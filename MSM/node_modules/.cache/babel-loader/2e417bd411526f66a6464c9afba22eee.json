{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:/Users/tzika/Desktop/Polymerlink-Front/polymerlink-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/tzika/Desktop/Polymerlink-Front/polymerlink-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _ = require(\"lodash\");\n\nvar ArgHandler = require(\"./ArgHandler\");\n\nvar addressConverter = require(\"./addressConverter\");\n\nvar dateConverter = require(\"./dateConverter\");\n\nvar regexify = require(\"./regexify\");\n\nvar xmlq = require(\"./xmlq\");\n\nvar FormulaError = require(\"./FormulaError\");\n\nvar Style = require(\"./Style\");\n\nvar RichText = require(\"./RichText\");\n/**\n * A cell\n */\n\n\nvar Cell = /*#__PURE__*/function () {\n  // /**\n  //  * Creates a new instance of cell.\n  //  * @param {Row} row - The parent row.\n  //  * @param {{}} node - The cell node.\n  //  */\n  function Cell(row, node, styleId) {\n    _classCallCheck(this, Cell);\n\n    this._row = row;\n\n    this._init(node, styleId);\n  }\n  /* PUBLIC */\n\n  /**\n   * Gets a value indicating whether the cell is the active cell in the sheet.\n   * @returns {boolean} True if active, false otherwise.\n   */\n\n  /**\n  * Make the cell the active cell in the sheet.\n  * @param {boolean} active - Must be set to `true`. Deactivating directly is not supported. To deactivate, you should activate a different cell instead.\n  * @returns {Cell} The cell.\n  */\n\n\n  _createClass(Cell, [{\n    key: \"active\",\n    value: function active() {\n      var _this = this;\n\n      return new ArgHandler('Cell.active').case(function () {\n        return _this.sheet().activeCell() === _this;\n      }).case('boolean', function (active) {\n        if (!active) throw new Error(\"Deactivating cell directly not supported. Activate a different cell instead.\");\n\n        _this.sheet().activeCell(_this);\n\n        return _this;\n      }).handle(arguments);\n    }\n    /**\n     * Get the address of the column.\n     * @param {{}} [opts] - Options\n     * @param {boolean} [opts.includeSheetName] - Include the sheet name in the address.\n     * @param {boolean} [opts.rowAnchored] - Anchor the row.\n     * @param {boolean} [opts.columnAnchored] - Anchor the column.\n     * @param {boolean} [opts.anchored] - Anchor both the row and the column.\n     * @returns {string} The address\n     */\n\n  }, {\n    key: \"address\",\n    value: function address(opts) {\n      return addressConverter.toAddress({\n        type: 'cell',\n        rowNumber: this.rowNumber(),\n        columnNumber: this.columnNumber(),\n        sheetName: opts && opts.includeSheetName && this.sheet().name(),\n        rowAnchored: opts && (opts.rowAnchored || opts.anchored),\n        columnAnchored: opts && (opts.columnAnchored || opts.anchored)\n      });\n    }\n    /**\n     * Gets the parent column of the cell.\n     * @returns {Column} The parent column.\n     */\n\n  }, {\n    key: \"column\",\n    value: function column() {\n      return this.sheet().column(this.columnNumber());\n    }\n    /**\n     * Clears the contents from the cell.\n     * @returns {Cell} The cell.\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var hostSharedFormulaId = this._formulaRef && this._sharedFormulaId;\n      delete this._value;\n      delete this._formulaType;\n      delete this._formula;\n      delete this._sharedFormulaId;\n      delete this._formulaRef; // TODO in future version: Move shared formula to some other cell. This would require parsing the formula...\n\n      if (!_.isNil(hostSharedFormulaId)) this.sheet().clearCellsUsingSharedFormula(hostSharedFormulaId);\n      return this;\n    }\n    /**\n     * Gets the column name of the cell.\n     * @returns {string} The column name.\n     */\n\n  }, {\n    key: \"columnName\",\n    value: function columnName() {\n      return addressConverter.columnNumberToName(this.columnNumber());\n    }\n    /**\n     * Gets the column number of the cell (1-based).\n     * @returns {number} The column number.\n     */\n\n  }, {\n    key: \"columnNumber\",\n    value: function columnNumber() {\n      return this._columnNumber;\n    }\n    /**\n     * Find the given pattern in the cell and optionally replace it.\n     * @param {string|RegExp} pattern - The pattern to look for. Providing a string will result in a case-insensitive substring search. Use a RegExp for more sophisticated searches.\n     * @param {string|function} [replacement] - The text to replace or a String.replace callback function. If pattern is a string, all occurrences of the pattern in the cell will be replaced.\n     * @returns {boolean} A flag indicating if the pattern was found.\n     */\n\n  }, {\n    key: \"find\",\n    value: function find(pattern, replacement) {\n      pattern = regexify(pattern);\n      var value = this.value();\n      if (typeof value !== 'string') return false;\n\n      if (_.isNil(replacement)) {\n        return pattern.test(value);\n      } else {\n        var replaced = value.replace(pattern, replacement);\n        if (replaced === value) return false;\n        this.value(replaced);\n        return true;\n      }\n    }\n    /**\n     * Gets the formula in the cell. Note that if a formula was set as part of a range, the getter will return 'SHARED'. This is a limitation that may be addressed in a future release.\n     * @returns {string} The formula in the cell.\n     */\n\n    /**\n    * Sets the formula in the cell.\n    * @param {string} formula - The formula to set.\n    * @returns {Cell} The cell.\n    */\n\n  }, {\n    key: \"formula\",\n    value: function formula() {\n      var _this2 = this;\n\n      return new ArgHandler('Cell.formula').case(function () {\n        // TODO in future: Return translated formula.\n        if (_this2._formulaType === \"shared\" && !_this2._formulaRef) return \"SHARED\";\n        return _this2._formula;\n      }).case('nil', function () {\n        _this2.clear();\n\n        return _this2;\n      }).case('string', function (formula) {\n        _this2.clear();\n\n        _this2._formulaType = \"normal\";\n        _this2._formula = formula;\n        return _this2;\n      }).handle(arguments);\n    }\n    /**\n     * Gets the hyperlink attached to the cell.\n     * @returns {string|undefined} The hyperlink or undefined if not set.\n     */\n\n    /**\n    * Set or clear the hyperlink on the cell.\n    * @param {string|Cell|undefined} hyperlink - The hyperlink to set or undefined to clear.\n    * @returns {Cell} The cell.\n    */\n\n    /**\n    * Set the hyperlink options on the cell.\n    * @param {{}|Cell} opts - Options or Cell. If opts is a Cell then an internal hyperlink is added.\n    * @param {string|Cell} [opts.hyperlink] - The hyperlink to set, can be a Cell or an internal/external string.\n    * @param {string} [opts.tooltip] - Additional text to help the user understand more about the hyperlink.\n    * @param {string} [opts.email] - Email address, ignored if opts.hyperlink is set.\n    * @param {string} [opts.emailSubject] - Email subject, ignored if opts.hyperlink is set.\n    * @returns {Cell} The cell.\n    */\n\n  }, {\n    key: \"hyperlink\",\n    value: function hyperlink() {\n      var _this3 = this;\n\n      return new ArgHandler('Cell.hyperlink').case(function () {\n        return _this3.sheet().hyperlink(_this3.address());\n      }).case('string', function (hyperlink) {\n        _this3.sheet().hyperlink(_this3.address(), hyperlink);\n\n        return _this3;\n      }).case(['object'], function (opts) {\n        _this3.sheet().hyperlink(_this3.address(), opts);\n\n        return _this3;\n      }).handle(arguments);\n    }\n    /**\n     * Gets the data validation object attached to the cell.\n     * @returns {object|undefined} The data validation or undefined if not set.\n     */\n\n    /**\n    * Set or clear the data validation object of the cell.\n    * @param {object|undefined} dataValidation - Object or null to clear.\n    * @returns {Cell} The cell.\n    */\n\n  }, {\n    key: \"dataValidation\",\n    value: function dataValidation() {\n      var _this4 = this;\n\n      return new ArgHandler('Cell.dataValidation').case(function () {\n        return _this4.sheet().dataValidation(_this4.address());\n      }).case('boolean', function (obj) {\n        return _this4.sheet().dataValidation(_this4.address(), obj);\n      }).case('*', function (obj) {\n        _this4.sheet().dataValidation(_this4.address(), obj);\n\n        return _this4;\n      }).handle(arguments);\n    }\n    /**\n     * Callback used by tap.\n     * @callback Cell~tapCallback\n     * @param {Cell} cell - The cell\n     * @returns {undefined}\n     */\n\n    /**\n    * Invoke a callback on the cell and return the cell. Useful for method chaining.\n    * @param {Cell~tapCallback} callback - The callback function.\n    * @returns {Cell} The cell.\n    */\n\n  }, {\n    key: \"tap\",\n    value: function tap(callback) {\n      callback(this);\n      return this;\n    }\n    /**\n     * Callback used by thru.\n     * @callback Cell~thruCallback\n     * @param {Cell} cell - The cell\n     * @returns {*} The value to return from thru.\n     */\n\n    /**\n    * Invoke a callback on the cell and return the value provided by the callback. Useful for method chaining.\n    * @param {Cell~thruCallback} callback - The callback function.\n    * @returns {*} The return value of the callback.\n    */\n\n  }, {\n    key: \"thru\",\n    value: function thru(callback) {\n      return callback(this);\n    }\n    /**\n     * Create a range from this cell and another.\n     * @param {Cell|string} cell - The other cell or cell address to range to.\n     * @returns {Range} The range.\n     */\n\n  }, {\n    key: \"rangeTo\",\n    value: function rangeTo(cell) {\n      return this.sheet().range(this, cell);\n    }\n    /**\n     * Returns a cell with a relative position given the offsets provided.\n     * @param {number} rowOffset - The row offset (0 for the current row).\n     * @param {number} columnOffset - The column offset (0 for the current column).\n     * @returns {Cell} The relative cell.\n     */\n\n  }, {\n    key: \"relativeCell\",\n    value: function relativeCell(rowOffset, columnOffset) {\n      var row = rowOffset + this.rowNumber();\n      var column = columnOffset + this.columnNumber();\n      return this.sheet().cell(row, column);\n    }\n    /**\n     * Gets the parent row of the cell.\n     * @returns {Row} The parent row.\n     */\n\n  }, {\n    key: \"row\",\n    value: function row() {\n      return this._row;\n    }\n    /**\n     * Gets the row number of the cell (1-based).\n     * @returns {number} The row number.\n     */\n\n  }, {\n    key: \"rowNumber\",\n    value: function rowNumber() {\n      return this.row().rowNumber();\n    }\n    /**\n     * Gets the parent sheet.\n     * @returns {Sheet} The parent sheet.\n     */\n\n  }, {\n    key: \"sheet\",\n    value: function sheet() {\n      return this.row().sheet();\n    }\n    /**\n     * Gets an individual style.\n     * @param {string} name - The name of the style.\n     * @returns {*} The style.\n     */\n\n    /**\n    * Gets multiple styles.\n    * @param {Array.<string>} names - The names of the style.\n    * @returns {object.<string, *>} Object whose keys are the style names and values are the styles.\n    */\n\n    /**\n    * Sets an individual style.\n    * @param {string} name - The name of the style.\n    * @param {*} value - The value to set.\n    * @returns {Cell} The cell.\n    */\n\n    /**\n    * Sets the styles in the range starting with the cell.\n    * @param {string} name - The name of the style.\n    * @param {Array.<Array.<*>>} - 2D array of values to set.\n    * @returns {Range} The range that was set.\n    */\n\n    /**\n    * Sets multiple styles.\n    * @param {object.<string, *>} styles - Object whose keys are the style names and values are the styles to set.\n    * @returns {Cell} The cell.\n    */\n\n    /**\n    * Sets to a specific style\n    * @param {Style} style - Style object given from stylesheet.createStyle\n    * @returns {Cell} The cell.\n    */\n\n  }, {\n    key: \"style\",\n    value: function style() {\n      var _this5 = this;\n\n      if (!this._style && !(arguments[0] instanceof Style)) {\n        this._style = this.workbook().styleSheet().createStyle(this._styleId);\n      }\n\n      return new ArgHandler(\"Cell.style\").case('string', function (name) {\n        // Get single value\n        return _this5._style.style(name);\n      }).case('array', function (names) {\n        // Get list of values\n        var values = {};\n        names.forEach(function (name) {\n          values[name] = _this5.style(name);\n        });\n        return values;\n      }).case([\"string\", \"array\"], function (name, values) {\n        var numRows = values.length;\n        var numCols = values[0].length;\n\n        var range = _this5.rangeTo(_this5.relativeCell(numRows - 1, numCols - 1));\n\n        return range.style(name, values);\n      }).case(['string', '*'], function (name, value) {\n        // Set a single value for all cells to a single value\n        _this5._style.style(name, value);\n\n        return _this5;\n      }).case('object', function (nameValues) {\n        // Object of key value pairs to set\n        for (var name in nameValues) {\n          if (!nameValues.hasOwnProperty(name)) continue;\n          var value = nameValues[name];\n\n          _this5.style(name, value);\n        }\n\n        return _this5;\n      }).case('Style', function (style) {\n        _this5._style = style;\n        _this5._styleId = style.id();\n        return _this5;\n      }).handle(arguments);\n    }\n    /**\n     * Gets the value of the cell.\n     * @returns {string|boolean|number|Date|RichText|undefined} The value of the cell.\n     */\n\n    /**\n    * Sets the value of the cell.\n    * @param {string|boolean|number|null|undefined|RichText} value - The value to set.\n    * @returns {Cell} The cell.\n    */\n\n    /**\n    * Sets the values in the range starting with the cell.\n    * @param {Array.<Array.<string|boolean|number|null|undefined>>} - 2D array of values to set.\n    * @returns {Range} The range that was set.\n    */\n\n  }, {\n    key: \"value\",\n    value: function value() {\n      var _this6 = this;\n\n      return new ArgHandler('Cell.value').case(function () {\n        if (_this6._value instanceof RichText) {\n          return _this6._value.getInstanceWithCellRef(_this6);\n        }\n\n        return _this6._value;\n      }).case(\"array\", function (values) {\n        var numRows = values.length;\n        var numCols = values[0].length;\n\n        var range = _this6.rangeTo(_this6.relativeCell(numRows - 1, numCols - 1));\n\n        return range.value(values);\n      }).case('*', function (value) {\n        _this6.clear();\n\n        if (value instanceof RichText) {\n          _this6._value = value.copy(_this6);\n        } else {\n          _this6._value = value;\n        }\n\n        return _this6;\n      }).handle(arguments);\n    }\n    /**\n     * Gets the parent workbook.\n     * @returns {Workbook} The parent workbook.\n     */\n\n  }, {\n    key: \"workbook\",\n    value: function workbook() {\n      return this.row().workbook();\n    }\n    /**\n     * Append horizontal page break after the cell.\n     * @returns {Cell} the cell.\n     */\n\n  }, {\n    key: \"addHorizontalPageBreak\",\n    value: function addHorizontalPageBreak() {\n      this.row().addPageBreak();\n      return this;\n    }\n    /* INTERNAL */\n\n    /**\n     * Gets the formula if a shared formula ref cell.\n     * @returns {string|undefined} The formula.\n     * @ignore\n     */\n\n  }, {\n    key: \"getSharedRefFormula\",\n    value: function getSharedRefFormula() {\n      return this._formulaType === \"shared\" ? this._formulaRef && this._formula : undefined;\n    }\n    /**\n     * Check if this cell uses a given shared a formula ID.\n     * @param {number} id - The shared formula ID.\n     * @returns {boolean} A flag indicating if shared.\n     * @ignore\n     */\n\n  }, {\n    key: \"sharesFormula\",\n    value: function sharesFormula(id) {\n      return this._formulaType === \"shared\" && this._sharedFormulaId === id;\n    }\n    /**\n     * Set a shared formula on the cell.\n     * @param {number} id - The shared formula index.\n     * @param {string} [formula] - The formula (if the reference cell).\n     * @param {string} [sharedRef] - The address of the shared range (if the reference cell).\n     * @returns {undefined}\n     * @ignore\n     */\n\n  }, {\n    key: \"setSharedFormula\",\n    value: function setSharedFormula(id, formula, sharedRef) {\n      this.clear();\n      this._formulaType = \"shared\";\n      this._sharedFormulaId = id;\n      this._formula = formula;\n      this._formulaRef = sharedRef;\n    }\n    /**\n     * Convert the cell to an XML object.\n     * @returns {{}} The XML form.\n     * @ignore\n     */\n\n  }, {\n    key: \"toXml\",\n    value: function toXml() {\n      // Create a node.\n      var node = {\n        name: 'c',\n        attributes: this._remainingAttributes || {},\n        // Start with any remaining attributes we don't current handle.\n        children: []\n      }; // Set the address.\n\n      node.attributes.r = this.address();\n\n      if (!_.isNil(this._formulaType)) {\n        // Add the formula.\n        var fNode = {\n          name: 'f',\n          attributes: this._remainingFormulaAttributes || {}\n        };\n        if (this._formulaType !== \"normal\") fNode.attributes.t = this._formulaType;\n        if (!_.isNil(this._formulaRef)) fNode.attributes.ref = this._formulaRef;\n        if (!_.isNil(this._sharedFormulaId)) fNode.attributes.si = this._sharedFormulaId;\n        if (!_.isNil(this._formula)) fNode.children = [this._formula];\n        node.children.push(fNode);\n      } else if (!_.isNil(this._value)) {\n        // Add the value. Don't emit value if a formula is set as Excel will show this stale value.\n        var type, text;\n\n        if (typeof this._value === \"string\") {\n          type = \"s\";\n          text = this.workbook().sharedStrings().getIndexForString(this._value);\n        } else if (typeof this._value === \"boolean\") {\n          type = \"b\";\n          text = this._value ? 1 : 0;\n        } else if (typeof this._value === \"number\") {\n          text = this._value;\n        } else if (this._value instanceof Date) {\n          text = dateConverter.dateToNumber(this._value);\n        } else if (this._value instanceof RichText || typeof this._value === \"object\" && this._value.constructor.name === \"RichText\") {\n          // Hack to make Jasmine test work\n          type = \"s\";\n          text = this.workbook().sharedStrings().getIndexForString(this._value.toXml());\n        }\n\n        if (type) node.attributes.t = type;\n        var vNode = {\n          name: 'v',\n          children: [text]\n        };\n        node.children.push(vNode);\n      } // If the style is set, set the style ID.\n\n\n      if (!_.isNil(this._style)) {\n        node.attributes.s = this._style.id();\n      } else if (!_.isNil(this._styleId)) {\n        node.attributes.s = this._styleId;\n      } // Add any remaining children that we don't currently handle.\n\n\n      if (this._remainingChildren) {\n        node.children = node.children.concat(this._remainingChildren);\n      }\n\n      return node;\n    }\n    /* PRIVATE */\n\n    /**\n     * Initialize the cell node.\n     * @param {{}|number} nodeOrColumnNumber - The existing node or the column number of a new cell.\n     * @param {number} [styleId] - The style ID for the new cell.\n     * @returns {undefined}\n     * @private\n     */\n\n  }, {\n    key: \"_init\",\n    value: function _init(nodeOrColumnNumber, styleId) {\n      if (_.isObject(nodeOrColumnNumber)) {\n        // Parse the existing node.\n        this._parseNode(nodeOrColumnNumber);\n      } else {\n        // This is a new cell.\n        this._columnNumber = nodeOrColumnNumber;\n        if (!_.isNil(styleId)) this._styleId = styleId;\n      }\n    }\n    /**\n     * Parse the existing node.\n     * @param {{}} node - The existing node.\n     * @returns {undefined}\n     * @private\n     */\n\n  }, {\n    key: \"_parseNode\",\n    value: function _parseNode(node) {\n      // Parse the column numbr out of the address.\n      var ref = addressConverter.fromAddress(node.attributes.r);\n      this._columnNumber = ref.columnNumber; // Store the style ID if present.\n\n      if (!_.isNil(node.attributes.s)) this._styleId = node.attributes.s; // Parse the formula if present..\n\n      var fNode = xmlq.findChild(node, 'f');\n\n      if (fNode) {\n        this._formulaType = fNode.attributes.t || \"normal\";\n        this._formulaRef = fNode.attributes.ref;\n        this._formula = fNode.children[0];\n        this._sharedFormulaId = fNode.attributes.si;\n\n        if (!_.isNil(this._sharedFormulaId)) {\n          // Update the sheet's max shared formula ID so we can set future IDs an index beyond this.\n          this.sheet().updateMaxSharedFormulaId(this._sharedFormulaId);\n        } // Delete the known attributes.\n\n\n        delete fNode.attributes.t;\n        delete fNode.attributes.ref;\n        delete fNode.attributes.si; // If any unknown attributes are still present, store them for later output.\n\n        if (!_.isEmpty(fNode.attributes)) this._remainingFormulaAttributes = fNode.attributes;\n      } // Parse the value.\n\n\n      var type = node.attributes.t;\n\n      if (type === \"s\") {\n        // String value.\n        var vNode = xmlq.findChild(node, 'v');\n\n        if (vNode) {\n          var sharedIndex = vNode.children[0];\n          this._value = this.workbook().sharedStrings().getStringByIndex(sharedIndex); // rich text\n\n          if (_.isArray(this._value)) {\n            this._value = new RichText(this._value);\n          }\n        } else {\n          this._value = '';\n        }\n      } else if (type === \"str\") {\n        // Simple string value.\n        var _vNode = xmlq.findChild(node, 'v');\n\n        this._value = _vNode && _vNode.children[0];\n      } else if (type === \"inlineStr\") {\n        // Inline string value: can be simple text or rich text.\n        var isNode = xmlq.findChild(node, 'is');\n\n        if (isNode.children[0].name === \"t\") {\n          var tNode = isNode.children[0];\n          this._value = tNode.children[0];\n        } else {\n          this._value = isNode.children;\n        }\n      } else if (type === \"b\") {\n        // Boolean value.\n        this._value = xmlq.findChild(node, 'v').children[0] === 1;\n      } else if (type === \"e\") {\n        // Error value.\n        var error = xmlq.findChild(node, 'v').children[0];\n        this._value = FormulaError.getError(error);\n      } else {\n        // Number value.\n        var _vNode2 = xmlq.findChild(node, 'v');\n\n        this._value = _vNode2 && Number(_vNode2.children[0]);\n      } // Delete known attributes.\n\n\n      delete node.attributes.r;\n      delete node.attributes.s;\n      delete node.attributes.t; // If any unknown attributes are still present, store them for later output.\n\n      if (!_.isEmpty(node.attributes)) this._remainingAttributes = node.attributes; // Delete known children.\n\n      xmlq.removeChild(node, 'f');\n      xmlq.removeChild(node, 'v');\n      xmlq.removeChild(node, 'is'); // If any unknown children are still present, store them for later output.\n\n      if (!_.isEmpty(node.children)) this._remainingChildren = node.children;\n    }\n  }]);\n\n  return Cell;\n}();\n\nmodule.exports = Cell;\n/*\n<c r=\"A6\" s=\"1\" t=\"s\">\n    <v>2</v>\n</c>\n*/","map":{"version":3,"sources":["C:/Users/tzika/Desktop/Polymerlink-Front/polymerlink-2/node_modules/xlsx-populate/lib/Cell.js"],"names":["_","require","ArgHandler","addressConverter","dateConverter","regexify","xmlq","FormulaError","Style","RichText","Cell","row","node","styleId","_row","_init","case","sheet","activeCell","active","Error","handle","arguments","opts","toAddress","type","rowNumber","columnNumber","sheetName","includeSheetName","name","rowAnchored","anchored","columnAnchored","column","hostSharedFormulaId","_formulaRef","_sharedFormulaId","_value","_formulaType","_formula","isNil","clearCellsUsingSharedFormula","columnNumberToName","_columnNumber","pattern","replacement","value","test","replaced","replace","clear","formula","hyperlink","address","dataValidation","obj","callback","cell","range","rowOffset","columnOffset","_style","workbook","styleSheet","createStyle","_styleId","style","names","values","forEach","numRows","length","numCols","rangeTo","relativeCell","nameValues","hasOwnProperty","id","getInstanceWithCellRef","copy","addPageBreak","undefined","sharedRef","attributes","_remainingAttributes","children","r","fNode","_remainingFormulaAttributes","t","ref","si","push","text","sharedStrings","getIndexForString","Date","dateToNumber","constructor","toXml","vNode","s","_remainingChildren","concat","nodeOrColumnNumber","isObject","_parseNode","fromAddress","findChild","updateMaxSharedFormulaId","isEmpty","sharedIndex","getStringByIndex","isArray","isNode","tNode","error","getError","Number","removeChild","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst _ = require(\"lodash\");\nconst ArgHandler = require(\"./ArgHandler\");\nconst addressConverter = require(\"./addressConverter\");\nconst dateConverter = require(\"./dateConverter\");\nconst regexify = require(\"./regexify\");\nconst xmlq = require(\"./xmlq\");\nconst FormulaError = require(\"./FormulaError\");\nconst Style = require(\"./Style\");\nconst RichText = require(\"./RichText\");\n\n/**\n * A cell\n */\nclass Cell {\n    // /**\n    //  * Creates a new instance of cell.\n    //  * @param {Row} row - The parent row.\n    //  * @param {{}} node - The cell node.\n    //  */\n    constructor(row, node, styleId) {\n        this._row = row;\n        this._init(node, styleId);\n    }\n\n    /* PUBLIC */\n\n    /**\n     * Gets a value indicating whether the cell is the active cell in the sheet.\n     * @returns {boolean} True if active, false otherwise.\n     *//**\n     * Make the cell the active cell in the sheet.\n     * @param {boolean} active - Must be set to `true`. Deactivating directly is not supported. To deactivate, you should activate a different cell instead.\n     * @returns {Cell} The cell.\n     */\n    active() {\n        return new ArgHandler('Cell.active')\n            .case(() => {\n                return this.sheet().activeCell() === this;\n            })\n            .case('boolean', active => {\n                if (!active) throw new Error(\"Deactivating cell directly not supported. Activate a different cell instead.\");\n                this.sheet().activeCell(this);\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Get the address of the column.\n     * @param {{}} [opts] - Options\n     * @param {boolean} [opts.includeSheetName] - Include the sheet name in the address.\n     * @param {boolean} [opts.rowAnchored] - Anchor the row.\n     * @param {boolean} [opts.columnAnchored] - Anchor the column.\n     * @param {boolean} [opts.anchored] - Anchor both the row and the column.\n     * @returns {string} The address\n     */\n    address(opts) {\n        return addressConverter.toAddress({\n            type: 'cell',\n            rowNumber: this.rowNumber(),\n            columnNumber: this.columnNumber(),\n            sheetName: opts && opts.includeSheetName && this.sheet().name(),\n            rowAnchored: opts && (opts.rowAnchored || opts.anchored),\n            columnAnchored: opts && (opts.columnAnchored || opts.anchored)\n        });\n    }\n\n    /**\n     * Gets the parent column of the cell.\n     * @returns {Column} The parent column.\n     */\n    column() {\n        return this.sheet().column(this.columnNumber());\n    }\n\n    /**\n     * Clears the contents from the cell.\n     * @returns {Cell} The cell.\n     */\n    clear() {\n        const hostSharedFormulaId = this._formulaRef && this._sharedFormulaId;\n\n        delete this._value;\n        delete this._formulaType;\n        delete this._formula;\n        delete this._sharedFormulaId;\n        delete this._formulaRef;\n\n        // TODO in future version: Move shared formula to some other cell. This would require parsing the formula...\n        if (!_.isNil(hostSharedFormulaId)) this.sheet().clearCellsUsingSharedFormula(hostSharedFormulaId);\n\n        return this;\n    }\n\n    /**\n     * Gets the column name of the cell.\n     * @returns {string} The column name.\n     */\n    columnName() {\n        return addressConverter.columnNumberToName(this.columnNumber());\n    }\n\n    /**\n     * Gets the column number of the cell (1-based).\n     * @returns {number} The column number.\n     */\n    columnNumber() {\n        return this._columnNumber;\n    }\n\n    /**\n     * Find the given pattern in the cell and optionally replace it.\n     * @param {string|RegExp} pattern - The pattern to look for. Providing a string will result in a case-insensitive substring search. Use a RegExp for more sophisticated searches.\n     * @param {string|function} [replacement] - The text to replace or a String.replace callback function. If pattern is a string, all occurrences of the pattern in the cell will be replaced.\n     * @returns {boolean} A flag indicating if the pattern was found.\n     */\n    find(pattern, replacement) {\n        pattern = regexify(pattern);\n\n        const value = this.value();\n        if (typeof value !== 'string') return false;\n\n        if (_.isNil(replacement)) {\n            return pattern.test(value);\n        } else {\n            const replaced = value.replace(pattern, replacement);\n            if (replaced === value) return false;\n            this.value(replaced);\n            return true;\n        }\n    }\n\n    /**\n     * Gets the formula in the cell. Note that if a formula was set as part of a range, the getter will return 'SHARED'. This is a limitation that may be addressed in a future release.\n     * @returns {string} The formula in the cell.\n     *//**\n     * Sets the formula in the cell.\n     * @param {string} formula - The formula to set.\n     * @returns {Cell} The cell.\n     */\n    formula() {\n        return new ArgHandler('Cell.formula')\n            .case(() => {\n                // TODO in future: Return translated formula.\n                if (this._formulaType === \"shared\" && !this._formulaRef) return \"SHARED\";\n                return this._formula;\n            })\n            .case('nil', () => {\n                this.clear();\n                return this;\n            })\n            .case('string', formula => {\n                this.clear();\n                this._formulaType = \"normal\";\n                this._formula = formula;\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Gets the hyperlink attached to the cell.\n     * @returns {string|undefined} The hyperlink or undefined if not set.\n     *//**\n     * Set or clear the hyperlink on the cell.\n     * @param {string|Cell|undefined} hyperlink - The hyperlink to set or undefined to clear.\n     * @returns {Cell} The cell.\n     *//**\n     * Set the hyperlink options on the cell.\n     * @param {{}|Cell} opts - Options or Cell. If opts is a Cell then an internal hyperlink is added.\n     * @param {string|Cell} [opts.hyperlink] - The hyperlink to set, can be a Cell or an internal/external string.\n     * @param {string} [opts.tooltip] - Additional text to help the user understand more about the hyperlink.\n     * @param {string} [opts.email] - Email address, ignored if opts.hyperlink is set.\n     * @param {string} [opts.emailSubject] - Email subject, ignored if opts.hyperlink is set.\n     * @returns {Cell} The cell.\n     */\n    hyperlink() {\n        return new ArgHandler('Cell.hyperlink')\n            .case(() => {\n                return this.sheet().hyperlink(this.address());\n            })\n            .case('string', hyperlink => {\n                this.sheet().hyperlink(this.address(), hyperlink);\n                return this;\n            })\n            .case(['object'], opts => {\n                this.sheet().hyperlink(this.address(), opts);\n                return this;\n            })\n            .handle(arguments);\n    }\n\n\n    /**\n     * Gets the data validation object attached to the cell.\n     * @returns {object|undefined} The data validation or undefined if not set.\n     *//**\n     * Set or clear the data validation object of the cell.\n     * @param {object|undefined} dataValidation - Object or null to clear.\n     * @returns {Cell} The cell.\n     */\n    dataValidation() {\n        return new ArgHandler('Cell.dataValidation')\n            .case(() => {\n                return this.sheet().dataValidation(this.address());\n            })\n            .case('boolean', obj => {\n                return this.sheet().dataValidation(this.address(), obj);\n            })\n            .case('*', obj => {\n                this.sheet().dataValidation(this.address(), obj);\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Callback used by tap.\n     * @callback Cell~tapCallback\n     * @param {Cell} cell - The cell\n     * @returns {undefined}\n     *//**\n     * Invoke a callback on the cell and return the cell. Useful for method chaining.\n     * @param {Cell~tapCallback} callback - The callback function.\n     * @returns {Cell} The cell.\n     */\n    tap(callback) {\n        callback(this);\n        return this;\n    }\n\n    /**\n     * Callback used by thru.\n     * @callback Cell~thruCallback\n     * @param {Cell} cell - The cell\n     * @returns {*} The value to return from thru.\n     *//**\n     * Invoke a callback on the cell and return the value provided by the callback. Useful for method chaining.\n     * @param {Cell~thruCallback} callback - The callback function.\n     * @returns {*} The return value of the callback.\n     */\n    thru(callback) {\n        return callback(this);\n    }\n\n    /**\n     * Create a range from this cell and another.\n     * @param {Cell|string} cell - The other cell or cell address to range to.\n     * @returns {Range} The range.\n     */\n    rangeTo(cell) {\n        return this.sheet().range(this, cell);\n    }\n\n    /**\n     * Returns a cell with a relative position given the offsets provided.\n     * @param {number} rowOffset - The row offset (0 for the current row).\n     * @param {number} columnOffset - The column offset (0 for the current column).\n     * @returns {Cell} The relative cell.\n     */\n    relativeCell(rowOffset, columnOffset) {\n        const row = rowOffset + this.rowNumber();\n        const column = columnOffset + this.columnNumber();\n        return this.sheet().cell(row, column);\n    }\n\n    /**\n     * Gets the parent row of the cell.\n     * @returns {Row} The parent row.\n     */\n    row() {\n        return this._row;\n    }\n\n    /**\n     * Gets the row number of the cell (1-based).\n     * @returns {number} The row number.\n     */\n    rowNumber() {\n        return this.row().rowNumber();\n    }\n\n    /**\n     * Gets the parent sheet.\n     * @returns {Sheet} The parent sheet.\n     */\n    sheet() {\n        return this.row().sheet();\n    }\n\n    /**\n     * Gets an individual style.\n     * @param {string} name - The name of the style.\n     * @returns {*} The style.\n     *//**\n     * Gets multiple styles.\n     * @param {Array.<string>} names - The names of the style.\n     * @returns {object.<string, *>} Object whose keys are the style names and values are the styles.\n     *//**\n     * Sets an individual style.\n     * @param {string} name - The name of the style.\n     * @param {*} value - The value to set.\n     * @returns {Cell} The cell.\n     *//**\n     * Sets the styles in the range starting with the cell.\n     * @param {string} name - The name of the style.\n     * @param {Array.<Array.<*>>} - 2D array of values to set.\n     * @returns {Range} The range that was set.\n     *//**\n     * Sets multiple styles.\n     * @param {object.<string, *>} styles - Object whose keys are the style names and values are the styles to set.\n     * @returns {Cell} The cell.\n     *//**\n     * Sets to a specific style\n     * @param {Style} style - Style object given from stylesheet.createStyle\n     * @returns {Cell} The cell.\n     */\n    style() {\n        if (!this._style && !(arguments[0] instanceof Style)) {\n            this._style = this.workbook().styleSheet().createStyle(this._styleId);\n        }\n\n        return new ArgHandler(\"Cell.style\")\n            .case('string', name => {\n                // Get single value\n                return this._style.style(name);\n            })\n            .case('array', names => {\n                // Get list of values\n                const values = {};\n                names.forEach(name => {\n                    values[name] = this.style(name);\n                });\n\n                return values;\n            })\n            .case([\"string\", \"array\"], (name, values) => {\n                const numRows = values.length;\n                const numCols = values[0].length;\n                const range = this.rangeTo(this.relativeCell(numRows - 1, numCols - 1));\n                return range.style(name, values);\n            })\n            .case(['string', '*'], (name, value) => {\n                // Set a single value for all cells to a single value\n                this._style.style(name, value);\n                return this;\n            })\n            .case('object', nameValues => {\n                // Object of key value pairs to set\n                for (const name in nameValues) {\n                    if (!nameValues.hasOwnProperty(name)) continue;\n                    const value = nameValues[name];\n                    this.style(name, value);\n                }\n\n                return this;\n            })\n            .case('Style', style => {\n                this._style = style;\n                this._styleId = style.id();\n\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Gets the value of the cell.\n     * @returns {string|boolean|number|Date|RichText|undefined} The value of the cell.\n     *//**\n     * Sets the value of the cell.\n     * @param {string|boolean|number|null|undefined|RichText} value - The value to set.\n     * @returns {Cell} The cell.\n     *//**\n     * Sets the values in the range starting with the cell.\n     * @param {Array.<Array.<string|boolean|number|null|undefined>>} - 2D array of values to set.\n     * @returns {Range} The range that was set.\n     */\n    value() {\n        return new ArgHandler('Cell.value')\n            .case(() => {\n                if (this._value instanceof RichText) {\n                    return this._value.getInstanceWithCellRef(this);\n                }\n                return this._value;\n            })\n            .case(\"array\", values => {\n                const numRows = values.length;\n                const numCols = values[0].length;\n                const range = this.rangeTo(this.relativeCell(numRows - 1, numCols - 1));\n                return range.value(values);\n            })\n            .case('*', value => {\n                this.clear();\n                if (value instanceof RichText) {\n                    this._value = value.copy(this);\n                } else {\n                    this._value = value;\n                }\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Gets the parent workbook.\n     * @returns {Workbook} The parent workbook.\n     */\n    workbook() {\n        return this.row().workbook();\n    }\n\n    /**\n     * Append horizontal page break after the cell.\n     * @returns {Cell} the cell.\n     */\n    addHorizontalPageBreak() {\n        this.row().addPageBreak();\n        return this;\n    }\n\n    /* INTERNAL */\n\n    /**\n     * Gets the formula if a shared formula ref cell.\n     * @returns {string|undefined} The formula.\n     * @ignore\n     */\n    getSharedRefFormula() {\n        return this._formulaType === \"shared\" ? this._formulaRef && this._formula : undefined;\n    }\n\n    /**\n     * Check if this cell uses a given shared a formula ID.\n     * @param {number} id - The shared formula ID.\n     * @returns {boolean} A flag indicating if shared.\n     * @ignore\n     */\n    sharesFormula(id) {\n        return this._formulaType === \"shared\" && this._sharedFormulaId === id;\n    }\n\n    /**\n     * Set a shared formula on the cell.\n     * @param {number} id - The shared formula index.\n     * @param {string} [formula] - The formula (if the reference cell).\n     * @param {string} [sharedRef] - The address of the shared range (if the reference cell).\n     * @returns {undefined}\n     * @ignore\n     */\n    setSharedFormula(id, formula, sharedRef) {\n        this.clear();\n\n        this._formulaType = \"shared\";\n        this._sharedFormulaId = id;\n        this._formula = formula;\n        this._formulaRef = sharedRef;\n    }\n\n    /**\n     * Convert the cell to an XML object.\n     * @returns {{}} The XML form.\n     * @ignore\n     */\n    toXml() {\n        // Create a node.\n        const node = {\n            name: 'c',\n            attributes: this._remainingAttributes || {}, // Start with any remaining attributes we don't current handle.\n            children: []\n        };\n\n        // Set the address.\n        node.attributes.r = this.address();\n\n        if (!_.isNil(this._formulaType)) {\n            // Add the formula.\n            const fNode = {\n                name: 'f',\n                attributes: this._remainingFormulaAttributes || {}\n            };\n\n            if (this._formulaType !== \"normal\") fNode.attributes.t = this._formulaType;\n            if (!_.isNil(this._formulaRef)) fNode.attributes.ref = this._formulaRef;\n            if (!_.isNil(this._sharedFormulaId)) fNode.attributes.si = this._sharedFormulaId;\n            if (!_.isNil(this._formula)) fNode.children = [this._formula];\n\n            node.children.push(fNode);\n        } else if (!_.isNil(this._value)) {\n            // Add the value. Don't emit value if a formula is set as Excel will show this stale value.\n            let type, text;\n            if (typeof this._value === \"string\") {\n                type = \"s\";\n                text = this.workbook().sharedStrings().getIndexForString(this._value);\n            } else if (typeof this._value === \"boolean\") {\n                type = \"b\";\n                text = this._value ? 1 : 0;\n            } else if (typeof this._value === \"number\") {\n                text = this._value;\n            } else if (this._value instanceof Date) {\n                text = dateConverter.dateToNumber(this._value);\n            } else if (this._value instanceof RichText || typeof this._value === \"object\" && this._value.constructor.name === \"RichText\") { // Hack to make Jasmine test work\n                type = \"s\";\n                text = this.workbook().sharedStrings().getIndexForString(this._value.toXml());\n            }\n\n            if (type) node.attributes.t = type;\n            const vNode = { name: 'v', children: [text] };\n            node.children.push(vNode);\n        }\n\n        // If the style is set, set the style ID.\n        if (!_.isNil(this._style)) {\n            node.attributes.s = this._style.id();\n        } else if (!_.isNil(this._styleId)) {\n            node.attributes.s = this._styleId;\n        }\n\n        // Add any remaining children that we don't currently handle.\n        if (this._remainingChildren) {\n            node.children = node.children.concat(this._remainingChildren);\n        }\n\n        return node;\n    }\n\n    /* PRIVATE */\n\n    /**\n     * Initialize the cell node.\n     * @param {{}|number} nodeOrColumnNumber - The existing node or the column number of a new cell.\n     * @param {number} [styleId] - The style ID for the new cell.\n     * @returns {undefined}\n     * @private\n     */\n    _init(nodeOrColumnNumber, styleId) {\n        if (_.isObject(nodeOrColumnNumber)) {\n            // Parse the existing node.\n            this._parseNode(nodeOrColumnNumber);\n        } else {\n            // This is a new cell.\n            this._columnNumber = nodeOrColumnNumber;\n            if (!_.isNil(styleId)) this._styleId = styleId;\n        }\n    }\n\n    /**\n     * Parse the existing node.\n     * @param {{}} node - The existing node.\n     * @returns {undefined}\n     * @private\n     */\n    _parseNode(node) {\n        // Parse the column numbr out of the address.\n        const ref = addressConverter.fromAddress(node.attributes.r);\n        this._columnNumber = ref.columnNumber;\n\n        // Store the style ID if present.\n        if (!_.isNil(node.attributes.s)) this._styleId = node.attributes.s;\n\n        // Parse the formula if present..\n        const fNode = xmlq.findChild(node, 'f');\n        if (fNode) {\n            this._formulaType = fNode.attributes.t || \"normal\";\n            this._formulaRef = fNode.attributes.ref;\n            this._formula = fNode.children[0];\n\n            this._sharedFormulaId = fNode.attributes.si;\n            if (!_.isNil(this._sharedFormulaId)) {\n                // Update the sheet's max shared formula ID so we can set future IDs an index beyond this.\n                this.sheet().updateMaxSharedFormulaId(this._sharedFormulaId);\n            }\n\n            // Delete the known attributes.\n            delete fNode.attributes.t;\n            delete fNode.attributes.ref;\n            delete fNode.attributes.si;\n\n            // If any unknown attributes are still present, store them for later output.\n            if (!_.isEmpty(fNode.attributes)) this._remainingFormulaAttributes = fNode.attributes;\n        }\n\n        // Parse the value.\n        const type = node.attributes.t;\n        if (type === \"s\") {\n            // String value.\n            const vNode = xmlq.findChild(node, 'v');\n            if (vNode) {\n                const sharedIndex = vNode.children[0];\n                this._value = this.workbook().sharedStrings().getStringByIndex(sharedIndex);\n\n                // rich text\n                if (_.isArray(this._value)) {\n                    this._value = new RichText(this._value);\n                }\n            } else {\n                this._value = '';\n            }\n        } else if (type === \"str\") {\n            // Simple string value.\n            const vNode = xmlq.findChild(node, 'v');\n            this._value = vNode && vNode.children[0];\n        } else if (type === \"inlineStr\") {\n            // Inline string value: can be simple text or rich text.\n            const isNode = xmlq.findChild(node, 'is');\n            if (isNode.children[0].name === \"t\") {\n                const tNode = isNode.children[0];\n                this._value = tNode.children[0];\n            } else {\n                this._value = isNode.children;\n            }\n        } else if (type === \"b\") {\n            // Boolean value.\n            this._value = xmlq.findChild(node, 'v').children[0] === 1;\n        } else if (type === \"e\") {\n            // Error value.\n            const error = xmlq.findChild(node, 'v').children[0];\n            this._value = FormulaError.getError(error);\n        } else {\n            // Number value.\n            const vNode = xmlq.findChild(node, 'v');\n            this._value = vNode && Number(vNode.children[0]);\n        }\n\n        // Delete known attributes.\n        delete node.attributes.r;\n        delete node.attributes.s;\n        delete node.attributes.t;\n\n        // If any unknown attributes are still present, store them for later output.\n        if (!_.isEmpty(node.attributes)) this._remainingAttributes = node.attributes;\n\n        // Delete known children.\n        xmlq.removeChild(node, 'f');\n        xmlq.removeChild(node, 'v');\n        xmlq.removeChild(node, 'is');\n\n        // If any unknown children are still present, store them for later output.\n        if (!_.isEmpty(node.children)) this._remainingChildren = node.children;\n    }\n}\n\nmodule.exports = Cell;\n\n/*\n<c r=\"A6\" s=\"1\" t=\"s\">\n    <v>2</v>\n</c>\n*/\n\n"]},"metadata":{},"sourceType":"script"}