{"ast":null,"code":"\"use strict\";\n\nconst sax = require(\"sax\");\n\nconst externals = require(\"./externals\"); // Regex to check if string is all whitespace.\n\n\nconst allWhitespaceRegex = /^\\s+$/;\n/**\n * XML parser.\n * @private\n */\n\nclass XmlParser {\n  /**\n   * Parse the XML text into a JSON object.\n   * @param {string} xmlText - The XML text.\n   * @returns {{}} The JSON object.\n   */\n  parseAsync(xmlText) {\n    return new externals.Promise((resolve, reject) => {\n      // Create the SAX parser.\n      const parser = sax.parser(true); // Parsed is the full parsed object. Current is the current node being parsed. Stack is the current stack of\n      // nodes leading to the current one.\n\n      let parsed, current;\n      const stack = []; // On error: Reject the promise.\n\n      parser.onerror = reject; // On text nodes: If it is all whitespace, do nothing. Otherwise, try to convert to a number and add as a child.\n\n      parser.ontext = text => {\n        if (allWhitespaceRegex.test(text)) {\n          if (current && current.attributes['xml:space'] === 'preserve') {\n            current.children.push(text);\n          }\n        } else {\n          current.children.push(this._covertToNumberIfNumber(text));\n        }\n      }; // On open tag start: Create a child element. If this is the root element, set it as parsed. Otherwise, add\n      // it as a child to the current node.\n\n\n      parser.onopentagstart = node => {\n        const child = {\n          name: node.name,\n          attributes: {},\n          children: []\n        };\n\n        if (current) {\n          current.children.push(child);\n        } else {\n          parsed = child;\n        }\n\n        stack.push(child);\n        current = child;\n      }; // On close tag: Pop the stack.\n\n\n      parser.onclosetag = node => {\n        stack.pop();\n        current = stack[stack.length - 1];\n      }; // On attribute: Try to convert the value to a number and add to the current node.\n\n\n      parser.onattribute = attribute => {\n        current.attributes[attribute.name] = this._covertToNumberIfNumber(attribute.value);\n      }; // On end: Resolve the promise.\n\n\n      parser.onend = () => resolve(parsed); // Start parsing the text.\n\n\n      parser.write(xmlText).close();\n    });\n  }\n  /**\n   * Convert the string to a number if it looks like one.\n   * @param {string} str - The string to convert.\n   * @returns {string|number} The number if converted or the string if not.\n   * @private\n   */\n\n\n  _covertToNumberIfNumber(str) {\n    const num = Number(str);\n    return num.toString() === str ? num : str;\n  }\n\n}\n\nmodule.exports = XmlParser;","map":{"version":3,"sources":["C:/Users/tatac/Desktop/MSM-Front/MSM/node_modules/xlsx-populate/lib/XmlParser.js"],"names":["sax","require","externals","allWhitespaceRegex","XmlParser","parseAsync","xmlText","Promise","resolve","reject","parser","parsed","current","stack","onerror","ontext","text","test","attributes","children","push","_covertToNumberIfNumber","onopentagstart","node","child","name","onclosetag","pop","length","onattribute","attribute","value","onend","write","close","str","num","Number","toString","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,GAAG,GAAGC,OAAO,CAAC,KAAD,CAAnB;;AACA,MAAMC,SAAS,GAAGD,OAAO,CAAC,aAAD,CAAzB,C,CAEA;;;AACA,MAAME,kBAAkB,GAAG,OAA3B;AAEA;AACA;AACA;AACA;;AACA,MAAMC,SAAN,CAAgB;AACZ;AACJ;AACA;AACA;AACA;AACIC,EAAAA,UAAU,CAACC,OAAD,EAAU;AAChB,WAAO,IAAIJ,SAAS,CAACK,OAAd,CAAsB,CAACC,OAAD,EAAUC,MAAV,KAAqB;AAC9C;AACA,YAAMC,MAAM,GAAGV,GAAG,CAACU,MAAJ,CAAW,IAAX,CAAf,CAF8C,CAI9C;AACA;;AACA,UAAIC,MAAJ,EAAYC,OAAZ;AACA,YAAMC,KAAK,GAAG,EAAd,CAP8C,CAS9C;;AACAH,MAAAA,MAAM,CAACI,OAAP,GAAiBL,MAAjB,CAV8C,CAY9C;;AACAC,MAAAA,MAAM,CAACK,MAAP,GAAgBC,IAAI,IAAI;AACpB,YAAIb,kBAAkB,CAACc,IAAnB,CAAwBD,IAAxB,CAAJ,EAAmC;AAC/B,cAAIJ,OAAO,IAAIA,OAAO,CAACM,UAAR,CAAmB,WAAnB,MAAoC,UAAnD,EAA+D;AAC3DN,YAAAA,OAAO,CAACO,QAAR,CAAiBC,IAAjB,CAAsBJ,IAAtB;AACH;AACJ,SAJD,MAIO;AACHJ,UAAAA,OAAO,CAACO,QAAR,CAAiBC,IAAjB,CAAsB,KAAKC,uBAAL,CAA6BL,IAA7B,CAAtB;AACH;AACJ,OARD,CAb8C,CAuB9C;AACA;;;AACAN,MAAAA,MAAM,CAACY,cAAP,GAAwBC,IAAI,IAAI;AAC5B,cAAMC,KAAK,GAAG;AAAEC,UAAAA,IAAI,EAAEF,IAAI,CAACE,IAAb;AAAmBP,UAAAA,UAAU,EAAE,EAA/B;AAAmCC,UAAAA,QAAQ,EAAE;AAA7C,SAAd;;AACA,YAAIP,OAAJ,EAAa;AACTA,UAAAA,OAAO,CAACO,QAAR,CAAiBC,IAAjB,CAAsBI,KAAtB;AACH,SAFD,MAEO;AACHb,UAAAA,MAAM,GAAGa,KAAT;AACH;;AAEDX,QAAAA,KAAK,CAACO,IAAN,CAAWI,KAAX;AACAZ,QAAAA,OAAO,GAAGY,KAAV;AACH,OAVD,CAzB8C,CAqC9C;;;AACAd,MAAAA,MAAM,CAACgB,UAAP,GAAoBH,IAAI,IAAI;AACxBV,QAAAA,KAAK,CAACc,GAAN;AACAf,QAAAA,OAAO,GAAGC,KAAK,CAACA,KAAK,CAACe,MAAN,GAAe,CAAhB,CAAf;AACH,OAHD,CAtC8C,CA2C9C;;;AACAlB,MAAAA,MAAM,CAACmB,WAAP,GAAqBC,SAAS,IAAI;AAC9BlB,QAAAA,OAAO,CAACM,UAAR,CAAmBY,SAAS,CAACL,IAA7B,IAAqC,KAAKJ,uBAAL,CAA6BS,SAAS,CAACC,KAAvC,CAArC;AACH,OAFD,CA5C8C,CAgD9C;;;AACArB,MAAAA,MAAM,CAACsB,KAAP,GAAe,MAAMxB,OAAO,CAACG,MAAD,CAA5B,CAjD8C,CAmD9C;;;AACAD,MAAAA,MAAM,CAACuB,KAAP,CAAa3B,OAAb,EAAsB4B,KAAtB;AACH,KArDM,CAAP;AAsDH;AAED;AACJ;AACA;AACA;AACA;AACA;;;AACIb,EAAAA,uBAAuB,CAACc,GAAD,EAAM;AACzB,UAAMC,GAAG,GAAGC,MAAM,CAACF,GAAD,CAAlB;AACA,WAAOC,GAAG,CAACE,QAAJ,OAAmBH,GAAnB,GAAyBC,GAAzB,GAA+BD,GAAtC;AACH;;AAxEW;;AA2EhBI,MAAM,CAACC,OAAP,GAAiBpC,SAAjB","sourcesContent":["\"use strict\";\n\nconst sax = require(\"sax\");\nconst externals = require(\"./externals\");\n\n// Regex to check if string is all whitespace.\nconst allWhitespaceRegex = /^\\s+$/;\n\n/**\n * XML parser.\n * @private\n */\nclass XmlParser {\n    /**\n     * Parse the XML text into a JSON object.\n     * @param {string} xmlText - The XML text.\n     * @returns {{}} The JSON object.\n     */\n    parseAsync(xmlText) {\n        return new externals.Promise((resolve, reject) => {\n            // Create the SAX parser.\n            const parser = sax.parser(true);\n\n            // Parsed is the full parsed object. Current is the current node being parsed. Stack is the current stack of\n            // nodes leading to the current one.\n            let parsed, current;\n            const stack = [];\n\n            // On error: Reject the promise.\n            parser.onerror = reject;\n\n            // On text nodes: If it is all whitespace, do nothing. Otherwise, try to convert to a number and add as a child.\n            parser.ontext = text => {\n                if (allWhitespaceRegex.test(text)) {\n                    if (current && current.attributes['xml:space'] === 'preserve') {\n                        current.children.push(text);\n                    }\n                } else {\n                    current.children.push(this._covertToNumberIfNumber(text));\n                }\n            };\n\n            // On open tag start: Create a child element. If this is the root element, set it as parsed. Otherwise, add\n            // it as a child to the current node.\n            parser.onopentagstart = node => {\n                const child = { name: node.name, attributes: {}, children: [] };\n                if (current) {\n                    current.children.push(child);\n                } else {\n                    parsed = child;\n                }\n\n                stack.push(child);\n                current = child;\n            };\n\n            // On close tag: Pop the stack.\n            parser.onclosetag = node => {\n                stack.pop();\n                current = stack[stack.length - 1];\n            };\n\n            // On attribute: Try to convert the value to a number and add to the current node.\n            parser.onattribute = attribute => {\n                current.attributes[attribute.name] = this._covertToNumberIfNumber(attribute.value);\n            };\n\n            // On end: Resolve the promise.\n            parser.onend = () => resolve(parsed);\n\n            // Start parsing the text.\n            parser.write(xmlText).close();\n        });\n    }\n\n    /**\n     * Convert the string to a number if it looks like one.\n     * @param {string} str - The string to convert.\n     * @returns {string|number} The number if converted or the string if not.\n     * @private\n     */\n    _covertToNumberIfNumber(str) {\n        const num = Number(str);\n        return num.toString() === str ? num : str;\n    }\n}\n\nmodule.exports = XmlParser;\n"]},"metadata":{},"sourceType":"script"}