{"ast":null,"code":"\"use strict\";\n\nconst _ = require(\"lodash\");\n\nconst Cell = require(\"./Cell\");\n\nconst regexify = require(\"./regexify\");\n\nconst ArgHandler = require(\"./ArgHandler\");\n\nconst addressConverter = require('./addressConverter');\n/**\n * A row.\n */\n\n\nclass Row {\n  // /**\n  //  * Creates a new instance of Row.\n  //  * @param {Sheet} sheet - The parent sheet.\n  //  * @param {{}} node - The row node.\n  //  */\n  constructor(sheet, node) {\n    this._sheet = sheet;\n\n    this._init(node);\n  }\n  /* PUBLIC */\n\n  /**\n   * Get the address of the row.\n   * @param {{}} [opts] - Options\n   * @param {boolean} [opts.includeSheetName] - Include the sheet name in the address.\n   * @param {boolean} [opts.anchored] - Anchor the address.\n   * @returns {string} The address\n   */\n\n\n  address(opts) {\n    return addressConverter.toAddress({\n      type: 'row',\n      rowNumber: this.rowNumber(),\n      sheetName: opts && opts.includeSheetName && this.sheet().name(),\n      rowAnchored: opts && opts.anchored\n    });\n  }\n  /**\n   * Get a cell in the row.\n   * @param {string|number} columnNameOrNumber - The name or number of the column.\n   * @returns {Cell} The cell.\n   */\n\n\n  cell(columnNameOrNumber) {\n    let columnNumber = columnNameOrNumber;\n\n    if (typeof columnNameOrNumber === 'string') {\n      columnNumber = addressConverter.columnNameToNumber(columnNameOrNumber);\n    }\n\n    if (columnNumber < 1) throw new RangeError(`Invalid column number ${columnNumber}. Remember that spreadsheets use 1-based indexing.`); // Return an existing cell.\n\n    if (this._cells[columnNumber]) return this._cells[columnNumber]; // No cell exists for this.\n    // Check if there is an existing row/column style for the new cell.\n\n    let styleId;\n    const rowStyleId = this._node.attributes.s;\n    const columnStyleId = this.sheet().existingColumnStyleId(columnNumber); // Row style takes priority. If a cell has both row and column styles it should have created a cell entry with a cell-specific style.\n\n    if (!_.isNil(rowStyleId)) styleId = rowStyleId;else if (!_.isNil(columnStyleId)) styleId = columnStyleId; // Create the new cell.\n\n    const cell = new Cell(this, columnNumber, styleId);\n    this._cells[columnNumber] = cell;\n    return cell;\n  }\n  /**\n   * Gets the row height.\n   * @returns {undefined|number} The height (or undefined).\n   */\n\n  /**\n  * Sets the row height.\n  * @param {number} height - The height of the row.\n  * @returns {Row} The row.\n  */\n\n\n  height() {\n    return new ArgHandler('Row.height').case(() => {\n      return this._node.attributes.customHeight ? this._node.attributes.ht : undefined;\n    }).case('number', height => {\n      this._node.attributes.ht = height;\n      this._node.attributes.customHeight = 1;\n      return this;\n    }).case('nil', () => {\n      delete this._node.attributes.ht;\n      delete this._node.attributes.customHeight;\n      return this;\n    }).handle(arguments);\n  }\n  /**\n   * Gets a value indicating whether the row is hidden.\n   * @returns {boolean} A flag indicating whether the row is hidden.\n   */\n\n  /**\n  * Sets whether the row is hidden.\n  * @param {boolean} hidden - A flag indicating whether to hide the row.\n  * @returns {Row} The row.\n  */\n\n\n  hidden() {\n    return new ArgHandler(\"Row.hidden\").case(() => {\n      return this._node.attributes.hidden === 1;\n    }).case('boolean', hidden => {\n      if (hidden) this._node.attributes.hidden = 1;else delete this._node.attributes.hidden;\n      return this;\n    }).handle(arguments);\n  }\n  /**\n   * Gets the row number.\n   * @returns {number} The row number.\n   */\n\n\n  rowNumber() {\n    return this._node.attributes.r;\n  }\n  /**\n   * Gets the parent sheet of the row.\n   * @returns {Sheet} The parent sheet.\n   */\n\n\n  sheet() {\n    return this._sheet;\n  }\n  /**\n   * Gets an individual style.\n   * @param {string} name - The name of the style.\n   * @returns {*} The style.\n   */\n\n  /**\n  * Gets multiple styles.\n  * @param {Array.<string>} names - The names of the style.\n  * @returns {object.<string, *>} Object whose keys are the style names and values are the styles.\n  */\n\n  /**\n  * Sets an individual style.\n  * @param {string} name - The name of the style.\n  * @param {*} value - The value to set.\n  * @returns {Cell} The cell.\n  */\n\n  /**\n  * Sets multiple styles.\n  * @param {object.<string, *>} styles - Object whose keys are the style names and values are the styles to set.\n  * @returns {Cell} The cell.\n  */\n\n  /**\n  * Sets to a specific style\n  * @param {Style} style - Style object given from stylesheet.createStyle\n  * @returns {Cell} The cell.\n  */\n\n\n  style() {\n    return new ArgHandler(\"Row.style\").case('string', name => {\n      // Get single value\n      this._createStyleIfNeeded();\n\n      return this._style.style(name);\n    }).case('array', names => {\n      // Get list of values\n      const values = {};\n      names.forEach(name => {\n        values[name] = this.style(name);\n      });\n      return values;\n    }).case(['string', '*'], (name, value) => {\n      this._createCellStylesIfNeeded(); // Style each existing cell within this row. (Cells don't inherit ow/column styles.)\n\n\n      _.forEach(this._cells, cell => {\n        if (cell) cell.style(name, value);\n      }); // Set the style on the row.\n\n\n      this._createStyleIfNeeded();\n\n      this._style.style(name, value);\n\n      return this;\n    }).case('object', nameValues => {\n      // Object of key value pairs to set\n      for (const name in nameValues) {\n        if (!nameValues.hasOwnProperty(name)) continue;\n        const value = nameValues[name];\n        this.style(name, value);\n      }\n\n      return this;\n    }).case('Style', style => {\n      this._createCellStylesIfNeeded(); // Style each existing cell within this row. (Cells don't inherit ow/column styles.)\n\n\n      _.forEach(this._cells, cell => {\n        if (cell) cell.style(style);\n      });\n\n      this._style = style;\n      this._node.attributes.s = style.id();\n      this._node.attributes.customFormat = 1;\n      return this;\n    }).handle(arguments);\n  }\n  /**\n   * Get the parent workbook.\n   * @returns {Workbook} The parent workbook.\n   */\n\n\n  workbook() {\n    return this.sheet().workbook();\n  }\n  /**\n   * Append horizontal page break after the row.\n   * @returns {Row} the row.\n   */\n\n\n  addPageBreak() {\n    this.sheet().horizontalPageBreaks().add(this.rowNumber());\n    return this;\n  }\n  /* INTERNAL */\n\n  /**\n   * Clear cells that are using a given shared formula ID.\n   * @param {number} sharedFormulaId - The shared formula ID.\n   * @returns {undefined}\n   * @ignore\n   */\n\n\n  clearCellsUsingSharedFormula(sharedFormulaId) {\n    this._cells.forEach(cell => {\n      if (!cell) return;\n      if (cell.sharesFormula(sharedFormulaId)) cell.clear();\n    });\n  }\n  /**\n   * Find a pattern in the row and optionally replace it.\n   * @param {string|RegExp} pattern - The search pattern.\n   * @param {string} [replacement] - The replacement text.\n   * @returns {Array.<Cell>} The matched cells.\n   * @ignore\n   */\n\n\n  find(pattern, replacement) {\n    pattern = regexify(pattern);\n    const matches = [];\n\n    this._cells.forEach(cell => {\n      if (!cell) return;\n      if (cell.find(pattern, replacement)) matches.push(cell);\n    });\n\n    return matches;\n  }\n  /**\n   * Check if the row has a cell at the given column number.\n   * @param {number} columnNumber - The column number.\n   * @returns {boolean} True if a cell exists, false otherwise.\n   * @ignore\n   */\n\n\n  hasCell(columnNumber) {\n    if (columnNumber < 1) throw new RangeError(`Invalid column number ${columnNumber}. Remember that spreadsheets use 1-based indexing.`);\n    return !!this._cells[columnNumber];\n  }\n  /**\n   * Check if the column has a style defined.\n   * @returns {boolean} True if a style exists, false otherwise.\n   * @ignore\n   */\n\n\n  hasStyle() {\n    return !_.isNil(this._node.attributes.s);\n  }\n  /**\n   * Returns the nax used column number.\n   * @returns {number} The max used column number.\n   * @ignore\n   */\n\n\n  minUsedColumnNumber() {\n    return _.findIndex(this._cells);\n  }\n  /**\n   * Returns the nax used column number.\n   * @returns {number} The max used column number.\n   * @ignore\n   */\n\n\n  maxUsedColumnNumber() {\n    return this._cells.length - 1;\n  }\n  /**\n   * Convert the row to an object.\n   * @returns {{}} The object form.\n   * @ignore\n   */\n\n\n  toXml() {\n    return this._node;\n  }\n  /* PRIVATE */\n\n  /**\n   * If a column node is already defined that intersects with this row and that column has a style set, we\n   * need to make sure that a cell node exists at the intersection so we can style it appropriately.\n   * Fetching the cell will force a new cell node to be created with a style matching the column.\n   * @returns {undefined}\n   * @private\n   */\n\n\n  _createCellStylesIfNeeded() {\n    this.sheet().forEachExistingColumnNumber(columnNumber => {\n      if (!_.isNil(this.sheet().existingColumnStyleId(columnNumber))) this.cell(columnNumber);\n    });\n  }\n  /**\n   * Create a style for this row if it doesn't already exist.\n   * @returns {undefined}\n   * @private\n   */\n\n\n  _createStyleIfNeeded() {\n    if (!this._style) {\n      const styleId = this._node.attributes.s;\n      this._style = this.workbook().styleSheet().createStyle(styleId);\n      this._node.attributes.s = this._style.id();\n      this._node.attributes.customFormat = 1;\n    }\n  }\n  /**\n   * Initialize the row node.\n   * @param {{}} node - The row node.\n   * @returns {undefined}\n   * @private\n   */\n\n\n  _init(node) {\n    this._node = node;\n    this._cells = [];\n\n    this._node.children.forEach(cellNode => {\n      const cell = new Cell(this, cellNode);\n      this._cells[cell.columnNumber()] = cell;\n    });\n\n    this._node.children = this._cells;\n  }\n\n}\n\nmodule.exports = Row;\n/*\n<row r=\"6\" spans=\"1:9\" x14ac:dyDescent=\"0.25\">\n    <c r=\"A6\" s=\"1\" t=\"s\">\n        <v>2</v>\n    </c>\n    <c r=\"B6\" s=\"1\"/>\n    <c r=\"C6\" s=\"1\"/>\n</row>\n*/","map":{"version":3,"sources":["C:/Users/tzika/Desktop/Polymerlink-Front/polymerlink-2/node_modules/xlsx-populate/lib/Row.js"],"names":["_","require","Cell","regexify","ArgHandler","addressConverter","Row","constructor","sheet","node","_sheet","_init","address","opts","toAddress","type","rowNumber","sheetName","includeSheetName","name","rowAnchored","anchored","cell","columnNameOrNumber","columnNumber","columnNameToNumber","RangeError","_cells","styleId","rowStyleId","_node","attributes","s","columnStyleId","existingColumnStyleId","isNil","height","case","customHeight","ht","undefined","handle","arguments","hidden","r","style","_createStyleIfNeeded","_style","names","values","forEach","value","_createCellStylesIfNeeded","nameValues","hasOwnProperty","id","customFormat","workbook","addPageBreak","horizontalPageBreaks","add","clearCellsUsingSharedFormula","sharedFormulaId","sharesFormula","clear","find","pattern","replacement","matches","push","hasCell","hasStyle","minUsedColumnNumber","findIndex","maxUsedColumnNumber","length","toXml","forEachExistingColumnNumber","styleSheet","createStyle","children","cellNode","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst _ = require(\"lodash\");\nconst Cell = require(\"./Cell\");\nconst regexify = require(\"./regexify\");\nconst ArgHandler = require(\"./ArgHandler\");\nconst addressConverter = require('./addressConverter');\n\n/**\n * A row.\n */\nclass Row {\n    // /**\n    //  * Creates a new instance of Row.\n    //  * @param {Sheet} sheet - The parent sheet.\n    //  * @param {{}} node - The row node.\n    //  */\n    constructor(sheet, node) {\n        this._sheet = sheet;\n        this._init(node);\n    }\n\n    /* PUBLIC */\n\n    /**\n     * Get the address of the row.\n     * @param {{}} [opts] - Options\n     * @param {boolean} [opts.includeSheetName] - Include the sheet name in the address.\n     * @param {boolean} [opts.anchored] - Anchor the address.\n     * @returns {string} The address\n     */\n    address(opts) {\n        return addressConverter.toAddress({\n            type: 'row',\n            rowNumber: this.rowNumber(),\n            sheetName: opts && opts.includeSheetName && this.sheet().name(),\n            rowAnchored: opts && opts.anchored\n        });\n    }\n\n    /**\n     * Get a cell in the row.\n     * @param {string|number} columnNameOrNumber - The name or number of the column.\n     * @returns {Cell} The cell.\n     */\n    cell(columnNameOrNumber) {\n        let columnNumber = columnNameOrNumber;\n        if (typeof columnNameOrNumber === 'string') {\n            columnNumber = addressConverter.columnNameToNumber(columnNameOrNumber);\n        }\n\n        if (columnNumber < 1) throw new RangeError(`Invalid column number ${columnNumber}. Remember that spreadsheets use 1-based indexing.`);\n\n        // Return an existing cell.\n        if (this._cells[columnNumber]) return this._cells[columnNumber];\n\n        // No cell exists for this.\n        // Check if there is an existing row/column style for the new cell.\n        let styleId;\n        const rowStyleId = this._node.attributes.s;\n        const columnStyleId = this.sheet().existingColumnStyleId(columnNumber);\n\n        // Row style takes priority. If a cell has both row and column styles it should have created a cell entry with a cell-specific style.\n        if (!_.isNil(rowStyleId)) styleId = rowStyleId;\n        else if (!_.isNil(columnStyleId)) styleId = columnStyleId;\n\n        // Create the new cell.\n        const cell = new Cell(this, columnNumber, styleId);\n        this._cells[columnNumber] = cell;\n        return cell;\n    }\n\n    /**\n     * Gets the row height.\n     * @returns {undefined|number} The height (or undefined).\n     *//**\n     * Sets the row height.\n     * @param {number} height - The height of the row.\n     * @returns {Row} The row.\n     */\n    height() {\n        return new ArgHandler('Row.height')\n            .case(() => {\n                return this._node.attributes.customHeight ? this._node.attributes.ht : undefined;\n            })\n            .case('number', height => {\n                this._node.attributes.ht = height;\n                this._node.attributes.customHeight = 1;\n                return this;\n            })\n            .case('nil', () => {\n                delete this._node.attributes.ht;\n                delete this._node.attributes.customHeight;\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Gets a value indicating whether the row is hidden.\n     * @returns {boolean} A flag indicating whether the row is hidden.\n     *//**\n     * Sets whether the row is hidden.\n     * @param {boolean} hidden - A flag indicating whether to hide the row.\n     * @returns {Row} The row.\n     */\n    hidden() {\n        return new ArgHandler(\"Row.hidden\")\n            .case(() => {\n                return this._node.attributes.hidden === 1;\n            })\n            .case('boolean', hidden => {\n                if (hidden) this._node.attributes.hidden = 1;\n                else delete this._node.attributes.hidden;\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Gets the row number.\n     * @returns {number} The row number.\n     */\n    rowNumber() {\n        return this._node.attributes.r;\n    }\n\n    /**\n     * Gets the parent sheet of the row.\n     * @returns {Sheet} The parent sheet.\n     */\n    sheet() {\n        return this._sheet;\n    }\n\n    /**\n     * Gets an individual style.\n     * @param {string} name - The name of the style.\n     * @returns {*} The style.\n     *//**\n     * Gets multiple styles.\n     * @param {Array.<string>} names - The names of the style.\n     * @returns {object.<string, *>} Object whose keys are the style names and values are the styles.\n     *//**\n     * Sets an individual style.\n     * @param {string} name - The name of the style.\n     * @param {*} value - The value to set.\n     * @returns {Cell} The cell.\n     *//**\n\t * Sets multiple styles.\n\t * @param {object.<string, *>} styles - Object whose keys are the style names and values are the styles to set.\n\t * @returns {Cell} The cell.\n     *//**\n     * Sets to a specific style\n     * @param {Style} style - Style object given from stylesheet.createStyle\n     * @returns {Cell} The cell.\n     */\n    style() {\n        return new ArgHandler(\"Row.style\")\n            .case('string', name => {\n                // Get single value\n                this._createStyleIfNeeded();\n                return this._style.style(name);\n            })\n            .case('array', names => {\n                // Get list of values\n                const values = {};\n                names.forEach(name => {\n                    values[name] = this.style(name);\n                });\n\n                return values;\n            })\n            .case(['string', '*'], (name, value) => {\n                this._createCellStylesIfNeeded();\n\n                // Style each existing cell within this row. (Cells don't inherit ow/column styles.)\n                _.forEach(this._cells, cell => {\n                    if (cell) cell.style(name, value);\n                });\n\n                // Set the style on the row.\n                this._createStyleIfNeeded();\n                this._style.style(name, value);\n\n                return this;\n            })\n            .case('object', nameValues => {\n                // Object of key value pairs to set\n                for (const name in nameValues) {\n                    if (!nameValues.hasOwnProperty(name)) continue;\n                    const value = nameValues[name];\n                    this.style(name, value);\n                }\n\n                return this;\n            })\n            .case('Style', style => {\n                this._createCellStylesIfNeeded();\n\n                // Style each existing cell within this row. (Cells don't inherit ow/column styles.)\n                _.forEach(this._cells, cell => {\n                    if (cell) cell.style(style);\n                });\n\n                this._style = style;\n                this._node.attributes.s = style.id();\n                this._node.attributes.customFormat = 1;\n\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Get the parent workbook.\n     * @returns {Workbook} The parent workbook.\n     */\n    workbook() {\n        return this.sheet().workbook();\n    }\n\n    /**\n     * Append horizontal page break after the row.\n     * @returns {Row} the row.\n     */\n    addPageBreak() {\n        this.sheet().horizontalPageBreaks().add(this.rowNumber());\n        return this;\n    }\n\n    /* INTERNAL */\n\n    /**\n     * Clear cells that are using a given shared formula ID.\n     * @param {number} sharedFormulaId - The shared formula ID.\n     * @returns {undefined}\n     * @ignore\n     */\n    clearCellsUsingSharedFormula(sharedFormulaId) {\n        this._cells.forEach(cell => {\n            if (!cell) return;\n            if (cell.sharesFormula(sharedFormulaId)) cell.clear();\n        });\n    }\n\n    /**\n     * Find a pattern in the row and optionally replace it.\n     * @param {string|RegExp} pattern - The search pattern.\n     * @param {string} [replacement] - The replacement text.\n     * @returns {Array.<Cell>} The matched cells.\n     * @ignore\n     */\n    find(pattern, replacement) {\n        pattern = regexify(pattern);\n\n        const matches = [];\n        this._cells.forEach(cell => {\n            if (!cell) return;\n            if (cell.find(pattern, replacement)) matches.push(cell);\n        });\n\n        return matches;\n    }\n\n    /**\n     * Check if the row has a cell at the given column number.\n     * @param {number} columnNumber - The column number.\n     * @returns {boolean} True if a cell exists, false otherwise.\n     * @ignore\n     */\n    hasCell(columnNumber) {\n        if (columnNumber < 1) throw new RangeError(`Invalid column number ${columnNumber}. Remember that spreadsheets use 1-based indexing.`);\n        return !!this._cells[columnNumber];\n    }\n\n    /**\n     * Check if the column has a style defined.\n     * @returns {boolean} True if a style exists, false otherwise.\n     * @ignore\n     */\n    hasStyle() {\n        return !_.isNil(this._node.attributes.s);\n    }\n\n    /**\n     * Returns the nax used column number.\n     * @returns {number} The max used column number.\n     * @ignore\n     */\n    minUsedColumnNumber() {\n        return _.findIndex(this._cells);\n    }\n\n    /**\n     * Returns the nax used column number.\n     * @returns {number} The max used column number.\n     * @ignore\n     */\n    maxUsedColumnNumber() {\n        return this._cells.length - 1;\n    }\n\n    /**\n     * Convert the row to an object.\n     * @returns {{}} The object form.\n     * @ignore\n     */\n    toXml() {\n        return this._node;\n    }\n\n    /* PRIVATE */\n\n    /**\n     * If a column node is already defined that intersects with this row and that column has a style set, we\n     * need to make sure that a cell node exists at the intersection so we can style it appropriately.\n     * Fetching the cell will force a new cell node to be created with a style matching the column.\n     * @returns {undefined}\n     * @private\n     */\n    _createCellStylesIfNeeded() {\n        this.sheet().forEachExistingColumnNumber(columnNumber => {\n            if (!_.isNil(this.sheet().existingColumnStyleId(columnNumber))) this.cell(columnNumber);\n        });\n    }\n\n    /**\n     * Create a style for this row if it doesn't already exist.\n     * @returns {undefined}\n     * @private\n     */\n    _createStyleIfNeeded() {\n        if (!this._style) {\n            const styleId = this._node.attributes.s;\n            this._style = this.workbook().styleSheet().createStyle(styleId);\n            this._node.attributes.s = this._style.id();\n            this._node.attributes.customFormat = 1;\n        }\n    }\n\n    /**\n     * Initialize the row node.\n     * @param {{}} node - The row node.\n     * @returns {undefined}\n     * @private\n     */\n    _init(node) {\n        this._node = node;\n        this._cells = [];\n        this._node.children.forEach(cellNode => {\n            const cell = new Cell(this, cellNode);\n            this._cells[cell.columnNumber()] = cell;\n        });\n        this._node.children = this._cells;\n    }\n}\n\nmodule.exports = Row;\n\n/*\n<row r=\"6\" spans=\"1:9\" x14ac:dyDescent=\"0.25\">\n    <c r=\"A6\" s=\"1\" t=\"s\">\n        <v>2</v>\n    </c>\n    <c r=\"B6\" s=\"1\"/>\n    <c r=\"C6\" s=\"1\"/>\n</row>\n*/\n"]},"metadata":{},"sourceType":"script"}