{"ast":null,"code":"\"use strict\";\n/* eslint camelcase:off */\n\nconst ArgHandler = require(\"./ArgHandler\");\n\nconst _ = require(\"lodash\");\n\nconst xmlq = require(\"./xmlq\");\n\nconst colorIndexes = require(\"./colorIndexes\");\n/**\n * A style.\n * @ignore\n */\n\n\nclass Style {\n  /**\n   * Creates a new instance of _Style.\n   * @constructor\n   * @param {StyleSheet} styleSheet - The styleSheet.\n   * @param {number} id - The style ID.\n   * @param {{}} xfNode - The xf node.\n   * @param {{}} fontNode - The font node.\n   * @param {{}} fillNode - The fill node.\n   * @param {{}} borderNode - The border node.\n   */\n  constructor(styleSheet, id, xfNode, fontNode, fillNode, borderNode) {\n    this._styleSheet = styleSheet;\n    this._id = id;\n    this._xfNode = xfNode;\n    this._fontNode = fontNode;\n    this._fillNode = fillNode;\n    this._borderNode = borderNode;\n  }\n  /**\n   * Gets the style ID.\n   * @returns {number} The ID.\n   */\n\n\n  id() {\n    return this._id;\n  }\n  /**\n   * Gets or sets a style.\n   * @param {string} name - The style name.\n   * @param {*} [value] - The value to set.\n   * @returns {*|Style} The value if getting or the style if setting.\n   */\n\n\n  style() {\n    return new ArgHandler(\"_Style.style\").case('string', name => {\n      const getterName = `_get_${name}`;\n      if (!this[getterName]) throw new Error(`_Style.style: '${name}' is not a valid style`);\n      return this[getterName]();\n    }).case(['string', '*'], (name, value) => {\n      const setterName = `_set_${name}`;\n      if (!this[setterName]) throw new Error(`_Style.style: '${name}' is not a valid style`);\n      this[setterName](value);\n      return this;\n    }).handle(arguments);\n  }\n\n  _getColor(node, name) {\n    const child = xmlq.findChild(node, name);\n    if (!child || !child.attributes) return;\n    const color = {};\n    if (child.attributes.hasOwnProperty('rgb')) color.rgb = child.attributes.rgb;else if (child.attributes.hasOwnProperty('theme')) color.theme = child.attributes.theme;else if (child.attributes.hasOwnProperty('indexed')) color.rgb = colorIndexes[child.attributes.indexed];\n    if (child.attributes.hasOwnProperty('tint')) color.tint = child.attributes.tint;\n    if (_.isEmpty(color)) return;\n    return color;\n  }\n\n  _setColor(node, name, color) {\n    if (typeof color === \"string\") color = {\n      rgb: color\n    };else if (typeof color === \"number\") color = {\n      theme: color\n    };\n    xmlq.setChildAttributes(node, name, {\n      rgb: color && color.rgb && color.rgb.toUpperCase(),\n      indexed: null,\n      theme: color && color.theme,\n      tint: color && color.tint\n    });\n    xmlq.removeChildIfEmpty(node, 'color');\n  }\n\n  _get_bold() {\n    return xmlq.hasChild(this._fontNode, 'b');\n  }\n\n  _set_bold(bold) {\n    if (bold) xmlq.appendChildIfNotFound(this._fontNode, \"b\");else xmlq.removeChild(this._fontNode, 'b');\n  }\n\n  _get_italic() {\n    return xmlq.hasChild(this._fontNode, 'i');\n  }\n\n  _set_italic(italic) {\n    if (italic) xmlq.appendChildIfNotFound(this._fontNode, \"i\");else xmlq.removeChild(this._fontNode, 'i');\n  }\n\n  _get_underline() {\n    const uNode = xmlq.findChild(this._fontNode, 'u');\n    return uNode ? uNode.attributes.val || true : false;\n  }\n\n  _set_underline(underline) {\n    if (underline) {\n      const uNode = xmlq.appendChildIfNotFound(this._fontNode, \"u\");\n      const val = typeof underline === 'string' ? underline : null;\n      xmlq.setAttributes(uNode, {\n        val\n      });\n    } else {\n      xmlq.removeChild(this._fontNode, 'u');\n    }\n  }\n\n  _get_strikethrough() {\n    return xmlq.hasChild(this._fontNode, 'strike');\n  }\n\n  _set_strikethrough(strikethrough) {\n    if (strikethrough) xmlq.appendChildIfNotFound(this._fontNode, \"strike\");else xmlq.removeChild(this._fontNode, 'strike');\n  }\n\n  _getFontVerticalAlignment() {\n    return xmlq.getChildAttribute(this._fontNode, 'vertAlign', \"val\");\n  }\n\n  _setFontVerticalAlignment(alignment) {\n    xmlq.setChildAttributes(this._fontNode, 'vertAlign', {\n      val: alignment\n    });\n    xmlq.removeChildIfEmpty(this._fontNode, 'vertAlign');\n  }\n\n  _get_subscript() {\n    return this._getFontVerticalAlignment() === \"subscript\";\n  }\n\n  _set_subscript(subscript) {\n    this._setFontVerticalAlignment(subscript ? \"subscript\" : null);\n  }\n\n  _get_superscript() {\n    return this._getFontVerticalAlignment() === \"superscript\";\n  }\n\n  _set_superscript(superscript) {\n    this._setFontVerticalAlignment(superscript ? \"superscript\" : null);\n  }\n\n  _get_fontSize() {\n    return xmlq.getChildAttribute(this._fontNode, 'sz', \"val\");\n  }\n\n  _set_fontSize(size) {\n    xmlq.setChildAttributes(this._fontNode, 'sz', {\n      val: size\n    });\n    xmlq.removeChildIfEmpty(this._fontNode, 'sz');\n  }\n\n  _get_fontFamily() {\n    return xmlq.getChildAttribute(this._fontNode, 'name', \"val\");\n  }\n\n  _set_fontFamily(family) {\n    xmlq.setChildAttributes(this._fontNode, 'name', {\n      val: family\n    });\n    xmlq.removeChildIfEmpty(this._fontNode, 'name');\n  }\n\n  _get_fontGenericFamily() {\n    return xmlq.getChildAttribute(this._fontNode, 'family', \"val\");\n  }\n\n  _set_fontGenericFamily(genericFamily) {\n    xmlq.setChildAttributes(this._fontNode, 'family', {\n      val: genericFamily\n    });\n    xmlq.removeChildIfEmpty(this._fontNode, 'family');\n  }\n\n  _get_fontColor() {\n    return this._getColor(this._fontNode, \"color\");\n  }\n\n  _set_fontColor(color) {\n    this._setColor(this._fontNode, \"color\", color);\n  }\n\n  _get_fontScheme() {\n    // can be 'minor', 'major', 'none'\n    return xmlq.getChildAttribute(this._fontNode, 'scheme', \"val\");\n  }\n\n  _set_fontScheme(scheme) {\n    xmlq.setChildAttributes(this._fontNode, 'scheme', {\n      val: scheme\n    });\n    xmlq.removeChildIfEmpty(this._fontNode, 'scheme');\n  }\n\n  _get_horizontalAlignment() {\n    return xmlq.getChildAttribute(this._xfNode, 'alignment', \"horizontal\");\n  }\n\n  _set_horizontalAlignment(alignment) {\n    xmlq.setChildAttributes(this._xfNode, 'alignment', {\n      horizontal: alignment\n    });\n    xmlq.removeChildIfEmpty(this._xfNode, 'alignment');\n  }\n\n  _get_justifyLastLine() {\n    return xmlq.getChildAttribute(this._xfNode, 'alignment', \"justifyLastLine\") === 1;\n  }\n\n  _set_justifyLastLine(justifyLastLine) {\n    xmlq.setChildAttributes(this._xfNode, 'alignment', {\n      justifyLastLine: justifyLastLine ? 1 : null\n    });\n    xmlq.removeChildIfEmpty(this._xfNode, 'alignment');\n  }\n\n  _get_indent() {\n    return xmlq.getChildAttribute(this._xfNode, 'alignment', \"indent\");\n  }\n\n  _set_indent(indent) {\n    xmlq.setChildAttributes(this._xfNode, 'alignment', {\n      indent\n    });\n    xmlq.removeChildIfEmpty(this._xfNode, 'alignment');\n  }\n\n  _get_verticalAlignment() {\n    return xmlq.getChildAttribute(this._xfNode, 'alignment', \"vertical\");\n  }\n\n  _set_verticalAlignment(alignment) {\n    xmlq.setChildAttributes(this._xfNode, 'alignment', {\n      vertical: alignment\n    });\n    xmlq.removeChildIfEmpty(this._xfNode, 'alignment');\n  }\n\n  _get_wrapText() {\n    return xmlq.getChildAttribute(this._xfNode, 'alignment', \"wrapText\") === 1;\n  }\n\n  _set_wrapText(wrapText) {\n    xmlq.setChildAttributes(this._xfNode, 'alignment', {\n      wrapText: wrapText ? 1 : null\n    });\n    xmlq.removeChildIfEmpty(this._xfNode, 'alignment');\n  }\n\n  _get_shrinkToFit() {\n    return xmlq.getChildAttribute(this._xfNode, 'alignment', \"shrinkToFit\") === 1;\n  }\n\n  _set_shrinkToFit(shrinkToFit) {\n    xmlq.setChildAttributes(this._xfNode, 'alignment', {\n      shrinkToFit: shrinkToFit ? 1 : null\n    });\n    xmlq.removeChildIfEmpty(this._xfNode, 'alignment');\n  }\n\n  _get_textDirection() {\n    const readingOrder = xmlq.getChildAttribute(this._xfNode, 'alignment', \"readingOrder\");\n    if (readingOrder === 1) return \"left-to-right\";\n    if (readingOrder === 2) return \"right-to-left\";\n    return readingOrder;\n  }\n\n  _set_textDirection(textDirection) {\n    let readingOrder;\n    if (textDirection === \"left-to-right\") readingOrder = 1;else if (textDirection === \"right-to-left\") readingOrder = 2;\n    xmlq.setChildAttributes(this._xfNode, 'alignment', {\n      readingOrder\n    });\n    xmlq.removeChildIfEmpty(this._xfNode, 'alignment');\n  }\n\n  _getTextRotation() {\n    return xmlq.getChildAttribute(this._xfNode, 'alignment', \"textRotation\");\n  }\n\n  _setTextRotation(textRotation) {\n    xmlq.setChildAttributes(this._xfNode, 'alignment', {\n      textRotation\n    });\n    xmlq.removeChildIfEmpty(this._xfNode, 'alignment');\n  }\n\n  _get_textRotation() {\n    let textRotation = this._getTextRotation(); // Negative angles in Excel correspond to values > 90 in OOXML.\n\n\n    if (textRotation > 90) textRotation = 90 - textRotation;\n    return textRotation;\n  }\n\n  _set_textRotation(textRotation) {\n    // Negative angles in Excel correspond to values > 90 in OOXML.\n    if (textRotation < 0) textRotation = 90 - textRotation;\n\n    this._setTextRotation(textRotation);\n  }\n\n  _get_angleTextCounterclockwise() {\n    return this._getTextRotation() === 45;\n  }\n\n  _set_angleTextCounterclockwise(value) {\n    this._setTextRotation(value ? 45 : null);\n  }\n\n  _get_angleTextClockwise() {\n    return this._getTextRotation() === 135;\n  }\n\n  _set_angleTextClockwise(value) {\n    this._setTextRotation(value ? 135 : null);\n  }\n\n  _get_rotateTextUp() {\n    return this._getTextRotation() === 90;\n  }\n\n  _set_rotateTextUp(value) {\n    this._setTextRotation(value ? 90 : null);\n  }\n\n  _get_rotateTextDown() {\n    return this._getTextRotation() === 180;\n  }\n\n  _set_rotateTextDown(value) {\n    this._setTextRotation(value ? 180 : null);\n  }\n\n  _get_verticalText() {\n    return this._getTextRotation() === 255;\n  }\n\n  _set_verticalText(value) {\n    this._setTextRotation(value ? 255 : null);\n  }\n\n  _get_fill() {\n    const patternFillNode = xmlq.findChild(this._fillNode, 'patternFill'); // jq.get(this._fillNode, \"patternFill[0]\");\n\n    const gradientFillNode = xmlq.findChild(this._fillNode, 'gradientFill'); // jq.get(this._fillNode, \"gradientFill[0]\");\n\n    const patternType = patternFillNode && patternFillNode.attributes.patternType; // jq.get(patternFillNode, \"$.patternType\");\n\n    if (patternType === \"solid\") {\n      return {\n        type: \"solid\",\n        color: this._getColor(patternFillNode, \"fgColor\")\n      };\n    }\n\n    if (patternType) {\n      return {\n        type: \"pattern\",\n        pattern: patternType,\n        foreground: this._getColor(patternFillNode, \"fgColor\"),\n        background: this._getColor(patternFillNode, \"bgColor\")\n      };\n    }\n\n    if (gradientFillNode) {\n      const gradientType = gradientFillNode.attributes.type || \"linear\";\n      const fill = {\n        type: \"gradient\",\n        gradientType,\n        stops: _.map(gradientFillNode.children, stop => ({\n          position: stop.attributes.position,\n          color: this._getColor(stop, \"color\")\n        }))\n      };\n\n      if (gradientType === \"linear\") {\n        fill.angle = gradientFillNode.attributes.degree;\n      } else {\n        fill.left = gradientFillNode.attributes.left;\n        fill.right = gradientFillNode.attributes.right;\n        fill.top = gradientFillNode.attributes.top;\n        fill.bottom = gradientFillNode.attributes.bottom;\n      }\n\n      return fill;\n    }\n  }\n\n  _set_fill(fill) {\n    this._fillNode.children = []; // No fill\n\n    if (_.isNil(fill)) return; // Pattern fill\n\n    if (fill.type === \"pattern\") {\n      const patternFill = {\n        name: 'patternFill',\n        attributes: {\n          patternType: fill.pattern\n        },\n        children: []\n      };\n\n      this._fillNode.children.push(patternFill);\n\n      this._setColor(patternFill, \"fgColor\", fill.foreground);\n\n      this._setColor(patternFill, \"bgColor\", fill.background);\n\n      return;\n    } // Gradient fill\n\n\n    if (fill.type === \"gradient\") {\n      const gradientFill = {\n        name: 'gradientFill',\n        attributes: {},\n        children: []\n      };\n\n      this._fillNode.children.push(gradientFill);\n\n      xmlq.setAttributes(gradientFill, {\n        type: fill.gradientType === \"path\" ? \"path\" : undefined,\n        left: fill.left,\n        right: fill.right,\n        top: fill.top,\n        bottom: fill.bottom,\n        degree: fill.angle\n      });\n\n      _.forEach(fill.stops, (fillStop, i) => {\n        const stop = {\n          name: 'stop',\n          attributes: {\n            position: fillStop.position\n          },\n          children: []\n        };\n        gradientFill.children.push(stop);\n\n        this._setColor(stop, 'color', fillStop.color);\n      });\n\n      return;\n    } // Solid fill (really a pattern fill with a solid pattern type).\n\n\n    if (!_.isObject(fill)) fill = {\n      type: \"solid\",\n      color: fill\n    };else if (fill.hasOwnProperty('rgb') || fill.hasOwnProperty(\"theme\")) fill = {\n      color: fill\n    };\n    const patternFill = {\n      name: 'patternFill',\n      attributes: {\n        patternType: 'solid'\n      }\n    };\n\n    this._fillNode.children.push(patternFill);\n\n    this._setColor(patternFill, \"fgColor\", fill.color);\n  }\n\n  _getBorder() {\n    const result = {};\n    [\"left\", \"right\", \"top\", \"bottom\", \"diagonal\"].forEach(side => {\n      const sideNode = xmlq.findChild(this._borderNode, side);\n      const sideResult = {};\n      const style = xmlq.getChildAttribute(this._borderNode, side, 'style');\n      if (style) sideResult.style = style;\n\n      const color = this._getColor(sideNode, 'color');\n\n      if (color) sideResult.color = color;\n\n      if (side === \"diagonal\") {\n        const up = this._borderNode.attributes.diagonalUp;\n        const down = this._borderNode.attributes.diagonalDown;\n        let direction;\n        if (up && down) direction = \"both\";else if (up) direction = \"up\";else if (down) direction = \"down\";\n        if (direction) sideResult.direction = direction;\n      }\n\n      if (!_.isEmpty(sideResult)) result[side] = sideResult;\n    });\n    return result;\n  }\n\n  _setBorder(settings) {\n    _.forOwn(settings, (setting, side) => {\n      if (typeof setting === \"boolean\") {\n        setting = {\n          style: setting ? \"thin\" : null\n        };\n      } else if (typeof setting === \"string\") {\n        setting = {\n          style: setting\n        };\n      } else if (setting === null || setting === undefined) {\n        setting = {\n          style: null,\n          color: null,\n          direction: null\n        };\n      }\n\n      if (setting.hasOwnProperty(\"style\")) {\n        xmlq.setChildAttributes(this._borderNode, side, {\n          style: setting.style\n        });\n      }\n\n      if (setting.hasOwnProperty(\"color\")) {\n        const sideNode = xmlq.findChild(this._borderNode, side);\n\n        this._setColor(sideNode, \"color\", setting.color);\n      }\n\n      if (side === \"diagonal\") {\n        xmlq.setAttributes(this._borderNode, {\n          diagonalUp: setting.direction === \"up\" || setting.direction === \"both\" ? 1 : null,\n          diagonalDown: setting.direction === \"down\" || setting.direction === \"both\" ? 1 : null\n        });\n      }\n    });\n  }\n\n  _get_border() {\n    return this._getBorder();\n  }\n\n  _set_border(settings) {\n    if (_.isObject(settings) && !settings.hasOwnProperty(\"style\") && !settings.hasOwnProperty(\"color\")) {\n      settings = _.defaults(settings, {\n        left: null,\n        right: null,\n        top: null,\n        bottom: null,\n        diagonal: null\n      });\n\n      this._setBorder(settings);\n    } else {\n      this._setBorder({\n        left: settings,\n        right: settings,\n        top: settings,\n        bottom: settings\n      });\n    }\n  }\n\n  _get_borderColor() {\n    return _.mapValues(this._getBorder(), value => value.color);\n  }\n\n  _set_borderColor(color) {\n    if (_.isObject(color)) {\n      this._setBorder(_.mapValues(color, color => ({\n        color\n      })));\n    } else {\n      this._setBorder({\n        left: {\n          color\n        },\n        right: {\n          color\n        },\n        top: {\n          color\n        },\n        bottom: {\n          color\n        },\n        diagonal: {\n          color\n        }\n      });\n    }\n  }\n\n  _get_borderStyle() {\n    return _.mapValues(this._getBorder(), value => value.style);\n  }\n\n  _set_borderStyle(style) {\n    if (_.isObject(style)) {\n      this._setBorder(_.mapValues(style, style => ({\n        style\n      })));\n    } else {\n      this._setBorder({\n        left: {\n          style\n        },\n        right: {\n          style\n        },\n        top: {\n          style\n        },\n        bottom: {\n          style\n        }\n      });\n    }\n  }\n\n  _get_diagonalBorderDirection() {\n    const border = this._getBorder().diagonal;\n\n    return border && border.direction;\n  }\n\n  _set_diagonalBorderDirection(direction) {\n    this._setBorder({\n      diagonal: {\n        direction\n      }\n    });\n  }\n\n  _get_numberFormat() {\n    const numFmtId = this._xfNode.attributes.numFmtId || 0;\n    return this._styleSheet.getNumberFormatCode(numFmtId);\n  }\n\n  _set_numberFormat(formatCode) {\n    this._xfNode.attributes.numFmtId = this._styleSheet.getNumberFormatId(formatCode);\n  }\n\n}\n\n[\"left\", \"right\", \"top\", \"bottom\", \"diagonal\"].forEach(side => {\n  Style.prototype[`_get_${side}Border`] = function () {\n    return this._getBorder()[side];\n  };\n\n  Style.prototype[`_set_${side}Border`] = function (settings) {\n    this._setBorder({\n      [side]: settings\n    });\n  };\n\n  Style.prototype[`_get_${side}BorderColor`] = function () {\n    const border = this._getBorder()[side];\n\n    return border && border.color;\n  };\n\n  Style.prototype[`_set_${side}BorderColor`] = function (color) {\n    this._setBorder({\n      [side]: {\n        color\n      }\n    });\n  };\n\n  Style.prototype[`_get_${side}BorderStyle`] = function () {\n    const border = this._getBorder()[side];\n\n    return border && border.style;\n  };\n\n  Style.prototype[`_set_${side}BorderStyle`] = function (style) {\n    this._setBorder({\n      [side]: {\n        style\n      }\n    });\n  };\n}); // IE doesn't support function names so explicitly set it.\n\nif (!Style.name) Style.name = \"Style\";\nmodule.exports = Style;","map":{"version":3,"sources":["C:/Users/tatac/Desktop/MSM-Front/MSM/node_modules/xlsx-populate/lib/Style.js"],"names":["ArgHandler","require","_","xmlq","colorIndexes","Style","constructor","styleSheet","id","xfNode","fontNode","fillNode","borderNode","_styleSheet","_id","_xfNode","_fontNode","_fillNode","_borderNode","style","case","name","getterName","Error","value","setterName","handle","arguments","_getColor","node","child","findChild","attributes","color","hasOwnProperty","rgb","theme","indexed","tint","isEmpty","_setColor","setChildAttributes","toUpperCase","removeChildIfEmpty","_get_bold","hasChild","_set_bold","bold","appendChildIfNotFound","removeChild","_get_italic","_set_italic","italic","_get_underline","uNode","val","_set_underline","underline","setAttributes","_get_strikethrough","_set_strikethrough","strikethrough","_getFontVerticalAlignment","getChildAttribute","_setFontVerticalAlignment","alignment","_get_subscript","_set_subscript","subscript","_get_superscript","_set_superscript","superscript","_get_fontSize","_set_fontSize","size","_get_fontFamily","_set_fontFamily","family","_get_fontGenericFamily","_set_fontGenericFamily","genericFamily","_get_fontColor","_set_fontColor","_get_fontScheme","_set_fontScheme","scheme","_get_horizontalAlignment","_set_horizontalAlignment","horizontal","_get_justifyLastLine","_set_justifyLastLine","justifyLastLine","_get_indent","_set_indent","indent","_get_verticalAlignment","_set_verticalAlignment","vertical","_get_wrapText","_set_wrapText","wrapText","_get_shrinkToFit","_set_shrinkToFit","shrinkToFit","_get_textDirection","readingOrder","_set_textDirection","textDirection","_getTextRotation","_setTextRotation","textRotation","_get_textRotation","_set_textRotation","_get_angleTextCounterclockwise","_set_angleTextCounterclockwise","_get_angleTextClockwise","_set_angleTextClockwise","_get_rotateTextUp","_set_rotateTextUp","_get_rotateTextDown","_set_rotateTextDown","_get_verticalText","_set_verticalText","_get_fill","patternFillNode","gradientFillNode","patternType","type","pattern","foreground","background","gradientType","fill","stops","map","children","stop","position","angle","degree","left","right","top","bottom","_set_fill","isNil","patternFill","push","gradientFill","undefined","forEach","fillStop","i","isObject","_getBorder","result","side","sideNode","sideResult","up","diagonalUp","down","diagonalDown","direction","_setBorder","settings","forOwn","setting","_get_border","_set_border","defaults","diagonal","_get_borderColor","mapValues","_set_borderColor","_get_borderStyle","_set_borderStyle","_get_diagonalBorderDirection","border","_set_diagonalBorderDirection","_get_numberFormat","numFmtId","getNumberFormatCode","_set_numberFormat","formatCode","getNumberFormatId","prototype","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\n/* eslint camelcase:off */\n\nconst ArgHandler = require(\"./ArgHandler\");\nconst _ = require(\"lodash\");\nconst xmlq = require(\"./xmlq\");\nconst colorIndexes = require(\"./colorIndexes\");\n\n/**\n * A style.\n * @ignore\n */\nclass Style {\n    /**\n     * Creates a new instance of _Style.\n     * @constructor\n     * @param {StyleSheet} styleSheet - The styleSheet.\n     * @param {number} id - The style ID.\n     * @param {{}} xfNode - The xf node.\n     * @param {{}} fontNode - The font node.\n     * @param {{}} fillNode - The fill node.\n     * @param {{}} borderNode - The border node.\n     */\n    constructor(styleSheet, id, xfNode, fontNode, fillNode, borderNode) {\n        this._styleSheet = styleSheet;\n        this._id = id;\n        this._xfNode = xfNode;\n        this._fontNode = fontNode;\n        this._fillNode = fillNode;\n        this._borderNode = borderNode;\n    }\n\n    /**\n     * Gets the style ID.\n     * @returns {number} The ID.\n     */\n    id() {\n        return this._id;\n    }\n\n    /**\n     * Gets or sets a style.\n     * @param {string} name - The style name.\n     * @param {*} [value] - The value to set.\n     * @returns {*|Style} The value if getting or the style if setting.\n     */\n    style() {\n        return new ArgHandler(\"_Style.style\")\n            .case('string', name => {\n                const getterName = `_get_${name}`;\n                if (!this[getterName]) throw new Error(`_Style.style: '${name}' is not a valid style`);\n                return this[getterName]();\n            })\n            .case(['string', '*'], (name, value) => {\n                const setterName = `_set_${name}`;\n                if (!this[setterName]) throw new Error(`_Style.style: '${name}' is not a valid style`);\n                this[setterName](value);\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    _getColor(node, name) {\n        const child = xmlq.findChild(node, name);\n        if (!child || !child.attributes) return;\n\n        const color = {};\n        if (child.attributes.hasOwnProperty('rgb')) color.rgb = child.attributes.rgb;\n        else if (child.attributes.hasOwnProperty('theme')) color.theme = child.attributes.theme;\n        else if (child.attributes.hasOwnProperty('indexed')) color.rgb = colorIndexes[child.attributes.indexed];\n\n        if (child.attributes.hasOwnProperty('tint')) color.tint = child.attributes.tint;\n\n        if (_.isEmpty(color)) return;\n\n        return color;\n    }\n\n    _setColor(node, name, color) {\n        if (typeof color === \"string\") color = { rgb: color };\n        else if (typeof color === \"number\") color = { theme: color };\n\n        xmlq.setChildAttributes(node, name, {\n            rgb: color && color.rgb && color.rgb.toUpperCase(),\n            indexed: null,\n            theme: color && color.theme,\n            tint: color && color.tint\n        });\n\n        xmlq.removeChildIfEmpty(node, 'color');\n    }\n\n    _get_bold() {\n        return xmlq.hasChild(this._fontNode, 'b');\n    }\n\n    _set_bold(bold) {\n        if (bold) xmlq.appendChildIfNotFound(this._fontNode, \"b\");\n        else xmlq.removeChild(this._fontNode, 'b');\n    }\n\n    _get_italic() {\n        return xmlq.hasChild(this._fontNode, 'i');\n    }\n\n    _set_italic(italic) {\n        if (italic) xmlq.appendChildIfNotFound(this._fontNode, \"i\");\n        else xmlq.removeChild(this._fontNode, 'i');\n    }\n\n    _get_underline() {\n        const uNode = xmlq.findChild(this._fontNode, 'u');\n        return uNode ? uNode.attributes.val || true : false;\n    }\n\n    _set_underline(underline) {\n        if (underline) {\n            const uNode = xmlq.appendChildIfNotFound(this._fontNode, \"u\");\n            const val = typeof underline === 'string' ? underline : null;\n            xmlq.setAttributes(uNode, { val });\n        } else {\n            xmlq.removeChild(this._fontNode, 'u');\n        }\n    }\n\n    _get_strikethrough() {\n        return xmlq.hasChild(this._fontNode, 'strike');\n    }\n\n    _set_strikethrough(strikethrough) {\n        if (strikethrough) xmlq.appendChildIfNotFound(this._fontNode, \"strike\");\n        else xmlq.removeChild(this._fontNode, 'strike');\n    }\n\n    _getFontVerticalAlignment() {\n        return xmlq.getChildAttribute(this._fontNode, 'vertAlign', \"val\");\n    }\n\n    _setFontVerticalAlignment(alignment) {\n        xmlq.setChildAttributes(this._fontNode, 'vertAlign', { val: alignment });\n        xmlq.removeChildIfEmpty(this._fontNode, 'vertAlign');\n    }\n\n    _get_subscript() {\n        return this._getFontVerticalAlignment() === \"subscript\";\n    }\n\n    _set_subscript(subscript) {\n        this._setFontVerticalAlignment(subscript ? \"subscript\" : null);\n    }\n\n    _get_superscript() {\n        return this._getFontVerticalAlignment() === \"superscript\";\n    }\n\n    _set_superscript(superscript) {\n        this._setFontVerticalAlignment(superscript ? \"superscript\" : null);\n    }\n\n    _get_fontSize() {\n        return xmlq.getChildAttribute(this._fontNode, 'sz', \"val\");\n    }\n\n    _set_fontSize(size) {\n        xmlq.setChildAttributes(this._fontNode, 'sz', { val: size });\n        xmlq.removeChildIfEmpty(this._fontNode, 'sz');\n    }\n\n    _get_fontFamily() {\n        return xmlq.getChildAttribute(this._fontNode, 'name', \"val\");\n    }\n\n    _set_fontFamily(family) {\n        xmlq.setChildAttributes(this._fontNode, 'name', { val: family });\n        xmlq.removeChildIfEmpty(this._fontNode, 'name');\n    }\n\n    _get_fontGenericFamily() {\n        return xmlq.getChildAttribute(this._fontNode, 'family', \"val\");\n    }\n\n    _set_fontGenericFamily(genericFamily) {\n        xmlq.setChildAttributes(this._fontNode, 'family', { val: genericFamily });\n        xmlq.removeChildIfEmpty(this._fontNode, 'family');\n    }\n\n    _get_fontColor() {\n        return this._getColor(this._fontNode, \"color\");\n    }\n\n    _set_fontColor(color) {\n        this._setColor(this._fontNode, \"color\", color);\n    }\n\n    _get_fontScheme() {\n        // can be 'minor', 'major', 'none'\n        return xmlq.getChildAttribute(this._fontNode, 'scheme', \"val\");\n    }\n\n    _set_fontScheme(scheme) {\n        xmlq.setChildAttributes(this._fontNode, 'scheme', { val: scheme });\n        xmlq.removeChildIfEmpty(this._fontNode, 'scheme');\n    }\n\n    _get_horizontalAlignment() {\n        return xmlq.getChildAttribute(this._xfNode, 'alignment', \"horizontal\");\n    }\n\n    _set_horizontalAlignment(alignment) {\n        xmlq.setChildAttributes(this._xfNode, 'alignment', { horizontal: alignment });\n        xmlq.removeChildIfEmpty(this._xfNode, 'alignment');\n    }\n\n    _get_justifyLastLine() {\n        return xmlq.getChildAttribute(this._xfNode, 'alignment', \"justifyLastLine\") === 1;\n    }\n\n    _set_justifyLastLine(justifyLastLine) {\n        xmlq.setChildAttributes(this._xfNode, 'alignment', { justifyLastLine: justifyLastLine ? 1 : null });\n        xmlq.removeChildIfEmpty(this._xfNode, 'alignment');\n    }\n\n    _get_indent() {\n        return xmlq.getChildAttribute(this._xfNode, 'alignment', \"indent\");\n    }\n\n    _set_indent(indent) {\n        xmlq.setChildAttributes(this._xfNode, 'alignment', { indent });\n        xmlq.removeChildIfEmpty(this._xfNode, 'alignment');\n    }\n\n    _get_verticalAlignment() {\n        return xmlq.getChildAttribute(this._xfNode, 'alignment', \"vertical\");\n    }\n\n    _set_verticalAlignment(alignment) {\n        xmlq.setChildAttributes(this._xfNode, 'alignment', { vertical: alignment });\n        xmlq.removeChildIfEmpty(this._xfNode, 'alignment');\n    }\n\n    _get_wrapText() {\n        return xmlq.getChildAttribute(this._xfNode, 'alignment', \"wrapText\") === 1;\n    }\n\n    _set_wrapText(wrapText) {\n        xmlq.setChildAttributes(this._xfNode, 'alignment', { wrapText: wrapText ? 1 : null });\n        xmlq.removeChildIfEmpty(this._xfNode, 'alignment');\n    }\n\n    _get_shrinkToFit() {\n        return xmlq.getChildAttribute(this._xfNode, 'alignment', \"shrinkToFit\") === 1;\n    }\n\n    _set_shrinkToFit(shrinkToFit) {\n        xmlq.setChildAttributes(this._xfNode, 'alignment', { shrinkToFit: shrinkToFit ? 1 : null });\n        xmlq.removeChildIfEmpty(this._xfNode, 'alignment');\n    }\n\n    _get_textDirection() {\n        const readingOrder = xmlq.getChildAttribute(this._xfNode, 'alignment', \"readingOrder\");\n        if (readingOrder === 1) return \"left-to-right\";\n        if (readingOrder === 2) return \"right-to-left\";\n        return readingOrder;\n    }\n\n    _set_textDirection(textDirection) {\n        let readingOrder;\n        if (textDirection === \"left-to-right\") readingOrder = 1;\n        else if (textDirection === \"right-to-left\") readingOrder = 2;\n        xmlq.setChildAttributes(this._xfNode, 'alignment', { readingOrder });\n        xmlq.removeChildIfEmpty(this._xfNode, 'alignment');\n    }\n\n    _getTextRotation() {\n        return xmlq.getChildAttribute(this._xfNode, 'alignment', \"textRotation\");\n    }\n\n    _setTextRotation(textRotation) {\n        xmlq.setChildAttributes(this._xfNode, 'alignment', { textRotation });\n        xmlq.removeChildIfEmpty(this._xfNode, 'alignment');\n    }\n\n    _get_textRotation() {\n        let textRotation = this._getTextRotation();\n\n        // Negative angles in Excel correspond to values > 90 in OOXML.\n        if (textRotation > 90) textRotation = 90 - textRotation;\n        return textRotation;\n    }\n\n    _set_textRotation(textRotation) {\n        // Negative angles in Excel correspond to values > 90 in OOXML.\n        if (textRotation < 0) textRotation = 90 - textRotation;\n        this._setTextRotation(textRotation);\n    }\n\n    _get_angleTextCounterclockwise() {\n        return this._getTextRotation() === 45;\n    }\n\n    _set_angleTextCounterclockwise(value) {\n        this._setTextRotation(value ? 45 : null);\n    }\n\n    _get_angleTextClockwise() {\n        return this._getTextRotation() === 135;\n    }\n\n    _set_angleTextClockwise(value) {\n        this._setTextRotation(value ? 135 : null);\n    }\n\n    _get_rotateTextUp() {\n        return this._getTextRotation() === 90;\n    }\n\n    _set_rotateTextUp(value) {\n        this._setTextRotation(value ? 90 : null);\n    }\n\n    _get_rotateTextDown() {\n        return this._getTextRotation() === 180;\n    }\n\n    _set_rotateTextDown(value) {\n        this._setTextRotation(value ? 180 : null);\n    }\n\n    _get_verticalText() {\n        return this._getTextRotation() === 255;\n    }\n\n    _set_verticalText(value) {\n        this._setTextRotation(value ? 255 : null);\n    }\n\n    _get_fill() {\n        const patternFillNode = xmlq.findChild(this._fillNode, 'patternFill');// jq.get(this._fillNode, \"patternFill[0]\");\n        const gradientFillNode = xmlq.findChild(this._fillNode, 'gradientFill');// jq.get(this._fillNode, \"gradientFill[0]\");\n        const patternType = patternFillNode && patternFillNode.attributes.patternType;// jq.get(patternFillNode, \"$.patternType\");\n\n        if (patternType === \"solid\") {\n            return {\n                type: \"solid\",\n                color: this._getColor(patternFillNode, \"fgColor\")\n            };\n        }\n\n        if (patternType) {\n            return {\n                type: \"pattern\",\n                pattern: patternType,\n                foreground: this._getColor(patternFillNode, \"fgColor\"),\n                background: this._getColor(patternFillNode, \"bgColor\")\n            };\n        }\n\n        if (gradientFillNode) {\n            const gradientType = gradientFillNode.attributes.type || \"linear\";\n            const fill = {\n                type: \"gradient\",\n                gradientType,\n                stops: _.map(gradientFillNode.children, stop => ({\n                    position: stop.attributes.position,\n                    color: this._getColor(stop, \"color\")\n                }))\n            };\n\n            if (gradientType === \"linear\") {\n                fill.angle = gradientFillNode.attributes.degree;\n            } else {\n                fill.left = gradientFillNode.attributes.left;\n                fill.right = gradientFillNode.attributes.right;\n                fill.top = gradientFillNode.attributes.top;\n                fill.bottom = gradientFillNode.attributes.bottom;\n            }\n\n            return fill;\n        }\n    }\n\n    _set_fill(fill) {\n        this._fillNode.children = [];\n\n        // No fill\n        if (_.isNil(fill)) return;\n\n        // Pattern fill\n        if (fill.type === \"pattern\") {\n            const patternFill = {\n                name: 'patternFill',\n                attributes: { patternType: fill.pattern },\n                children: []\n            };\n            this._fillNode.children.push(patternFill);\n            this._setColor(patternFill, \"fgColor\", fill.foreground);\n            this._setColor(patternFill, \"bgColor\", fill.background);\n            return;\n        }\n\n        // Gradient fill\n        if (fill.type === \"gradient\") {\n            const gradientFill = { name: 'gradientFill', attributes: {}, children: [] };\n            this._fillNode.children.push(gradientFill);\n            xmlq.setAttributes(gradientFill, {\n                type: fill.gradientType === \"path\" ? \"path\" : undefined,\n                left: fill.left,\n                right: fill.right,\n                top: fill.top,\n                bottom: fill.bottom,\n                degree: fill.angle\n            });\n\n            _.forEach(fill.stops, (fillStop, i) => {\n                const stop = {\n                    name: 'stop',\n                    attributes: { position: fillStop.position },\n                    children: []\n                };\n                gradientFill.children.push(stop);\n                this._setColor(stop, 'color', fillStop.color);\n            });\n\n            return;\n        }\n\n        // Solid fill (really a pattern fill with a solid pattern type).\n        if (!_.isObject(fill)) fill = { type: \"solid\", color: fill };\n        else if (fill.hasOwnProperty('rgb') || fill.hasOwnProperty(\"theme\")) fill = { color: fill };\n\n        const patternFill = {\n            name: 'patternFill',\n            attributes: { patternType: 'solid' }\n        };\n        this._fillNode.children.push(patternFill);\n        this._setColor(patternFill, \"fgColor\", fill.color);\n    }\n\n    _getBorder() {\n        const result = {};\n        [\"left\", \"right\", \"top\", \"bottom\", \"diagonal\"].forEach(side => {\n            const sideNode = xmlq.findChild(this._borderNode, side);\n            const sideResult = {};\n\n            const style = xmlq.getChildAttribute(this._borderNode, side, 'style');\n            if (style) sideResult.style = style;\n            const color = this._getColor(sideNode, 'color');\n            if (color) sideResult.color = color;\n\n            if (side === \"diagonal\") {\n                const up = this._borderNode.attributes.diagonalUp;\n                const down = this._borderNode.attributes.diagonalDown;\n                let direction;\n                if (up && down) direction = \"both\";\n                else if (up) direction = \"up\";\n                else if (down) direction = \"down\";\n                if (direction) sideResult.direction = direction;\n            }\n\n            if (!_.isEmpty(sideResult)) result[side] = sideResult;\n        });\n\n        return result;\n    }\n\n    _setBorder(settings) {\n        _.forOwn(settings, (setting, side) => {\n            if (typeof setting === \"boolean\") {\n                setting = { style: setting ? \"thin\" : null };\n            } else if (typeof setting === \"string\") {\n                setting = { style: setting };\n            } else if (setting === null || setting === undefined) {\n                setting = { style: null, color: null, direction: null };\n            }\n\n            if (setting.hasOwnProperty(\"style\")) {\n                xmlq.setChildAttributes(this._borderNode, side, { style: setting.style });\n            }\n\n            if (setting.hasOwnProperty(\"color\")) {\n                const sideNode = xmlq.findChild(this._borderNode, side);\n                this._setColor(sideNode, \"color\", setting.color);\n            }\n\n            if (side === \"diagonal\") {\n                xmlq.setAttributes(this._borderNode, {\n                    diagonalUp: setting.direction === \"up\" || setting.direction === \"both\" ? 1 : null,\n                    diagonalDown: setting.direction === \"down\" || setting.direction === \"both\" ? 1 : null\n                });\n            }\n        });\n    }\n\n    _get_border() {\n        return this._getBorder();\n    }\n\n    _set_border(settings) {\n        if (_.isObject(settings) && !settings.hasOwnProperty(\"style\") && !settings.hasOwnProperty(\"color\")) {\n            settings = _.defaults(settings, {\n                left: null,\n                right: null,\n                top: null,\n                bottom: null,\n                diagonal: null\n            });\n            this._setBorder(settings);\n        } else {\n            this._setBorder({\n                left: settings,\n                right: settings,\n                top: settings,\n                bottom: settings\n            });\n        }\n    }\n\n    _get_borderColor() {\n        return _.mapValues(this._getBorder(), value => value.color);\n    }\n\n    _set_borderColor(color) {\n        if (_.isObject(color)) {\n            this._setBorder(_.mapValues(color, color => ({ color })));\n        } else {\n            this._setBorder({\n                left: { color },\n                right: { color },\n                top: { color },\n                bottom: { color },\n                diagonal: { color }\n            });\n        }\n    }\n\n    _get_borderStyle() {\n        return _.mapValues(this._getBorder(), value => value.style);\n    }\n\n    _set_borderStyle(style) {\n        if (_.isObject(style)) {\n            this._setBorder(_.mapValues(style, style => ({ style })));\n        } else {\n            this._setBorder({\n                left: { style },\n                right: { style },\n                top: { style },\n                bottom: { style }\n            });\n        }\n    }\n\n    _get_diagonalBorderDirection() {\n        const border = this._getBorder().diagonal;\n        return border && border.direction;\n    }\n\n    _set_diagonalBorderDirection(direction) {\n        this._setBorder({ diagonal: { direction } });\n    }\n\n    _get_numberFormat() {\n        const numFmtId = this._xfNode.attributes.numFmtId || 0;\n        return this._styleSheet.getNumberFormatCode(numFmtId);\n    }\n\n    _set_numberFormat(formatCode) {\n        this._xfNode.attributes.numFmtId = this._styleSheet.getNumberFormatId(formatCode);\n    }\n}\n\n[\"left\", \"right\", \"top\", \"bottom\", \"diagonal\"].forEach(side => {\n    Style.prototype[`_get_${side}Border`] = function () {\n        return this._getBorder()[side];\n    };\n\n    Style.prototype[`_set_${side}Border`] = function (settings) {\n        this._setBorder({ [side]: settings });\n    };\n\n    Style.prototype[`_get_${side}BorderColor`] = function () {\n        const border = this._getBorder()[side];\n        return border && border.color;\n    };\n\n    Style.prototype[`_set_${side}BorderColor`] = function (color) {\n        this._setBorder({ [side]: { color } });\n    };\n\n    Style.prototype[`_get_${side}BorderStyle`] = function () {\n        const border = this._getBorder()[side];\n        return border && border.style;\n    };\n\n    Style.prototype[`_set_${side}BorderStyle`] = function (style) {\n        this._setBorder({ [side]: { style } });\n    };\n});\n\n// IE doesn't support function names so explicitly set it.\nif (!Style.name) Style.name = \"Style\";\n\nmodule.exports = Style;\n"]},"metadata":{},"sourceType":"script"}