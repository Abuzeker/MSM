{"ast":null,"code":"\"use strict\";\n\nvar _ = require(\"lodash\");\n/**\n * XML query methods.\n * @private\n */\n\n\nmodule.exports = {\n  /**\n   * Append a child to the node.\n   * @param {{}} node - The parent node.\n   * @param {{}} child - The child node.\n   * @returns {undefined}\n   */\n  appendChild: function appendChild(node, child) {\n    if (!node.children) node.children = [];\n    node.children.push(child);\n  },\n\n  /**\n   * Append a child if one with the given name is not found.\n   * @param {{}} node - The parent node.\n   * @param {string} name - The child node name.\n   * @returns {{}} The child.\n   */\n  appendChildIfNotFound: function appendChildIfNotFound(node, name) {\n    var child = this.findChild(node, name);\n\n    if (!child) {\n      child = {\n        name: name,\n        attributes: {},\n        children: []\n      };\n      this.appendChild(node, child);\n    }\n\n    return child;\n  },\n\n  /**\n   * Find a child with the given name.\n   * @param {{}} node - The parent node.\n   * @param {string} name - The name to find.\n   * @returns {undefined|{}} The child if found.\n   */\n  findChild: function findChild(node, name) {\n    return _.find(node.children, {\n      name: name\n    });\n  },\n\n  /**\n   * Get an attribute from a child node.\n   * @param {{}} node - The parent node.\n   * @param {string} name - The name of the child node.\n   * @param {string} attribute - The name of the attribute.\n   * @returns {undefined|*} The value of the attribute if found.\n   */\n  getChildAttribute: function getChildAttribute(node, name, attribute) {\n    var child = this.findChild(node, name);\n    if (child) return child.attributes && child.attributes[attribute];\n  },\n\n  /**\n   * Returns a value indicating whether the node has a child with the given name.\n   * @param {{}} node - The parent node.\n   * @param {string} name - The name of the child node.\n   * @returns {boolean} True if found, false otherwise.\n   */\n  hasChild: function hasChild(node, name) {\n    return _.some(node.children, {\n      name: name\n    });\n  },\n\n  /**\n   * Insert the child after the specified node.\n   * @param {{}} node - The parent node.\n   * @param {{}} child - The child node.\n   * @param {{}} after - The node to insert after.\n   * @returns {undefined}\n   */\n  insertAfter: function insertAfter(node, child, after) {\n    if (!node.children) node.children = [];\n    var index = node.children.indexOf(after);\n    node.children.splice(index + 1, 0, child);\n  },\n\n  /**\n   * Insert the child before the specified node.\n   * @param {{}} node - The parent node.\n   * @param {{}} child - The child node.\n   * @param {{}} before - The node to insert before.\n   * @returns {undefined}\n   */\n  insertBefore: function insertBefore(node, child, before) {\n    if (!node.children) node.children = [];\n    var index = node.children.indexOf(before);\n    node.children.splice(index, 0, child);\n  },\n\n  /**\n   * Insert a child node in the correct order.\n   * @param {{}} node - The parent node.\n   * @param {{}} child - The child node.\n   * @param {Array.<string>} nodeOrder - The order of the node names.\n   * @returns {undefined}\n   */\n  insertInOrder: function insertInOrder(node, child, nodeOrder) {\n    var childIndex = nodeOrder.indexOf(child.name);\n\n    if (node.children && childIndex >= 0) {\n      for (var i = childIndex + 1; i < nodeOrder.length; i++) {\n        var sibling = this.findChild(node, nodeOrder[i]);\n\n        if (sibling) {\n          this.insertBefore(node, child, sibling);\n          return;\n        }\n      }\n    }\n\n    this.appendChild(node, child);\n  },\n\n  /**\n   * Check if the node is empty (no attributes and no children).\n   * @param {{}} node - The node.\n   * @returns {boolean} True if empty, false otherwise.\n   */\n  isEmpty: function isEmpty(node) {\n    return _.isEmpty(node.children) && _.isEmpty(node.attributes);\n  },\n\n  /**\n   * Remove a child node.\n   * @param {{}} node - The parent node.\n   * @param {string|{}} child - The child node or name of node.\n   * @returns {undefined}\n   */\n  removeChild: function removeChild(node, child) {\n    if (!node.children) return;\n\n    if (typeof child === 'string') {\n      _.remove(node.children, {\n        name: child\n      });\n    } else {\n      var index = node.children.indexOf(child);\n      if (index >= 0) node.children.splice(index, 1);\n    }\n  },\n\n  /**\n   * Set/unset the attributes on the node.\n   * @param {{}} node - The node.\n   * @param {{}} attributes - The attributes to set.\n   * @returns {undefined}\n   */\n  setAttributes: function setAttributes(node, attributes) {\n    _.forOwn(attributes, function (value, attribute) {\n      if (_.isNil(value)) {\n        if (node.attributes) delete node.attributes[attribute];\n      } else {\n        if (!node.attributes) node.attributes = {};\n        node.attributes[attribute] = value;\n      }\n    });\n  },\n\n  /**\n   * Set attributes on a child node, creating the child if necessary.\n   * @param {{}} node - The parent node.\n   * @param {string} name - The name of the child node.\n   * @param {{}} attributes - The attributes to set.\n   * @returns {{}} The child.\n   */\n  setChildAttributes: function setChildAttributes(node, name, attributes) {\n    var _this = this;\n\n    var child = this.findChild(node, name);\n\n    _.forOwn(attributes, function (value, attribute) {\n      if (_.isNil(value)) {\n        if (child && child.attributes) delete child.attributes[attribute];\n      } else {\n        if (!child) {\n          child = {\n            name: name,\n            attributes: {},\n            children: []\n          };\n\n          _this.appendChild(node, child);\n        }\n\n        if (!child.attributes) child.attributes = {};\n        child.attributes[attribute] = value;\n      }\n    });\n\n    return child;\n  },\n\n  /**\n   * Remove the child node if empty.\n   * @param {{}} node - The parent node.\n   * @param {string|{}} child - The child or name of child node.\n   * @returns {undefined}\n   */\n  removeChildIfEmpty: function removeChildIfEmpty(node, child) {\n    if (typeof child === 'string') child = this.findChild(node, child);\n    if (child && this.isEmpty(child)) this.removeChild(node, child);\n  }\n};","map":{"version":3,"sources":["C:/Users/tzika/Desktop/Polymerlink-Front/polymerlink-2/node_modules/xlsx-populate/lib/xmlq.js"],"names":["_","require","module","exports","appendChild","node","child","children","push","appendChildIfNotFound","name","findChild","attributes","find","getChildAttribute","attribute","hasChild","some","insertAfter","after","index","indexOf","splice","insertBefore","before","insertInOrder","nodeOrder","childIndex","i","length","sibling","isEmpty","removeChild","remove","setAttributes","forOwn","value","isNil","setChildAttributes","removeChildIfEmpty"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst _ = require(\"lodash\");\n\n/**\n * XML query methods.\n * @private\n */\nmodule.exports = {\n    /**\n     * Append a child to the node.\n     * @param {{}} node - The parent node.\n     * @param {{}} child - The child node.\n     * @returns {undefined}\n     */\n    appendChild(node, child) {\n        if (!node.children) node.children = [];\n        node.children.push(child);\n    },\n\n    /**\n     * Append a child if one with the given name is not found.\n     * @param {{}} node - The parent node.\n     * @param {string} name - The child node name.\n     * @returns {{}} The child.\n     */\n    appendChildIfNotFound(node, name) {\n        let child = this.findChild(node, name);\n        if (!child) {\n            child = { name, attributes: {}, children: [] };\n            this.appendChild(node, child);\n        }\n\n        return child;\n    },\n\n    /**\n     * Find a child with the given name.\n     * @param {{}} node - The parent node.\n     * @param {string} name - The name to find.\n     * @returns {undefined|{}} The child if found.\n     */\n    findChild(node, name) {\n        return _.find(node.children, { name });\n    },\n\n    /**\n     * Get an attribute from a child node.\n     * @param {{}} node - The parent node.\n     * @param {string} name - The name of the child node.\n     * @param {string} attribute - The name of the attribute.\n     * @returns {undefined|*} The value of the attribute if found.\n     */\n    getChildAttribute(node, name, attribute) {\n        const child = this.findChild(node, name);\n        if (child) return child.attributes && child.attributes[attribute];\n    },\n\n    /**\n     * Returns a value indicating whether the node has a child with the given name.\n     * @param {{}} node - The parent node.\n     * @param {string} name - The name of the child node.\n     * @returns {boolean} True if found, false otherwise.\n     */\n    hasChild(node, name) {\n        return _.some(node.children, { name });\n    },\n\n    /**\n     * Insert the child after the specified node.\n     * @param {{}} node - The parent node.\n     * @param {{}} child - The child node.\n     * @param {{}} after - The node to insert after.\n     * @returns {undefined}\n     */\n    insertAfter(node, child, after) {\n        if (!node.children) node.children = [];\n        const index = node.children.indexOf(after);\n        node.children.splice(index + 1, 0, child);\n    },\n\n    /**\n     * Insert the child before the specified node.\n     * @param {{}} node - The parent node.\n     * @param {{}} child - The child node.\n     * @param {{}} before - The node to insert before.\n     * @returns {undefined}\n     */\n    insertBefore(node, child, before) {\n        if (!node.children) node.children = [];\n        const index = node.children.indexOf(before);\n        node.children.splice(index, 0, child);\n    },\n\n    /**\n     * Insert a child node in the correct order.\n     * @param {{}} node - The parent node.\n     * @param {{}} child - The child node.\n     * @param {Array.<string>} nodeOrder - The order of the node names.\n     * @returns {undefined}\n     */\n    insertInOrder(node, child, nodeOrder) {\n        const childIndex = nodeOrder.indexOf(child.name);\n        if (node.children && childIndex >= 0) {\n            for (let i = childIndex + 1; i < nodeOrder.length; i++) {\n                const sibling = this.findChild(node, nodeOrder[i]);\n                if (sibling) {\n                    this.insertBefore(node, child, sibling);\n                    return;\n                }\n            }\n        }\n\n        this.appendChild(node, child);\n    },\n\n    /**\n     * Check if the node is empty (no attributes and no children).\n     * @param {{}} node - The node.\n     * @returns {boolean} True if empty, false otherwise.\n     */\n    isEmpty(node) {\n        return _.isEmpty(node.children) && _.isEmpty(node.attributes);\n    },\n\n    /**\n     * Remove a child node.\n     * @param {{}} node - The parent node.\n     * @param {string|{}} child - The child node or name of node.\n     * @returns {undefined}\n     */\n    removeChild(node, child) {\n        if (!node.children) return;\n        if (typeof child === 'string') {\n            _.remove(node.children, { name: child });\n        } else {\n            const index = node.children.indexOf(child);\n            if (index >= 0) node.children.splice(index, 1);\n        }\n    },\n\n    /**\n     * Set/unset the attributes on the node.\n     * @param {{}} node - The node.\n     * @param {{}} attributes - The attributes to set.\n     * @returns {undefined}\n     */\n    setAttributes(node, attributes) {\n        _.forOwn(attributes, (value, attribute) => {\n            if (_.isNil(value)) {\n                if (node.attributes) delete node.attributes[attribute];\n            } else {\n                if (!node.attributes) node.attributes = {};\n                node.attributes[attribute] = value;\n            }\n        });\n    },\n\n    /**\n     * Set attributes on a child node, creating the child if necessary.\n     * @param {{}} node - The parent node.\n     * @param {string} name - The name of the child node.\n     * @param {{}} attributes - The attributes to set.\n     * @returns {{}} The child.\n     */\n    setChildAttributes(node, name, attributes) {\n        let child = this.findChild(node, name);\n        _.forOwn(attributes, (value, attribute) => {\n            if (_.isNil(value)) {\n                if (child && child.attributes) delete child.attributes[attribute];\n            } else {\n                if (!child) {\n                    child = { name, attributes: {}, children: [] };\n                    this.appendChild(node, child);\n                }\n\n                if (!child.attributes) child.attributes = {};\n                child.attributes[attribute] = value;\n            }\n        });\n\n        return child;\n    },\n\n    /**\n     * Remove the child node if empty.\n     * @param {{}} node - The parent node.\n     * @param {string|{}} child - The child or name of child node.\n     * @returns {undefined}\n     */\n    removeChildIfEmpty(node, child) {\n        if (typeof child === 'string') child = this.findChild(node, child);\n        if (child && this.isEmpty(child)) this.removeChild(node, child);\n    }\n};\n"]},"metadata":{},"sourceType":"script"}