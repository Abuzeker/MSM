{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:/Users/tzika/Desktop/Polymerlink-Front/polymerlink-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/tzika/Desktop/Polymerlink-Front/polymerlink-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _ = require(\"lodash\");\n\nvar Cell = require(\"./Cell\");\n\nvar Row = require(\"./Row\");\n\nvar Column = require(\"./Column\");\n\nvar Range = require(\"./Range\");\n\nvar Relationships = require(\"./Relationships\");\n\nvar xmlq = require(\"./xmlq\");\n\nvar regexify = require(\"./regexify\");\n\nvar addressConverter = require(\"./addressConverter\");\n\nvar ArgHandler = require(\"./ArgHandler\");\n\nvar colorIndexes = require(\"./colorIndexes\");\n\nvar PageBreaks = require(\"./PageBreaks\"); // Order of the nodes as defined by the spec.\n\n\nvar nodeOrder = [\"sheetPr\", \"dimension\", \"sheetViews\", \"sheetFormatPr\", \"cols\", \"sheetData\", \"sheetCalcPr\", \"sheetProtection\", \"autoFilter\", \"protectedRanges\", \"scenarios\", \"autoFilter\", \"sortState\", \"dataConsolidate\", \"customSheetViews\", \"mergeCells\", \"phoneticPr\", \"conditionalFormatting\", \"dataValidations\", \"hyperlinks\", \"printOptions\", \"pageMargins\", \"pageSetup\", \"headerFooter\", \"rowBreaks\", \"colBreaks\", \"customProperties\", \"cellWatches\", \"ignoredErrors\", \"smartTags\", \"drawing\", \"drawingHF\", \"legacyDrawing\", \"legacyDrawingHF\", \"picture\", \"oleObjects\", \"controls\", \"webPublishItems\", \"tableParts\", \"extLst\"];\n/**\n * A worksheet.\n */\n\nvar Sheet = /*#__PURE__*/function () {\n  // /**\n  //  * Creates a new instance of Sheet.\n  //  * @param {Workbook} workbook - The parent workbook.\n  //  * @param {{}} idNode - The sheet ID node (from the parent workbook).\n  //  * @param {{}} node - The sheet node.\n  //  * @param {{}} [relationshipsNode] - The optional sheet relationships node.\n  //  */\n  function Sheet(workbook, idNode, node, relationshipsNode) {\n    _classCallCheck(this, Sheet);\n\n    this._init(workbook, idNode, node, relationshipsNode);\n  }\n  /* PUBLIC */\n\n  /**\n   * Gets a value indicating whether the sheet is the active sheet in the workbook.\n   * @returns {boolean} True if active, false otherwise.\n   */\n\n  /**\n  * Make the sheet the active sheet in the workkbok.\n  * @param {boolean} active - Must be set to `true`. Deactivating directly is not supported. To deactivate, you should activate a different sheet instead.\n  * @returns {Sheet} The sheet.\n  */\n\n\n  _createClass(Sheet, [{\n    key: \"active\",\n    value: function active() {\n      var _this = this;\n\n      return new ArgHandler('Sheet.active').case(function () {\n        return _this.workbook().activeSheet() === _this;\n      }).case('boolean', function (active) {\n        if (!active) throw new Error(\"Deactivating sheet directly not supported. Activate a different sheet instead.\");\n\n        _this.workbook().activeSheet(_this);\n\n        return _this;\n      }).handle(arguments);\n    }\n    /**\n     * Get the active cell in the sheet.\n     * @returns {Cell} The active cell.\n     */\n\n    /**\n    * Set the active cell in the workbook.\n    * @param {string|Cell} cell - The cell or address of cell to activate.\n    * @returns {Sheet} The sheet.\n    */\n\n    /**\n    * Set the active cell in the workbook by row and column.\n    * @param {number} rowNumber - The row number of the cell.\n    * @param {string|number} columnNameOrNumber - The column name or number of the cell.\n    * @returns {Sheet} The sheet.\n    */\n\n  }, {\n    key: \"activeCell\",\n    value: function activeCell() {\n      var _this2 = this;\n\n      var sheetViewNode = this._getOrCreateSheetViewNode();\n\n      var selectionNode = xmlq.findChild(sheetViewNode, \"selection\");\n      return new ArgHandler('Sheet.activeCell').case(function () {\n        var cellAddress = selectionNode ? selectionNode.attributes.activeCell : \"A1\";\n        return _this2.cell(cellAddress);\n      }).case(['number', '*'], function (rowNumber, columnNameOrNumber) {\n        var cell = _this2.cell(rowNumber, columnNameOrNumber);\n\n        return _this2.activeCell(cell);\n      }).case('*', function (cell) {\n        if (!selectionNode) {\n          selectionNode = {\n            name: \"selection\",\n            attributes: {},\n            children: []\n          };\n          xmlq.appendChild(sheetViewNode, selectionNode);\n        }\n\n        if (!(cell instanceof Cell)) cell = _this2.cell(cell);\n        selectionNode.attributes.activeCell = selectionNode.attributes.sqref = cell.address();\n        return _this2;\n      }).handle(arguments);\n    }\n    /**\n     * Gets the cell with the given address.\n     * @param {string} address - The address of the cell.\n     * @returns {Cell} The cell.\n     */\n\n    /**\n    * Gets the cell with the given row and column numbers.\n    * @param {number} rowNumber - The row number of the cell.\n    * @param {string|number} columnNameOrNumber - The column name or number of the cell.\n    * @returns {Cell} The cell.\n    */\n\n  }, {\n    key: \"cell\",\n    value: function cell() {\n      var _this3 = this;\n\n      return new ArgHandler('Sheet.cell').case('string', function (address) {\n        var ref = addressConverter.fromAddress(address);\n        if (ref.type !== 'cell') throw new Error('Sheet.cell: Invalid address.');\n        return _this3.row(ref.rowNumber).cell(ref.columnNumber);\n      }).case(['number', '*'], function (rowNumber, columnNameOrNumber) {\n        return _this3.row(rowNumber).cell(columnNameOrNumber);\n      }).handle(arguments);\n    }\n    /**\n     * Gets a column in the sheet.\n     * @param {string|number} columnNameOrNumber - The name or number of the column.\n     * @returns {Column} The column.\n     */\n\n  }, {\n    key: \"column\",\n    value: function column(columnNameOrNumber) {\n      var columnNumber = typeof columnNameOrNumber === \"string\" ? addressConverter.columnNameToNumber(columnNameOrNumber) : columnNameOrNumber; // If we're already created a column for this column number, return it.\n\n      if (this._columns[columnNumber]) return this._columns[columnNumber]; // We need to create a new column, which requires a backing col node. There may already exist a node whose min/max cover our column.\n      // First, see if there is an existing col node.\n\n      var existingColNode = this._colNodes[columnNumber];\n      var colNode;\n\n      if (existingColNode) {\n        // If the existing node covered earlier columns than the new one, we need to have a col node to cover the min up to our new node.\n        if (existingColNode.attributes.min < columnNumber) {\n          // Clone the node and set the max to the column before our new col.\n          var beforeColNode = _.cloneDeep(existingColNode);\n\n          beforeColNode.attributes.max = columnNumber - 1; // Update the col nodes cache.\n\n          for (var i = beforeColNode.attributes.min; i <= beforeColNode.attributes.max; i++) {\n            this._colNodes[i] = beforeColNode;\n          }\n        } // Make a clone for the new column. Set the min/max to the column number and cache it.\n\n\n        colNode = _.cloneDeep(existingColNode);\n        colNode.attributes.min = columnNumber;\n        colNode.attributes.max = columnNumber;\n        this._colNodes[columnNumber] = colNode; // If the max of the existing node is greater than the nre one, create a col node for that too.\n\n        if (existingColNode.attributes.max > columnNumber) {\n          var afterColNode = _.cloneDeep(existingColNode);\n\n          afterColNode.attributes.min = columnNumber + 1;\n\n          for (var _i = afterColNode.attributes.min; _i <= afterColNode.attributes.max; _i++) {\n            this._colNodes[_i] = afterColNode;\n          }\n        }\n      } else {\n        // The was no existing node so create a new one.\n        colNode = {\n          name: 'col',\n          attributes: {\n            min: columnNumber,\n            max: columnNumber\n          },\n          children: []\n        };\n        this._colNodes[columnNumber] = colNode;\n      } // Create the new column and cache it.\n\n\n      var column = new Column(this, colNode);\n      this._columns[columnNumber] = column;\n      return column;\n    }\n    /**\n     * Gets a defined name scoped to the sheet.\n     * @param {string} name - The defined name.\n     * @returns {undefined|string|Cell|Range|Row|Column} What the defined name refers to or undefined if not found. Will return the string formula if not a Row, Column, Cell, or Range.\n     */\n\n    /**\n    * Set a defined name scoped to the sheet.\n    * @param {string} name - The defined name.\n    * @param {string|Cell|Range|Row|Column} refersTo - What the name refers to.\n    * @returns {Workbook} The workbook.\n    */\n\n  }, {\n    key: \"definedName\",\n    value: function definedName() {\n      var _this4 = this;\n\n      return new ArgHandler(\"Workbook.definedName\").case('string', function (name) {\n        return _this4.workbook().scopedDefinedName(_this4, name);\n      }).case(['string', '*'], function (name, refersTo) {\n        _this4.workbook().scopedDefinedName(_this4, name, refersTo);\n\n        return _this4;\n      }).handle(arguments);\n    }\n    /**\n     * Deletes the sheet and returns the parent workbook.\n     * @returns {Workbook} The workbook.\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      this.workbook().deleteSheet(this);\n      return this.workbook();\n    }\n    /**\n     * Find the given pattern in the sheet and optionally replace it.\n     * @param {string|RegExp} pattern - The pattern to look for. Providing a string will result in a case-insensitive substring search. Use a RegExp for more sophisticated searches.\n     * @param {string|function} [replacement] - The text to replace or a String.replace callback function. If pattern is a string, all occurrences of the pattern in each cell will be replaced.\n     * @returns {Array.<Cell>} The matching cells.\n     */\n\n  }, {\n    key: \"find\",\n    value: function find(pattern, replacement) {\n      pattern = regexify(pattern);\n      var matches = [];\n\n      this._rows.forEach(function (row) {\n        if (!row) return;\n        matches = matches.concat(row.find(pattern, replacement));\n      });\n\n      return matches;\n    }\n    /**\n     * Gets a value indicating whether this sheet's grid lines are visible.\n     * @returns {boolean} True if selected, false if not.\n     */\n\n    /**\n    * Sets whether this sheet's grid lines are visible.\n    * @param {boolean} selected - True to make visible, false to hide.\n    * @returns {Sheet} The sheet.\n    */\n\n  }, {\n    key: \"gridLinesVisible\",\n    value: function gridLinesVisible() {\n      var _this5 = this;\n\n      var sheetViewNode = this._getOrCreateSheetViewNode();\n\n      return new ArgHandler('Sheet.gridLinesVisible').case(function () {\n        return sheetViewNode.attributes.showGridLines === 1 || sheetViewNode.attributes.showGridLines === undefined;\n      }).case('boolean', function (visible) {\n        sheetViewNode.attributes.showGridLines = visible ? 1 : 0;\n        return _this5;\n      }).handle(arguments);\n    }\n    /**\n     * Gets a value indicating if the sheet is hidden or not.\n     * @returns {boolean|string} True if hidden, false if visible, and 'very' if very hidden.\n     */\n\n    /**\n    * Set whether the sheet is hidden or not.\n    * @param {boolean|string} hidden - True to hide, false to show, and 'very' to make very hidden.\n    * @returns {Sheet} The sheet.\n    */\n\n  }, {\n    key: \"hidden\",\n    value: function hidden() {\n      var _this6 = this;\n\n      return new ArgHandler('Sheet.hidden').case(function () {\n        if (_this6._idNode.attributes.state === 'hidden') return true;\n        if (_this6._idNode.attributes.state === 'veryHidden') return \"very\";\n        return false;\n      }).case('*', function (hidden) {\n        if (hidden) {\n          var visibleSheets = _.filter(_this6.workbook().sheets(), function (sheet) {\n            return !sheet.hidden();\n          });\n\n          if (visibleSheets.length === 1 && visibleSheets[0] === _this6) {\n            throw new Error(\"This sheet may not be hidden as a workbook must contain at least one visible sheet.\");\n          } // If activate, activate the first other visible sheet.\n\n\n          if (_this6.active()) {\n            var activeIndex = visibleSheets[0] === _this6 ? 1 : 0;\n            visibleSheets[activeIndex].active(true);\n          }\n        }\n\n        if (hidden === 'very') _this6._idNode.attributes.state = 'veryHidden';else if (hidden) _this6._idNode.attributes.state = 'hidden';else delete _this6._idNode.attributes.state;\n        return _this6;\n      }).handle(arguments);\n    }\n    /**\n     * Move the sheet.\n     * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.\n     * @returns {Sheet} The sheet.\n     */\n\n  }, {\n    key: \"move\",\n    value: function move(indexOrBeforeSheet) {\n      this.workbook().moveSheet(this, indexOrBeforeSheet);\n      return this;\n    }\n    /**\n     * Get the name of the sheet.\n     * @returns {string} The sheet name.\n     */\n\n    /**\n    * Set the name of the sheet. *Note: this method does not rename references to the sheet so formulas, etc. can be broken. Use with caution!*\n    * @param {string} name - The name to set to the sheet.\n    * @returns {Sheet} The sheet.\n    */\n\n  }, {\n    key: \"name\",\n    value: function name() {\n      var _this7 = this;\n\n      return new ArgHandler('Sheet.name').case(function () {\n        return \"\".concat(_this7._idNode.attributes.name);\n      }).case('string', function (name) {\n        _this7._idNode.attributes.name = name;\n        return _this7;\n      }).handle(arguments);\n    }\n    /**\n     * Gets a range from the given range address.\n     * @param {string} address - The range address (e.g. 'A1:B3').\n     * @returns {Range} The range.\n     */\n\n    /**\n    * Gets a range from the given cells or cell addresses.\n    * @param {string|Cell} startCell - The starting cell or cell address (e.g. 'A1').\n    * @param {string|Cell} endCell - The ending cell or cell address (e.g. 'B3').\n    * @returns {Range} The range.\n    */\n\n    /**\n    * Gets a range from the given row numbers and column names or numbers.\n    * @param {number} startRowNumber - The starting cell row number.\n    * @param {string|number} startColumnNameOrNumber - The starting cell column name or number.\n    * @param {number} endRowNumber - The ending cell row number.\n    * @param {string|number} endColumnNameOrNumber - The ending cell column name or number.\n    * @returns {Range} The range.\n    */\n\n  }, {\n    key: \"range\",\n    value: function range() {\n      var _this8 = this;\n\n      return new ArgHandler('Sheet.range').case('string', function (address) {\n        var ref = addressConverter.fromAddress(address);\n        if (ref.type !== 'range') throw new Error('Sheet.range: Invalid address');\n        return _this8.range(ref.startRowNumber, ref.startColumnNumber, ref.endRowNumber, ref.endColumnNumber);\n      }).case(['*', '*'], function (startCell, endCell) {\n        if (typeof startCell === \"string\") startCell = _this8.cell(startCell);\n        if (typeof endCell === \"string\") endCell = _this8.cell(endCell);\n        return new Range(startCell, endCell);\n      }).case(['number', '*', 'number', '*'], function (startRowNumber, startColumnNameOrNumber, endRowNumber, endColumnNameOrNumber) {\n        return _this8.range(_this8.cell(startRowNumber, startColumnNameOrNumber), _this8.cell(endRowNumber, endColumnNameOrNumber));\n      }).handle(arguments);\n    }\n    /**\n     * Unsets sheet autoFilter.\n     * @returns {Sheet} This sheet.\n     */\n\n    /**\n    * Sets sheet autoFilter to a Range.\n    * @param {Range} range - The autoFilter range.\n    * @returns {Sheet} This sheet.\n    */\n\n  }, {\n    key: \"autoFilter\",\n    value: function autoFilter(range) {\n      this._autoFilter = range;\n      return this;\n    }\n    /**\n     * Gets the row with the given number.\n     * @param {number} rowNumber - The row number.\n     * @returns {Row} The row with the given number.\n     */\n\n  }, {\n    key: \"row\",\n    value: function row(rowNumber) {\n      if (rowNumber < 1) throw new RangeError(\"Invalid row number \".concat(rowNumber, \". Remember that spreadsheets use 1-based indexing.\"));\n      if (this._rows[rowNumber]) return this._rows[rowNumber];\n      var rowNode = {\n        name: 'row',\n        attributes: {\n          r: rowNumber\n        },\n        children: []\n      };\n      var row = new Row(this, rowNode);\n      this._rows[rowNumber] = row;\n      return row;\n    }\n    /**\n     * Get the tab color. (See style [Color](#color).)\n     * @returns {undefined|Color} The color or undefined if not set.\n     */\n\n    /**\n    * Sets the tab color. (See style [Color](#color).)\n    * @returns {Color|string|number} color - Color of the tab. If string, will set an RGB color. If number, will set a theme color.\n    */\n\n  }, {\n    key: \"tabColor\",\n    value: function tabColor() {\n      var _this9 = this;\n\n      return new ArgHandler(\"Sheet.tabColor\").case(function () {\n        var tabColorNode = xmlq.findChild(_this9._sheetPrNode, \"tabColor\");\n        if (!tabColorNode) return;\n        var color = {};\n        if (tabColorNode.attributes.hasOwnProperty('rgb')) color.rgb = tabColorNode.attributes.rgb;else if (tabColorNode.attributes.hasOwnProperty('theme')) color.theme = tabColorNode.attributes.theme;else if (tabColorNode.attributes.hasOwnProperty('indexed')) color.rgb = colorIndexes[tabColorNode.attributes.indexed];\n        if (tabColorNode.attributes.hasOwnProperty('tint')) color.tint = tabColorNode.attributes.tint;\n        return color;\n      }).case(\"string\", function (rgb) {\n        return _this9.tabColor({\n          rgb: rgb\n        });\n      }).case(\"integer\", function (theme) {\n        return _this9.tabColor({\n          theme: theme\n        });\n      }).case(\"nil\", function () {\n        xmlq.removeChild(_this9._sheetPrNode, \"tabColor\");\n        return _this9;\n      }).case(\"object\", function (color) {\n        var tabColorNode = xmlq.appendChildIfNotFound(_this9._sheetPrNode, \"tabColor\");\n        xmlq.setAttributes(tabColorNode, {\n          rgb: color.rgb && color.rgb.toUpperCase(),\n          indexed: null,\n          theme: color.theme,\n          tint: color.tint\n        });\n        return _this9;\n      }).handle(arguments);\n    }\n    /**\n     * Gets a value indicating whether this sheet is selected.\n     * @returns {boolean} True if selected, false if not.\n     */\n\n    /**\n    * Sets whether this sheet is selected.\n    * @param {boolean} selected - True to select, false to deselected.\n    * @returns {Sheet} The sheet.\n    */\n\n  }, {\n    key: \"tabSelected\",\n    value: function tabSelected() {\n      var _this10 = this;\n\n      var sheetViewNode = this._getOrCreateSheetViewNode();\n\n      return new ArgHandler('Sheet.tabSelected').case(function () {\n        return sheetViewNode.attributes.tabSelected === 1;\n      }).case('boolean', function (selected) {\n        if (selected) sheetViewNode.attributes.tabSelected = 1;else delete sheetViewNode.attributes.tabSelected;\n        return _this10;\n      }).handle(arguments);\n    }\n    /**\n     * Gets a value indicating whether this sheet is rtl (Right To Left).\n     * @returns {boolean} True if rtl, false if ltr.\n     */\n\n    /**\n    * Sets whether this sheet is rtl.\n    * @param {boolean} rtl - True to rtl, false to ltr (Left To Right).\n    * @returns {Sheet} The sheet.\n    */\n\n  }, {\n    key: \"rightToLeft\",\n    value: function rightToLeft() {\n      var _this11 = this;\n\n      var sheetViewNode = this._getOrCreateSheetViewNode();\n\n      return new ArgHandler('Sheet.rightToLeft').case(function () {\n        return sheetViewNode.attributes.rightToLeft;\n      }).case('boolean', function (rtl) {\n        if (rtl) sheetViewNode.attributes.rightToLeft = true;else delete sheetViewNode.attributes.rightToLeft;\n        return _this11;\n      }).handle(arguments);\n    }\n    /**\n     * Get the range of cells in the sheet that have contained a value or style at any point. Useful for extracting the entire sheet contents.\n     * @returns {Range|undefined} The used range or undefined if no cells in the sheet are used.\n     */\n\n  }, {\n    key: \"usedRange\",\n    value: function usedRange() {\n      var minRowNumber = _.findIndex(this._rows);\n\n      var maxRowNumber = this._rows.length - 1;\n      var minColumnNumber = 0;\n      var maxColumnNumber = 0;\n\n      for (var i = 0; i < this._rows.length; i++) {\n        var row = this._rows[i];\n        if (!row) continue;\n        var minUsedColumnNumber = row.minUsedColumnNumber();\n        var maxUsedColumnNumber = row.maxUsedColumnNumber();\n        if (minUsedColumnNumber > 0 && (!minColumnNumber || minUsedColumnNumber < minColumnNumber)) minColumnNumber = minUsedColumnNumber;\n        if (maxUsedColumnNumber > 0 && (!maxColumnNumber || maxUsedColumnNumber > maxColumnNumber)) maxColumnNumber = maxUsedColumnNumber;\n      } // Return undefined if nothing in the sheet is used.\n\n\n      if (minRowNumber <= 0 || minColumnNumber <= 0 || maxRowNumber <= 0 || maxColumnNumber <= 0) return;\n      return this.range(minRowNumber, minColumnNumber, maxRowNumber, maxColumnNumber);\n    }\n    /**\n     * Gets the parent workbook.\n     * @returns {Workbook} The parent workbook.\n     */\n\n  }, {\n    key: \"workbook\",\n    value: function workbook() {\n      return this._workbook;\n    }\n    /**\n     * Gets all page breaks.\n     * @returns {{}} the object holds both vertical and horizontal PageBreaks.\n     */\n\n  }, {\n    key: \"pageBreaks\",\n    value: function pageBreaks() {\n      return this._pageBreaks;\n    }\n    /**\n     * Gets the vertical page breaks.\n     * @returns {PageBreaks} vertical PageBreaks.\n     */\n\n  }, {\n    key: \"verticalPageBreaks\",\n    value: function verticalPageBreaks() {\n      return this._pageBreaks.colBreaks;\n    }\n    /**\n     * Gets the horizontal page breaks.\n     * @returns {PageBreaks} horizontal PageBreaks.\n     */\n\n  }, {\n    key: \"horizontalPageBreaks\",\n    value: function horizontalPageBreaks() {\n      return this._pageBreaks.rowBreaks;\n    }\n    /* INTERNAL */\n\n    /**\n     * Clear cells that are using a given shared formula ID.\n     * @param {number} sharedFormulaId - The shared formula ID.\n     * @returns {undefined}\n     * @ignore\n     */\n\n  }, {\n    key: \"clearCellsUsingSharedFormula\",\n    value: function clearCellsUsingSharedFormula(sharedFormulaId) {\n      this._rows.forEach(function (row) {\n        if (!row) return;\n        row.clearCellsUsingSharedFormula(sharedFormulaId);\n      });\n    }\n    /**\n     * Get an existing column style ID.\n     * @param {number} columnNumber - The column number.\n     * @returns {undefined|number} The style ID.\n     * @ignore\n     */\n\n  }, {\n    key: \"existingColumnStyleId\",\n    value: function existingColumnStyleId(columnNumber) {\n      // This will work after setting Column.style because Column updates the attributes live.\n      var colNode = this._colNodes[columnNumber];\n      return colNode && colNode.attributes.style;\n    }\n    /**\n     * Call a callback for each column number that has a node defined for it.\n     * @param {Function} callback - The callback.\n     * @returns {undefined}\n     * @ignore\n     */\n\n  }, {\n    key: \"forEachExistingColumnNumber\",\n    value: function forEachExistingColumnNumber(callback) {\n      _.forEach(this._colNodes, function (node, columnNumber) {\n        if (!node) return;\n        callback(columnNumber);\n      });\n    }\n    /**\n     * Call a callback for each existing row.\n     * @param {Function} callback - The callback.\n     * @returns {undefined}\n     * @ignore\n     */\n\n  }, {\n    key: \"forEachExistingRow\",\n    value: function forEachExistingRow(callback) {\n      _.forEach(this._rows, function (row, rowNumber) {\n        if (row) callback(row, rowNumber);\n      });\n\n      return this;\n    }\n    /**\n     * Get the hyperlink attached to the cell with the given address.\n     * @param {string} address - The address of the hyperlinked cell.\n     * @returns {string|undefined} The hyperlink or undefined if not set.\n     */\n\n    /**\n    * Set the hyperlink on the cell with the given address.\n    * @param {string} address - The address of the hyperlinked cell.\n    * @param {string} hyperlink - The hyperlink to set or undefined to clear.\n    * @param {boolean} [internal] - The flag to force hyperlink to be internal. If true, then autodetect is skipped.\n    * @returns {Sheet} The sheet.\n    */\n\n    /**\n    * Set the hyperlink on the cell with the given address. If opts is a Cell an internal hyperlink is added.\n    * @param {string} address - The address of the hyperlinked cell.\n    * @param {object|Cell} opts - Options.\n    * @returns {Sheet} The sheet.\n    * @ignore\n    */\n\n    /**\n    * Set the hyperlink on the cell with the given address and options.\n    * @param {string} address - The address of the hyperlinked cell.\n    * @param {{}|Cell} opts - Options or Cell. If opts is a Cell then an internal hyperlink is added.\n    * @param {string|Cell} [opts.hyperlink] - The hyperlink to set, can be a Cell or an internal/external string.\n    * @param {string} [opts.tooltip] - Additional text to help the user understand more about the hyperlink.\n    * @param {string} [opts.email] - Email address, ignored if opts.hyperlink is set.\n    * @param {string} [opts.emailSubject] - Email subject, ignored if opts.hyperlink is set.\n    * @returns {Sheet} The sheet.\n    */\n\n  }, {\n    key: \"hyperlink\",\n    value: function hyperlink() {\n      var _this12 = this;\n\n      return new ArgHandler('Sheet.hyperlink').case('string', function (address) {\n        var hyperlinkNode = _this12._hyperlinks[address];\n        if (!hyperlinkNode) return;\n\n        var relationship = _this12._relationships.findById(hyperlinkNode.attributes['r:id']);\n\n        return relationship && relationship.attributes.Target;\n      }).case(['string', 'nil'], function (address) {\n        // TODO: delete relationship\n        delete _this12._hyperlinks[address];\n        return _this12;\n      }).case(['string', 'string'], function (address, hyperlink) {\n        return _this12.hyperlink(address, hyperlink, false);\n      }).case(['string', 'string', 'boolean'], function (address, hyperlink, internal) {\n        var isHyperlinkInternalAddress = internal || addressConverter.fromAddress(hyperlink);\n        var nodeAttributes;\n\n        if (isHyperlinkInternalAddress) {\n          nodeAttributes = {\n            ref: address,\n            location: hyperlink,\n            display: hyperlink\n          };\n        } else {\n          var relationship = _this12._relationships.add(\"hyperlink\", hyperlink, \"External\");\n\n          nodeAttributes = {\n            ref: address,\n            'r:id': relationship.attributes.Id\n          };\n        }\n\n        _this12._hyperlinks[address] = {\n          name: 'hyperlink',\n          attributes: nodeAttributes,\n          children: []\n        };\n        return _this12;\n      }).case(['string', 'object'], function (address, opts) {\n        if (opts instanceof Cell) {\n          var cell = opts;\n          var hyperlink = cell.address({\n            includeSheetName: true\n          });\n\n          _this12.hyperlink(address, hyperlink, true);\n        } else if (opts.hyperlink) {\n          _this12.hyperlink(address, opts.hyperlink);\n        } else if (opts.email) {\n          var email = opts.email;\n          var subject = opts.emailSubject || '';\n\n          _this12.hyperlink(address, encodeURI(\"mailto:\".concat(email, \"?subject=\").concat(subject)));\n        }\n\n        var hyperlinkNode = _this12._hyperlinks[address];\n\n        if (hyperlinkNode) {\n          if (opts.tooltip) {\n            hyperlinkNode.attributes.tooltip = opts.tooltip;\n          }\n        }\n\n        return _this12;\n      }).handle(arguments);\n    }\n    /**\n     * Increment and return the max shared formula ID.\n     * @returns {number} The new max shared formula ID.\n     * @ignore\n     */\n\n  }, {\n    key: \"incrementMaxSharedFormulaId\",\n    value: function incrementMaxSharedFormulaId() {\n      return ++this._maxSharedFormulaId;\n    }\n    /**\n     * Get a value indicating whether the cells in the given address are merged.\n     * @param {string} address - The address to check.\n     * @returns {boolean} True if merged, false if not merged.\n     * @ignore\n     */\n\n    /**\n    * Merge/unmerge cells by adding/removing a mergeCell entry.\n    * @param {string} address - The address to merge.\n    * @param {boolean} merged - True to merge, false to unmerge.\n    * @returns {Sheet} The sheet.\n    * @ignore\n    */\n\n  }, {\n    key: \"merged\",\n    value: function merged() {\n      var _this13 = this;\n\n      return new ArgHandler('Sheet.merge').case('string', function (address) {\n        return _this13._mergeCells.hasOwnProperty(address);\n      }).case(['string', '*'], function (address, merge) {\n        if (merge) {\n          _this13._mergeCells[address] = {\n            name: 'mergeCell',\n            attributes: {\n              ref: address\n            },\n            children: []\n          };\n        } else {\n          delete _this13._mergeCells[address];\n        }\n\n        return _this13;\n      }).handle(arguments);\n    }\n    /**\n     * Gets a Object or undefined of the cells in the given address.\n     * @param {string} address - The address to check.\n     * @returns {object|boolean} Object or false if not set\n     * @ignore\n     */\n\n    /**\n    * Removes dataValidation at the given address\n    * @param {string} address - The address to remove.\n    * @param {boolean} obj - false to delete.\n    * @returns {boolean} true if removed.\n    * @ignore\n    */\n\n    /**\n    * Add dataValidation to cells at the given address if object or string\n    * @param {string} address - The address to set.\n    * @param {object|string} obj - Object or String to set\n    * @returns {Sheet} The sheet.\n    * @ignore\n    */\n\n  }, {\n    key: \"dataValidation\",\n    value: function dataValidation() {\n      var _this14 = this;\n\n      return new ArgHandler('Sheet.dataValidation').case('string', function (address) {\n        if (_this14._dataValidations[address]) {\n          return {\n            type: _this14._dataValidations[address].attributes.type,\n            allowBlank: _this14._dataValidations[address].attributes.allowBlank,\n            showInputMessage: _this14._dataValidations[address].attributes.showInputMessage,\n            prompt: _this14._dataValidations[address].attributes.prompt,\n            promptTitle: _this14._dataValidations[address].attributes.promptTitle,\n            showErrorMessage: _this14._dataValidations[address].attributes.showErrorMessage,\n            error: _this14._dataValidations[address].attributes.error,\n            errorTitle: _this14._dataValidations[address].attributes.errorTitle,\n            operator: _this14._dataValidations[address].attributes.operator,\n            formula1: _this14._dataValidations[address].children[0].children[0],\n            formula2: _this14._dataValidations[address].children[1] ? _this14._dataValidations[address].children[1].children[0] : undefined\n          };\n        } else {\n          return false;\n        }\n      }).case(['string', 'boolean'], function (address, obj) {\n        if (_this14._dataValidations[address]) {\n          if (obj === false) return delete _this14._dataValidations[address];\n        } else {\n          return false;\n        }\n      }).case(['string', '*'], function (address, obj) {\n        if (typeof obj === 'string') {\n          _this14._dataValidations[address] = {\n            name: 'dataValidation',\n            attributes: {\n              type: 'list',\n              allowBlank: false,\n              showInputMessage: false,\n              prompt: '',\n              promptTitle: '',\n              showErrorMessage: false,\n              error: '',\n              errorTitle: '',\n              operator: '',\n              sqref: address\n            },\n            children: [{\n              name: 'formula1',\n              atrributes: {},\n              children: [obj]\n            }, {\n              name: 'formula2',\n              atrributes: {},\n              children: ['']\n            }]\n          };\n        } else if (typeof obj === 'object') {\n          _this14._dataValidations[address] = {\n            name: 'dataValidation',\n            attributes: {\n              type: obj.type ? obj.type : 'list',\n              allowBlank: obj.allowBlank,\n              showInputMessage: obj.showInputMessage,\n              prompt: obj.prompt,\n              promptTitle: obj.promptTitle,\n              showErrorMessage: obj.showErrorMessage,\n              error: obj.error,\n              errorTitle: obj.errorTitle,\n              operator: obj.operator,\n              sqref: address\n            },\n            children: [{\n              name: 'formula1',\n              atrributes: {},\n              children: [obj.formula1]\n            }, {\n              name: 'formula2',\n              atrributes: {},\n              children: [obj.formula2]\n            }]\n          };\n        }\n\n        return _this14;\n      }).handle(arguments);\n    }\n    /**\n     * Convert the sheet to a collection of XML objects.\n     * @returns {{}} The XML forms.\n     * @ignore\n     */\n\n  }, {\n    key: \"toXmls\",\n    value: function toXmls() {\n      var _this15 = this;\n\n      // Shallow clone the node so we don't have to remove these children later if they don't belong.\n      var node = _.clone(this._node);\n\n      node.children = node.children.slice(); // Add the columns if needed.\n\n      this._colsNode.children = _.filter(this._colNodes, function (colNode, i) {\n        // Columns should only be present if they have attributes other than min/max.\n        return colNode && i === colNode.attributes.min && Object.keys(colNode.attributes).length > 2;\n      });\n\n      if (this._colsNode.children.length) {\n        xmlq.insertInOrder(node, this._colsNode, nodeOrder);\n      } // Add the hyperlinks if needed.\n\n\n      this._hyperlinksNode.children = _.values(this._hyperlinks);\n\n      if (this._hyperlinksNode.children.length) {\n        xmlq.insertInOrder(node, this._hyperlinksNode, nodeOrder);\n      } // Add the printOptions if needed.\n\n\n      if (this._printOptionsNode) {\n        if (Object.keys(this._printOptionsNode.attributes).length) {\n          xmlq.insertInOrder(node, this._printOptionsNode, nodeOrder);\n        }\n      } // Add the pageMargins if needed.\n\n\n      if (this._pageMarginsNode && this._pageMarginsPresetName) {\n        // Clone to preserve the current state of this sheet.\n        var childNode = _.clone(this._pageMarginsNode);\n\n        if (Object.keys(this._pageMarginsNode.attributes).length) {\n          // Fill in any missing attribute values with presets.\n          childNode.attributes = _.assign(this._pageMarginsPresets[this._pageMarginsPresetName], this._pageMarginsNode.attributes);\n        } else {\n          // No need to fill in, all attributes is currently empty, simply replace.\n          childNode.attributes = this._pageMarginsPresets[this._pageMarginsPresetName];\n        }\n\n        xmlq.insertInOrder(node, childNode, nodeOrder);\n      } // Add the merge cells if needed.\n\n\n      this._mergeCellsNode.children = _.values(this._mergeCells);\n\n      if (this._mergeCellsNode.children.length) {\n        xmlq.insertInOrder(node, this._mergeCellsNode, nodeOrder);\n      } // Add the DataValidation cells if needed.\n\n\n      this._dataValidationsNode.children = _.values(this._dataValidations);\n\n      if (this._dataValidationsNode.children.length) {\n        xmlq.insertInOrder(node, this._dataValidationsNode, nodeOrder);\n      }\n\n      if (this._autoFilter) {\n        xmlq.insertInOrder(node, {\n          name: \"autoFilter\",\n          children: [],\n          attributes: {\n            ref: this._autoFilter.address()\n          }\n        }, nodeOrder);\n      } // Add the PageBreaks nodes if needed.\n\n\n      ['colBreaks', 'rowBreaks'].forEach(function (name) {\n        var breaks = _this15[\"_\".concat(name, \"Node\")];\n\n        if (breaks.attributes.count) {\n          xmlq.insertInOrder(node, breaks, nodeOrder);\n        }\n      });\n      return {\n        id: this._idNode,\n        sheet: node,\n        relationships: this._relationships\n      };\n    }\n    /**\n     * Update the max shared formula ID to the given value if greater than current.\n     * @param {number} sharedFormulaId - The new shared formula ID.\n     * @returns {undefined}\n     * @ignore\n     */\n\n  }, {\n    key: \"updateMaxSharedFormulaId\",\n    value: function updateMaxSharedFormulaId(sharedFormulaId) {\n      if (sharedFormulaId > this._maxSharedFormulaId) {\n        this._maxSharedFormulaId = sharedFormulaId;\n      }\n    }\n    /**\n     * Get the print option given a valid print option attribute.\n     * @param {string} attributeName - Attribute name of the printOptions.\n     *   gridLines - Used in conjunction with gridLinesSet. If both gridLines and gridlinesSet are true, then grid lines shall print. Otherwise, they shall not (i.e., one or both have false values).\n     *   gridLinesSet - Used in conjunction with gridLines. If both gridLines and gridLinesSet are true, then grid lines shall print. Otherwise, they shall not (i.e., one or both have false values).\n     *   headings - Print row and column headings.\n     *   horizontalCentered - Center on page horizontally when printing.\n     *   verticalCentered - Center on page vertically when printing.\n     * @returns {boolean}\n     */\n\n    /**\n    * Set the print option given a valid print option attribute and a value.\n    * @param {string} attributeName - Attribute name of the printOptions. See get print option for list of valid attributes.\n    * @param {undefined|boolean} attributeEnabled - If `undefined` or `false` then the attribute is removed, otherwise the print option is enabled.\n    * @returns {Sheet} The sheet.\n    */\n\n  }, {\n    key: \"printOptions\",\n    value: function printOptions() {\n      var _this16 = this;\n\n      var supportedAttributeNames = ['gridLines', 'gridLinesSet', 'headings', 'horizontalCentered', 'verticalCentered'];\n\n      var checkAttributeName = this._getCheckAttributeNameHelper('printOptions', supportedAttributeNames);\n\n      return new ArgHandler('Sheet.printOptions').case(['string'], function (attributeName) {\n        checkAttributeName(attributeName);\n        return _this16._printOptionsNode.attributes[attributeName] === 1;\n      }).case(['string', 'nil'], function (attributeName) {\n        checkAttributeName(attributeName);\n        delete _this16._printOptionsNode.attributes[attributeName];\n        return _this16;\n      }).case(['string', 'boolean'], function (attributeName, attributeEnabled) {\n        checkAttributeName(attributeName);\n\n        if (attributeEnabled) {\n          _this16._printOptionsNode.attributes[attributeName] = 1;\n          return _this16;\n        } else {\n          return _this16.printOptions(attributeName, undefined);\n        }\n      }).handle(arguments);\n    }\n    /**\n     * Get the print option for the gridLines attribute value.\n     * @returns {boolean}\n     */\n\n    /**\n    * Set the print option for the gridLines attribute value.\n    * @param {undefined|boolean} enabled - If `undefined` or `false` then attribute is removed, otherwise gridLines is enabled.\n    * @returns {Sheet} The sheet.\n    */\n\n  }, {\n    key: \"printGridLines\",\n    value: function printGridLines() {\n      var _this17 = this;\n\n      return new ArgHandler('Sheet.gridLines').case(function () {\n        return _this17.printOptions('gridLines') && _this17.printOptions('gridLinesSet');\n      }).case(['nil'], function () {\n        _this17.printOptions('gridLines', undefined);\n\n        _this17.printOptions('gridLinesSet', undefined);\n\n        return _this17;\n      }).case(['boolean'], function (enabled) {\n        _this17.printOptions('gridLines', enabled);\n\n        _this17.printOptions('gridLinesSet', enabled);\n\n        return _this17;\n      }).handle(arguments);\n    }\n    /**\n     * Get the page margin given a valid attribute name.\n     * If the value is not yet defined, then it will return the current preset value.\n     * @param {string} attributeName - Attribute name of the pageMargins.\n     *     left - Left Page Margin in inches.\n     *     right - Right page margin in inches.\n     *     top - Top Page Margin in inches.\n     *     buttom - Bottom Page Margin in inches.\n     *     footer - Footer Page Margin in inches.\n     *     header - Header Page Margin in inches.\n     * @returns {number} the attribute value.\n     */\n\n    /**\n    * Set the page margin (or override the preset) given an attribute name and a value.\n    * @param {string} attributeName - Attribute name of the pageMargins. See get page margin for list of valid attributes.\n    * @param {undefined|number|string} attributeStringValue - If `undefined` then set back to preset value, otherwise, set the given attribute value.\n    * @returns {Sheet} The sheet.\n    */\n\n  }, {\n    key: \"pageMargins\",\n    value: function pageMargins() {\n      var _this18 = this;\n\n      if (this.pageMarginsPreset() === undefined) {\n        throw new Error('Sheet.pageMargins: preset is undefined.');\n      }\n\n      var supportedAttributeNames = ['left', 'right', 'top', 'bottom', 'header', 'footer'];\n\n      var checkAttributeName = this._getCheckAttributeNameHelper('pageMargins', supportedAttributeNames);\n\n      var checkRange = this._getCheckRangeHelper('pageMargins', 0, undefined);\n\n      return new ArgHandler('Sheet.pageMargins').case(['string'], function (attributeName) {\n        checkAttributeName(attributeName);\n        var attributeValue = _this18._pageMarginsNode.attributes[attributeName];\n\n        if (attributeValue !== undefined) {\n          return parseFloat(attributeValue);\n        } else if (_this18._pageMarginsPresetName) {\n          return parseFloat(_this18._pageMarginsPresets[_this18._pageMarginsPresetName][attributeName]);\n        } else {\n          return undefined;\n        }\n      }).case(['string', 'nil'], function (attributeName) {\n        checkAttributeName(attributeName);\n        delete _this18._pageMarginsNode.attributes[attributeName];\n        return _this18;\n      }).case(['string', 'number'], function (attributeName, attributeNumberValue) {\n        checkAttributeName(attributeName);\n        checkRange(attributeNumberValue);\n        _this18._pageMarginsNode.attributes[attributeName] = attributeNumberValue;\n        return _this18;\n      }).case(['string', 'string'], function (attributeName, attributeStringValue) {\n        return _this18.pageMargins(attributeName, parseFloat(attributeStringValue));\n      }).handle(arguments);\n    }\n    /**\n     * Page margins preset is a set of page margins associated with a name.\n     * The page margin preset acts as a fallback when not explicitly defined by `Sheet.pageMargins`.\n     * If a sheet already contains page margins, it attempts to auto-detect, otherwise they are defined as the template preset.\n     * If no page margins exist, then the preset is undefined and will not be included in the output of `Sheet.toXmls`.\n     * Available presets include: normal, wide, narrow, template.\n     *\n     * Get the page margins preset name. The registered name of a predefined set of attributes.\n     * @returns {string} The preset name.\n     */\n\n    /**\n    * Set the page margins preset by name, clearing any existing/temporary attribute values.\n    * @param {undefined|string} presetName - The preset name. If `undefined`, page margins will not be included in the output of `Sheet.toXmls`.\n    * @returns {Sheet} The sheet.\n    */\n\n    /**\n    * Set a new page margins preset by name and attributes object.\n    * @param {string} presetName - The preset name.\n    * @param {object} presetAttributes - The preset attributes.\n    * @returns {Sheet} The sheet.\n    */\n\n  }, {\n    key: \"pageMarginsPreset\",\n    value: function pageMarginsPreset() {\n      var _this19 = this;\n\n      return new ArgHandler('Sheet.pageMarginsPreset').case(function () {\n        return _this19._pageMarginsPresetName;\n      }).case(['nil'], function () {\n        // Remove all preset overrides and exclude from sheet\n        _this19._pageMarginsPresetName = undefined; // Remove all preset overrides\n\n        _this19._pageMarginsNode.attributes = {};\n        return _this19;\n      }).case(['string'], function (presetName) {\n        var checkPresetName = _this19._getCheckAttributeNameHelper('pageMarginsPreset', Object.keys(_this19._pageMarginsPresets));\n\n        checkPresetName(presetName); // Change to new preset\n\n        _this19._pageMarginsPresetName = presetName; // Remove all preset overrides\n\n        _this19._pageMarginsNode.attributes = {};\n        return _this19;\n      }).case(['string', 'object'], function (presetName, presetAttributes) {\n        if (_this19._pageMarginsPresets.hasOwnProperty(presetName)) {\n          throw new Error(\"Sheet.pageMarginsPreset: The preset \".concat(presetName, \" already exists!\"));\n        } // Validate preset attribute keys.\n\n\n        var pageMarginsAttributeNames = ['left', 'right', 'top', 'bottom', 'header', 'footer'];\n\n        var isValidPresetAttributeKeys = _.isEqual(_.sortBy(pageMarginsAttributeNames), _.sortBy(Object.keys(presetAttributes)));\n\n        if (isValidPresetAttributeKeys === false) {\n          throw new Error(\"Sheet.pageMarginsPreset: Invalid preset attributes for one or key(s)! - \\\"\".concat(Object.keys(presetAttributes), \"\\\"\"));\n        } // Validate preset attribute values.\n\n\n        _.forEach(function (attributeValue, attributeName) {\n          var attributeNumberValue = parseFloat(attributeValue);\n\n          if (_.isNaN(attributeNumberValue) || _.isNumber(attributeNumberValue) === false) {\n            throw new Error(\"Sheet.pageMarginsPreset: Invalid preset attribute value! - \\\"\".concat(attributeValue, \"\\\"\"));\n          }\n        }); // Change to new preset\n\n\n        _this19._pageMarginsPresetName = presetName; // Remove all preset overrides\n\n        _this19._pageMarginsNode.attributes = {}; // Register the preset\n\n        _this19._pageMarginsPresets[presetName] = presetAttributes;\n        return _this19;\n      }).handle(arguments);\n    }\n    /**\n     * https://docs.microsoft.com/en-us/dotnet/api/documentformat.openxml.spreadsheet.pane?view=openxml-2.8.1\n     * @typedef {Object} PaneOptions\n     * @property {string} activePane=bottomRight Active Pane. The pane that is active.\n     * @property {string} state Split State. Indicates whether the pane has horizontal / vertical splits,\n     * and whether those splits are frozen.\n     * @property {string} topLeftCell Top Left Visible Cell. Location of the top left visible cell in the bottom\n     * right pane (when in Left-To-Right mode).\n     * @property {number} xSplit (Horizontal Split Position) Horizontal position of the split, in 1/20th of a point;\n     * 0 (zero) if none. If the pane is frozen, this value indicates the number of columns visible in the top pane.\n     * @property {number} ySplit (Vertical Split Position) Vertical position of the split, in 1/20th of a point; 0\n     * (zero) if none. If the pane is frozen, this value indicates the number of rows visible in the left pane.\n     */\n\n    /**\n    * Gets sheet view pane options\n    * @return {PaneOptions} sheet view pane options\n    */\n\n    /**\n    * Sets sheet view pane options\n    * @param {PaneOptions|null|undefined} paneOptions sheet view pane options\n    * @return {Sheet} The sheet\n    */\n\n  }, {\n    key: \"panes\",\n    value: function panes() {\n      var _this20 = this;\n\n      var supportedStates = ['split', 'frozen', 'frozenSplit'];\n      var supportedActivePanes = ['bottomLeft', 'bottomRight', 'topLeft', 'topRight'];\n\n      var checkStateName = this._getCheckAttributeNameHelper('pane.state', supportedStates);\n\n      var checkActivePane = this._getCheckAttributeNameHelper('pane.activePane', supportedActivePanes);\n\n      var sheetViewNode = this._getOrCreateSheetViewNode();\n\n      var paneNode = xmlq.findChild(sheetViewNode, 'pane');\n      return new ArgHandler('Sheet.pane').case(function () {\n        if (paneNode) {\n          var result = _.cloneDeep(paneNode.attributes);\n\n          if (!result.state) result.state = 'split';\n          return result;\n        }\n      }).case(['nil'], function () {\n        xmlq.removeChild(sheetViewNode, 'pane');\n        return _this20;\n      }).case(['object'], function (paneAttributes) {\n        var attributes = _.assign({\n          activePane: 'bottomRight'\n        }, paneAttributes);\n\n        checkStateName(attributes.state);\n        checkActivePane(attributes.activePane);\n\n        if (paneNode) {\n          paneNode.attributes = attributes;\n        } else {\n          paneNode = {\n            name: \"pane\",\n            attributes: attributes,\n            children: []\n          };\n          xmlq.appendChild(sheetViewNode, paneNode);\n        }\n\n        return _this20;\n      }).handle(arguments);\n    }\n    /**\n     * Freezes Panes for this sheet.\n     * @param {number} xSplit the number of columns visible in the top pane. 0 (zero) if none.\n     * @param {number} ySplit the number of rows visible in the left pane. 0 (zero) if none.\n     * @return {Sheet} The sheet\n     */\n\n    /**\n    * freezes Panes for this sheet.\n    * @param {string} topLeftCell Top Left Visible Cell. Location of the top left visible cell in the bottom\n    * right pane (when in Left-To-Right mode).\n    * @return {Sheet} The sheet\n    */\n\n  }, {\n    key: \"freezePanes\",\n    value: function freezePanes() {\n      var _this21 = this;\n\n      return new ArgHandler('Sheet.feezePanes').case(['integer', 'integer'], function (xSplit, ySplit) {\n        var topLeftCell = addressConverter.columnNumberToName(xSplit + 1) + (ySplit + 1);\n        var activePane = xSplit === 0 ? 'bottomLeft' : 'bottomRight';\n        activePane = ySplit === 0 ? 'topRight' : activePane;\n        return _this21.panes({\n          state: 'frozen',\n          topLeftCell: topLeftCell,\n          xSplit: xSplit,\n          ySplit: ySplit,\n          activePane: activePane\n        });\n      }).case(['string'], function (topLeftCell) {\n        var ref = addressConverter.fromAddress(topLeftCell);\n        var xSplit = ref.columnNumber - 1,\n            ySplit = ref.rowNumber - 1;\n        var activePane = xSplit === 0 ? 'bottomLeft' : 'bottomRight';\n        activePane = ySplit === 0 ? 'topRight' : activePane;\n        return _this21.panes({\n          state: 'frozen',\n          topLeftCell: topLeftCell,\n          xSplit: xSplit,\n          ySplit: ySplit,\n          activePane: activePane\n        });\n      }).handle(arguments);\n    }\n    /**\n     * Splits Panes for this sheet.\n     * @param {number} xSplit (Horizontal Split Position) Horizontal position of the split,\n     * in 1/20th of a point; 0 (zero) if none.\n     * @param {number} ySplit (Vertical Split Position) VVertical position of the split,\n     * in 1/20th of a point; 0 (zero) if none.\n     * @return {Sheet} The sheet\n     */\n\n  }, {\n    key: \"splitPanes\",\n    value: function splitPanes(xSplit, ySplit) {\n      return this.panes({\n        state: 'split',\n        xSplit: xSplit,\n        ySplit: ySplit\n      });\n    }\n    /**\n     * resets to default sheet view panes.\n     * @return {Sheet} The sheet\n     */\n\n  }, {\n    key: \"resetPanes\",\n    value: function resetPanes() {\n      return this.panes(null);\n    }\n    /* PRIVATE */\n\n    /**\n     * Get a helper function to check that the attribute name provided is supported.\n     * @param {string} functionName - Name of the parent function.\n     * @param {array} supportedAttributeNames - Array of supported attribute name strings.\n     * @returns {function} The helper function, which takes an attribute name. If the array of supported attribute names does not contain the given attribute name, then an Error is thrown.\n     * @ignore\n     */\n\n  }, {\n    key: \"_getCheckAttributeNameHelper\",\n    value: function _getCheckAttributeNameHelper(functionName, supportedAttributeNames) {\n      return function (attributeName) {\n        if (!_.includes(supportedAttributeNames, attributeName)) {\n          throw new Error(\"Sheet.\".concat(functionName, \": \\\"\").concat(attributeName, \"\\\" is not supported.\"));\n        }\n      };\n    }\n    /**\n     * Get a helper function to check that the value is of the expected type.\n     * @param {string} functionName - Name of the parent function.\n     * @param {string} valueType - A string produced by typeof.\n     * @returns {function} The helper function, which takes a value. If the value type is not expected, a TypeError is thrown.\n     * @ignore\n     */\n\n  }, {\n    key: \"_getCheckTypeHelper\",\n    value: function _getCheckTypeHelper(functionName, valueType) {\n      return function (value) {\n        if (typeof value !== valueType) {\n          throw new TypeError(\"Sheet.\".concat(functionName, \": invalid type - value must be of type \").concat(valueType, \".\"));\n        }\n      };\n    }\n    /**\n     * Get a helper function to check that the value is within the expected range.\n     * @param {string} functionName - Name of the parent function.\n     * @param {undefined|number} valueMin - The minimum value of the range. This value is range-inclusive.\n     * @param {undefined|number} valueMax - The maximum value of the range. This value is range-exclusive.\n     * @returns {function} The helper function, which takes a value. If the value type is not 'number', a TypeError is thrown. If the value is not within the range, a RangeError is thrown.\n     * @ignore\n     */\n\n  }, {\n    key: \"_getCheckRangeHelper\",\n    value: function _getCheckRangeHelper(functionName, valueMin, valueMax) {\n      var checkType = this._getCheckTypeHelper(functionName, 'number');\n\n      return function (value) {\n        checkType(value);\n\n        if (valueMin !== undefined) {\n          if (value < valueMin) {\n            throw new RangeError(\"Sheet.\".concat(functionName, \": value too small - value must be greater than or equal to \").concat(valueMin, \".\"));\n          }\n        }\n\n        if (valueMax !== undefined) {\n          if (valueMax <= value) {\n            throw new RangeError(\"Sheet.\".concat(functionName, \": value too large - value must be less than \").concat(valueMax, \".\"));\n          }\n        }\n      };\n    }\n    /**\n     * Get the sheet view node if it exists or create it if it doesn't.\n     * @returns {{}} The sheet view node.\n     * @private\n     */\n\n  }, {\n    key: \"_getOrCreateSheetViewNode\",\n    value: function _getOrCreateSheetViewNode() {\n      var sheetViewsNode = xmlq.findChild(this._node, \"sheetViews\");\n\n      if (!sheetViewsNode) {\n        sheetViewsNode = {\n          name: \"sheetViews\",\n          attributes: {},\n          children: [{\n            name: \"sheetView\",\n            attributes: {\n              workbookViewId: 0\n            },\n            children: []\n          }]\n        };\n        xmlq.insertInOrder(this._node, sheetViewsNode, nodeOrder);\n      }\n\n      return xmlq.findChild(sheetViewsNode, \"sheetView\");\n    }\n    /**\n     * Initializes the sheet.\n     * @param {Workbook} workbook - The parent workbook.\n     * @param {{}} idNode - The sheet ID node (from the parent workbook).\n     * @param {{}} node - The sheet node.\n     * @param {{}} [relationshipsNode] - The optional sheet relationships node.\n     * @returns {undefined}\n     * @private\n     */\n\n  }, {\n    key: \"_init\",\n    value: function _init(workbook, idNode, node, relationshipsNode) {\n      var _this22 = this;\n\n      if (!node) {\n        node = {\n          name: \"worksheet\",\n          attributes: {\n            xmlns: \"http://schemas.openxmlformats.org/spreadsheetml/2006/main\",\n            'xmlns:r': \"http://schemas.openxmlformats.org/officeDocument/2006/relationships\",\n            'xmlns:mc': \"http://schemas.openxmlformats.org/markup-compatibility/2006\",\n            'mc:Ignorable': \"x14ac\",\n            'xmlns:x14ac': \"http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac\"\n          },\n          children: [{\n            name: \"sheetData\",\n            attributes: {},\n            children: []\n          }]\n        };\n      }\n\n      this._workbook = workbook;\n      this._idNode = idNode;\n      this._node = node;\n      this._maxSharedFormulaId = -1;\n      this._mergeCells = {};\n      this._dataValidations = {};\n      this._hyperlinks = {};\n      this._autoFilter = null; // Create the relationships.\n\n      this._relationships = new Relationships(relationshipsNode); // Delete the optional dimension node\n\n      xmlq.removeChild(this._node, \"dimension\"); // Create the rows.\n\n      this._rows = [];\n      this._sheetDataNode = xmlq.findChild(this._node, \"sheetData\");\n\n      this._sheetDataNode.children.forEach(function (rowNode) {\n        var row = new Row(_this22, rowNode);\n        _this22._rows[row.rowNumber()] = row;\n      });\n\n      this._sheetDataNode.children = this._rows; // Create the columns node.\n\n      this._columns = [];\n      this._colsNode = xmlq.findChild(this._node, \"cols\");\n\n      if (this._colsNode) {\n        xmlq.removeChild(this._node, this._colsNode);\n      } else {\n        this._colsNode = {\n          name: 'cols',\n          attributes: {},\n          children: []\n        };\n      } // Cache the col nodes.\n\n\n      this._colNodes = [];\n\n      _.forEach(this._colsNode.children, function (colNode) {\n        var min = colNode.attributes.min;\n        var max = colNode.attributes.max;\n\n        for (var i = min; i <= max; i++) {\n          _this22._colNodes[i] = colNode;\n        }\n      }); // Create the sheet properties node.\n\n\n      this._sheetPrNode = xmlq.findChild(this._node, \"sheetPr\");\n\n      if (!this._sheetPrNode) {\n        this._sheetPrNode = {\n          name: 'sheetPr',\n          attributes: {},\n          children: []\n        };\n        xmlq.insertInOrder(this._node, this._sheetPrNode, nodeOrder);\n      } // Create the merge cells.\n\n\n      this._mergeCellsNode = xmlq.findChild(this._node, \"mergeCells\");\n\n      if (this._mergeCellsNode) {\n        xmlq.removeChild(this._node, this._mergeCellsNode);\n      } else {\n        this._mergeCellsNode = {\n          name: 'mergeCells',\n          attributes: {},\n          children: []\n        };\n      }\n\n      var mergeCellNodes = this._mergeCellsNode.children;\n      this._mergeCellsNode.children = [];\n      mergeCellNodes.forEach(function (mergeCellNode) {\n        _this22._mergeCells[mergeCellNode.attributes.ref] = mergeCellNode;\n      }); // Create the DataValidations.\n\n      this._dataValidationsNode = xmlq.findChild(this._node, \"dataValidations\");\n\n      if (this._dataValidationsNode) {\n        xmlq.removeChild(this._node, this._dataValidationsNode);\n      } else {\n        this._dataValidationsNode = {\n          name: 'dataValidations',\n          attributes: {},\n          children: []\n        };\n      }\n\n      var dataValidationNodes = this._dataValidationsNode.children;\n      this._dataValidationsNode.children = [];\n      dataValidationNodes.forEach(function (dataValidationNode) {\n        _this22._dataValidations[dataValidationNode.attributes.sqref] = dataValidationNode;\n      }); // Create the hyperlinks.\n\n      this._hyperlinksNode = xmlq.findChild(this._node, \"hyperlinks\");\n\n      if (this._hyperlinksNode) {\n        xmlq.removeChild(this._node, this._hyperlinksNode);\n      } else {\n        this._hyperlinksNode = {\n          name: 'hyperlinks',\n          attributes: {},\n          children: []\n        };\n      }\n\n      var hyperlinkNodes = this._hyperlinksNode.children;\n      this._hyperlinksNode.children = [];\n      hyperlinkNodes.forEach(function (hyperlinkNode) {\n        _this22._hyperlinks[hyperlinkNode.attributes.ref] = hyperlinkNode;\n      }); // Create the printOptions.\n\n      this._printOptionsNode = xmlq.findChild(this._node, \"printOptions\");\n\n      if (this._printOptionsNode) {\n        xmlq.removeChild(this._node, this._printOptionsNode);\n      } else {\n        this._printOptionsNode = {\n          name: 'printOptions',\n          attributes: {},\n          children: []\n        };\n      } // Create the pageMargins.\n\n\n      this._pageMarginsPresets = {\n        normal: {\n          left: 0.7,\n          right: 0.7,\n          top: 0.75,\n          bottom: 0.75,\n          header: 0.3,\n          footer: 0.3\n        },\n        wide: {\n          left: 1,\n          right: 1,\n          top: 1,\n          bottom: 1,\n          header: 0.5,\n          footer: 0.5\n        },\n        narrow: {\n          left: 0.25,\n          right: 0.25,\n          top: 0.75,\n          bottom: 0.75,\n          header: 0.3,\n          footer: 0.3\n        }\n      };\n      this._pageMarginsNode = xmlq.findChild(this._node, \"pageMargins\");\n\n      if (this._pageMarginsNode) {\n        // Sheet has page margins, assume preset is template.\n        this._pageMarginsPresetName = 'template'; // Search for a preset that matches existing attributes.\n\n        for (var presetName in this._pageMarginsPresets) {\n          if (_.isEqual(this._pageMarginsNode.attributes, this._pageMarginsPresets[presetName])) {\n            this._pageMarginsPresetName = presetName;\n            break;\n          }\n        } // If template preset, then register as template preset, and clear attributes.\n\n\n        if (this._pageMarginsPresetName === 'template') {\n          this._pageMarginsPresets.template = this._pageMarginsNode.attributes;\n          this._pageMarginsNode.attributes = {};\n        }\n\n        xmlq.removeChild(this._node, this._pageMarginsNode);\n      } else {\n        // Sheet has no page margins, the preset assignment is therefore undefined.\n        this._pageMarginsPresetName = undefined;\n        this._pageMarginsNode = {\n          name: 'pageMargins',\n          attributes: {},\n          children: []\n        };\n      } // Create the pageBreaks\n\n\n      ['colBreaks', 'rowBreaks'].forEach(function (name) {\n        _this22[\"_\".concat(name, \"Node\")] = xmlq.findChild(_this22._node, name);\n\n        if (_this22[\"_\".concat(name, \"Node\")]) {\n          xmlq.removeChild(_this22._node, _this22[\"_\".concat(name, \"Node\")]);\n        } else {\n          _this22[\"_\".concat(name, \"Node\")] = {\n            name: name,\n            children: [],\n            attributes: {\n              count: 0,\n              manualBreakCount: 0\n            }\n          };\n        }\n      });\n      this._pageBreaks = {\n        colBreaks: new PageBreaks(this._colBreaksNode),\n        rowBreaks: new PageBreaks(this._rowBreaksNode)\n      };\n    }\n  }]);\n\n  return Sheet;\n}();\n\nmodule.exports = Sheet;\n/*\nxl/workbook.xml\n\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<worksheet ...>\n    ...\n\n    <printOptions headings=\"1\" gridLines=\"1\" />\n    <pageMargins left=\"0.7\" right=\"0.7\" top=\"0.75\" bottom=\"0.75\" header=\"0.3\" footer=\"0.3\" />\n    <pageSetup orientation=\"portrait\" horizontalDpi=\"0\" verticalDpi=\"0\" />\n</worksheet>\n// */","map":{"version":3,"sources":["C:/Users/tzika/Desktop/Polymerlink-Front/polymerlink-2/node_modules/xlsx-populate/lib/Sheet.js"],"names":["_","require","Cell","Row","Column","Range","Relationships","xmlq","regexify","addressConverter","ArgHandler","colorIndexes","PageBreaks","nodeOrder","Sheet","workbook","idNode","node","relationshipsNode","_init","case","activeSheet","active","Error","handle","arguments","sheetViewNode","_getOrCreateSheetViewNode","selectionNode","findChild","cellAddress","attributes","activeCell","cell","rowNumber","columnNameOrNumber","name","children","appendChild","sqref","address","ref","fromAddress","type","row","columnNumber","columnNameToNumber","_columns","existingColNode","_colNodes","colNode","min","beforeColNode","cloneDeep","max","i","afterColNode","column","scopedDefinedName","refersTo","deleteSheet","pattern","replacement","matches","_rows","forEach","concat","find","showGridLines","undefined","visible","_idNode","state","hidden","visibleSheets","filter","sheets","sheet","length","activeIndex","indexOrBeforeSheet","moveSheet","range","startRowNumber","startColumnNumber","endRowNumber","endColumnNumber","startCell","endCell","startColumnNameOrNumber","endColumnNameOrNumber","_autoFilter","RangeError","rowNode","r","tabColorNode","_sheetPrNode","color","hasOwnProperty","rgb","theme","indexed","tint","tabColor","removeChild","appendChildIfNotFound","setAttributes","toUpperCase","tabSelected","selected","rightToLeft","rtl","minRowNumber","findIndex","maxRowNumber","minColumnNumber","maxColumnNumber","minUsedColumnNumber","maxUsedColumnNumber","_workbook","_pageBreaks","colBreaks","rowBreaks","sharedFormulaId","clearCellsUsingSharedFormula","style","callback","hyperlinkNode","_hyperlinks","relationship","_relationships","findById","Target","hyperlink","internal","isHyperlinkInternalAddress","nodeAttributes","location","display","add","Id","opts","includeSheetName","email","subject","emailSubject","encodeURI","tooltip","_maxSharedFormulaId","_mergeCells","merge","_dataValidations","allowBlank","showInputMessage","prompt","promptTitle","showErrorMessage","error","errorTitle","operator","formula1","formula2","obj","atrributes","clone","_node","slice","_colsNode","Object","keys","insertInOrder","_hyperlinksNode","values","_printOptionsNode","_pageMarginsNode","_pageMarginsPresetName","childNode","assign","_pageMarginsPresets","_mergeCellsNode","_dataValidationsNode","breaks","count","id","relationships","supportedAttributeNames","checkAttributeName","_getCheckAttributeNameHelper","attributeName","attributeEnabled","printOptions","enabled","pageMarginsPreset","checkRange","_getCheckRangeHelper","attributeValue","parseFloat","attributeNumberValue","attributeStringValue","pageMargins","presetName","checkPresetName","presetAttributes","pageMarginsAttributeNames","isValidPresetAttributeKeys","isEqual","sortBy","isNaN","isNumber","supportedStates","supportedActivePanes","checkStateName","checkActivePane","paneNode","result","paneAttributes","activePane","xSplit","ySplit","topLeftCell","columnNumberToName","panes","functionName","includes","valueType","value","TypeError","valueMin","valueMax","checkType","_getCheckTypeHelper","sheetViewsNode","workbookViewId","xmlns","_sheetDataNode","mergeCellNodes","mergeCellNode","dataValidationNodes","dataValidationNode","hyperlinkNodes","normal","left","right","top","bottom","header","footer","wide","narrow","template","manualBreakCount","_colBreaksNode","_rowBreaksNode","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst _ = require(\"lodash\");\nconst Cell = require(\"./Cell\");\nconst Row = require(\"./Row\");\nconst Column = require(\"./Column\");\nconst Range = require(\"./Range\");\nconst Relationships = require(\"./Relationships\");\nconst xmlq = require(\"./xmlq\");\nconst regexify = require(\"./regexify\");\nconst addressConverter = require(\"./addressConverter\");\nconst ArgHandler = require(\"./ArgHandler\");\nconst colorIndexes = require(\"./colorIndexes\");\nconst PageBreaks = require(\"./PageBreaks\");\n\n// Order of the nodes as defined by the spec.\nconst nodeOrder = [\n    \"sheetPr\", \"dimension\", \"sheetViews\", \"sheetFormatPr\", \"cols\", \"sheetData\",\n    \"sheetCalcPr\", \"sheetProtection\", \"autoFilter\", \"protectedRanges\", \"scenarios\", \"autoFilter\",\n    \"sortState\", \"dataConsolidate\", \"customSheetViews\", \"mergeCells\", \"phoneticPr\",\n    \"conditionalFormatting\", \"dataValidations\", \"hyperlinks\", \"printOptions\",\n    \"pageMargins\", \"pageSetup\", \"headerFooter\", \"rowBreaks\", \"colBreaks\",\n    \"customProperties\", \"cellWatches\", \"ignoredErrors\", \"smartTags\", \"drawing\",\n    \"drawingHF\", \"legacyDrawing\", \"legacyDrawingHF\", \"picture\", \"oleObjects\", \"controls\", \"webPublishItems\", \"tableParts\",\n    \"extLst\"\n];\n\n/**\n * A worksheet.\n */\nclass Sheet {\n    // /**\n    //  * Creates a new instance of Sheet.\n    //  * @param {Workbook} workbook - The parent workbook.\n    //  * @param {{}} idNode - The sheet ID node (from the parent workbook).\n    //  * @param {{}} node - The sheet node.\n    //  * @param {{}} [relationshipsNode] - The optional sheet relationships node.\n    //  */\n    constructor(workbook, idNode, node, relationshipsNode) {\n        this._init(workbook, idNode, node, relationshipsNode);\n    }\n\n    /* PUBLIC */\n\n    /**\n     * Gets a value indicating whether the sheet is the active sheet in the workbook.\n     * @returns {boolean} True if active, false otherwise.\n     *//**\n     * Make the sheet the active sheet in the workkbok.\n     * @param {boolean} active - Must be set to `true`. Deactivating directly is not supported. To deactivate, you should activate a different sheet instead.\n     * @returns {Sheet} The sheet.\n     */\n    active() {\n        return new ArgHandler('Sheet.active')\n            .case(() => {\n                return this.workbook().activeSheet() === this;\n            })\n            .case('boolean', active => {\n                if (!active) throw new Error(\"Deactivating sheet directly not supported. Activate a different sheet instead.\");\n                this.workbook().activeSheet(this);\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Get the active cell in the sheet.\n     * @returns {Cell} The active cell.\n     *//**\n     * Set the active cell in the workbook.\n     * @param {string|Cell} cell - The cell or address of cell to activate.\n     * @returns {Sheet} The sheet.\n     *//**\n     * Set the active cell in the workbook by row and column.\n     * @param {number} rowNumber - The row number of the cell.\n     * @param {string|number} columnNameOrNumber - The column name or number of the cell.\n     * @returns {Sheet} The sheet.\n     */\n    activeCell() {\n        const sheetViewNode = this._getOrCreateSheetViewNode();\n        let selectionNode = xmlq.findChild(sheetViewNode, \"selection\");\n        return new ArgHandler('Sheet.activeCell')\n            .case(() => {\n                const cellAddress = selectionNode ? selectionNode.attributes.activeCell : \"A1\";\n                return this.cell(cellAddress);\n            })\n            .case(['number', '*'], (rowNumber, columnNameOrNumber) => {\n                const cell = this.cell(rowNumber, columnNameOrNumber);\n                return this.activeCell(cell);\n            })\n            .case('*', cell => {\n                if (!selectionNode) {\n                    selectionNode = {\n                        name: \"selection\",\n                        attributes: {},\n                        children: []\n                    };\n\n                    xmlq.appendChild(sheetViewNode, selectionNode);\n                }\n\n                if (!(cell instanceof Cell)) cell = this.cell(cell);\n                selectionNode.attributes.activeCell = selectionNode.attributes.sqref = cell.address();\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Gets the cell with the given address.\n     * @param {string} address - The address of the cell.\n     * @returns {Cell} The cell.\n     *//**\n     * Gets the cell with the given row and column numbers.\n     * @param {number} rowNumber - The row number of the cell.\n     * @param {string|number} columnNameOrNumber - The column name or number of the cell.\n     * @returns {Cell} The cell.\n     */\n    cell() {\n        return new ArgHandler('Sheet.cell')\n            .case('string', address => {\n                const ref = addressConverter.fromAddress(address);\n                if (ref.type !== 'cell') throw new Error('Sheet.cell: Invalid address.');\n                return this.row(ref.rowNumber).cell(ref.columnNumber);\n            })\n            .case(['number', '*'], (rowNumber, columnNameOrNumber) => {\n                return this.row(rowNumber).cell(columnNameOrNumber);\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Gets a column in the sheet.\n     * @param {string|number} columnNameOrNumber - The name or number of the column.\n     * @returns {Column} The column.\n     */\n    column(columnNameOrNumber) {\n        const columnNumber = typeof columnNameOrNumber === \"string\" ? addressConverter.columnNameToNumber(columnNameOrNumber) : columnNameOrNumber;\n\n        // If we're already created a column for this column number, return it.\n        if (this._columns[columnNumber]) return this._columns[columnNumber];\n\n        // We need to create a new column, which requires a backing col node. There may already exist a node whose min/max cover our column.\n        // First, see if there is an existing col node.\n        const existingColNode = this._colNodes[columnNumber];\n\n        let colNode;\n        if (existingColNode) {\n            // If the existing node covered earlier columns than the new one, we need to have a col node to cover the min up to our new node.\n            if (existingColNode.attributes.min < columnNumber) {\n                // Clone the node and set the max to the column before our new col.\n                const beforeColNode = _.cloneDeep(existingColNode);\n                beforeColNode.attributes.max = columnNumber - 1;\n\n                // Update the col nodes cache.\n                for (let i = beforeColNode.attributes.min; i <= beforeColNode.attributes.max; i++) {\n                    this._colNodes[i] = beforeColNode;\n                }\n            }\n\n            // Make a clone for the new column. Set the min/max to the column number and cache it.\n            colNode = _.cloneDeep(existingColNode);\n            colNode.attributes.min = columnNumber;\n            colNode.attributes.max = columnNumber;\n            this._colNodes[columnNumber] = colNode;\n\n            // If the max of the existing node is greater than the nre one, create a col node for that too.\n            if (existingColNode.attributes.max > columnNumber) {\n                const afterColNode = _.cloneDeep(existingColNode);\n                afterColNode.attributes.min = columnNumber + 1;\n                for (let i = afterColNode.attributes.min; i <= afterColNode.attributes.max; i++) {\n                    this._colNodes[i] = afterColNode;\n                }\n            }\n        } else {\n            // The was no existing node so create a new one.\n            colNode = {\n                name: 'col',\n                attributes: {\n                    min: columnNumber,\n                    max: columnNumber\n                },\n                children: []\n            };\n\n            this._colNodes[columnNumber] = colNode;\n        }\n\n        // Create the new column and cache it.\n        const column = new Column(this, colNode);\n        this._columns[columnNumber] = column;\n        return column;\n    }\n\n    /**\n     * Gets a defined name scoped to the sheet.\n     * @param {string} name - The defined name.\n     * @returns {undefined|string|Cell|Range|Row|Column} What the defined name refers to or undefined if not found. Will return the string formula if not a Row, Column, Cell, or Range.\n     *//**\n     * Set a defined name scoped to the sheet.\n     * @param {string} name - The defined name.\n     * @param {string|Cell|Range|Row|Column} refersTo - What the name refers to.\n     * @returns {Workbook} The workbook.\n     */\n    definedName() {\n        return new ArgHandler(\"Workbook.definedName\")\n            .case('string', name => {\n                return this.workbook().scopedDefinedName(this, name);\n            })\n            .case(['string', '*'], (name, refersTo) => {\n                this.workbook().scopedDefinedName(this, name, refersTo);\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Deletes the sheet and returns the parent workbook.\n     * @returns {Workbook} The workbook.\n     */\n    delete() {\n        this.workbook().deleteSheet(this);\n        return this.workbook();\n    }\n\n    /**\n     * Find the given pattern in the sheet and optionally replace it.\n     * @param {string|RegExp} pattern - The pattern to look for. Providing a string will result in a case-insensitive substring search. Use a RegExp for more sophisticated searches.\n     * @param {string|function} [replacement] - The text to replace or a String.replace callback function. If pattern is a string, all occurrences of the pattern in each cell will be replaced.\n     * @returns {Array.<Cell>} The matching cells.\n     */\n    find(pattern, replacement) {\n        pattern = regexify(pattern);\n\n        let matches = [];\n        this._rows.forEach(row => {\n            if (!row) return;\n            matches = matches.concat(row.find(pattern, replacement));\n        });\n\n        return matches;\n    }\n\n    /**\n     * Gets a value indicating whether this sheet's grid lines are visible.\n     * @returns {boolean} True if selected, false if not.\n     *//**\n     * Sets whether this sheet's grid lines are visible.\n     * @param {boolean} selected - True to make visible, false to hide.\n     * @returns {Sheet} The sheet.\n     */\n    gridLinesVisible() {\n        const sheetViewNode = this._getOrCreateSheetViewNode();\n        return new ArgHandler('Sheet.gridLinesVisible')\n            .case(() => {\n                return sheetViewNode.attributes.showGridLines === 1 || sheetViewNode.attributes.showGridLines === undefined;\n            })\n            .case('boolean', visible => {\n                sheetViewNode.attributes.showGridLines = visible ? 1 : 0;\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Gets a value indicating if the sheet is hidden or not.\n     * @returns {boolean|string} True if hidden, false if visible, and 'very' if very hidden.\n     *//**\n     * Set whether the sheet is hidden or not.\n     * @param {boolean|string} hidden - True to hide, false to show, and 'very' to make very hidden.\n     * @returns {Sheet} The sheet.\n     */\n    hidden() {\n        return new ArgHandler('Sheet.hidden')\n            .case(() => {\n                if (this._idNode.attributes.state === 'hidden') return true;\n                if (this._idNode.attributes.state === 'veryHidden') return \"very\";\n                return false;\n            })\n            .case('*', hidden => {\n                if (hidden) {\n                    const visibleSheets = _.filter(this.workbook().sheets(), sheet => !sheet.hidden());\n                    if (visibleSheets.length === 1 && visibleSheets[0] === this) {\n                        throw new Error(\"This sheet may not be hidden as a workbook must contain at least one visible sheet.\");\n                    }\n\n                    // If activate, activate the first other visible sheet.\n                    if (this.active()) {\n                        const activeIndex = visibleSheets[0] === this ? 1 : 0;\n                        visibleSheets[activeIndex].active(true);\n                    }\n                }\n\n                if (hidden === 'very') this._idNode.attributes.state = 'veryHidden';\n                else if (hidden) this._idNode.attributes.state = 'hidden';\n                else delete this._idNode.attributes.state;\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Move the sheet.\n     * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.\n     * @returns {Sheet} The sheet.\n     */\n    move(indexOrBeforeSheet) {\n        this.workbook().moveSheet(this, indexOrBeforeSheet);\n        return this;\n    }\n\n    /**\n     * Get the name of the sheet.\n     * @returns {string} The sheet name.\n     *//**\n     * Set the name of the sheet. *Note: this method does not rename references to the sheet so formulas, etc. can be broken. Use with caution!*\n     * @param {string} name - The name to set to the sheet.\n     * @returns {Sheet} The sheet.\n     */\n    name() {\n        return new ArgHandler('Sheet.name')\n            .case(() => {\n                return `${this._idNode.attributes.name}`;\n            })\n            .case('string', name => {\n                this._idNode.attributes.name = name;\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Gets a range from the given range address.\n     * @param {string} address - The range address (e.g. 'A1:B3').\n     * @returns {Range} The range.\n     *//**\n     * Gets a range from the given cells or cell addresses.\n     * @param {string|Cell} startCell - The starting cell or cell address (e.g. 'A1').\n     * @param {string|Cell} endCell - The ending cell or cell address (e.g. 'B3').\n     * @returns {Range} The range.\n     *//**\n     * Gets a range from the given row numbers and column names or numbers.\n     * @param {number} startRowNumber - The starting cell row number.\n     * @param {string|number} startColumnNameOrNumber - The starting cell column name or number.\n     * @param {number} endRowNumber - The ending cell row number.\n     * @param {string|number} endColumnNameOrNumber - The ending cell column name or number.\n     * @returns {Range} The range.\n     */\n    range() {\n        return new ArgHandler('Sheet.range')\n            .case('string', address => {\n                const ref = addressConverter.fromAddress(address);\n                if (ref.type !== 'range') throw new Error('Sheet.range: Invalid address');\n                return this.range(ref.startRowNumber, ref.startColumnNumber, ref.endRowNumber, ref.endColumnNumber);\n            })\n            .case(['*', '*'], (startCell, endCell) => {\n                if (typeof startCell === \"string\") startCell = this.cell(startCell);\n                if (typeof endCell === \"string\") endCell = this.cell(endCell);\n                return new Range(startCell, endCell);\n            })\n            .case(['number', '*', 'number', '*'], (startRowNumber, startColumnNameOrNumber, endRowNumber, endColumnNameOrNumber) => {\n                return this.range(this.cell(startRowNumber, startColumnNameOrNumber), this.cell(endRowNumber, endColumnNameOrNumber));\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Unsets sheet autoFilter.\n     * @returns {Sheet} This sheet.\n     *//**\n     * Sets sheet autoFilter to a Range.\n     * @param {Range} range - The autoFilter range.\n     * @returns {Sheet} This sheet.\n     */\n    autoFilter(range) {\n        this._autoFilter = range;\n\n        return this;\n    }\n\n    /**\n     * Gets the row with the given number.\n     * @param {number} rowNumber - The row number.\n     * @returns {Row} The row with the given number.\n     */\n    row(rowNumber) {\n        if (rowNumber < 1) throw new RangeError(`Invalid row number ${rowNumber}. Remember that spreadsheets use 1-based indexing.`);\n\n        if (this._rows[rowNumber]) return this._rows[rowNumber];\n\n        const rowNode = {\n            name: 'row',\n            attributes: {\n                r: rowNumber\n            },\n            children: []\n        };\n\n        const row = new Row(this, rowNode);\n        this._rows[rowNumber] = row;\n        return row;\n    }\n\n    /**\n     * Get the tab color. (See style [Color](#color).)\n     * @returns {undefined|Color} The color or undefined if not set.\n     *//**\n     * Sets the tab color. (See style [Color](#color).)\n     * @returns {Color|string|number} color - Color of the tab. If string, will set an RGB color. If number, will set a theme color.\n     */\n    tabColor() {\n        return new ArgHandler(\"Sheet.tabColor\")\n            .case(() => {\n                const tabColorNode = xmlq.findChild(this._sheetPrNode, \"tabColor\");\n                if (!tabColorNode) return;\n\n                const color = {};\n                if (tabColorNode.attributes.hasOwnProperty('rgb')) color.rgb = tabColorNode.attributes.rgb;\n                else if (tabColorNode.attributes.hasOwnProperty('theme')) color.theme = tabColorNode.attributes.theme;\n                else if (tabColorNode.attributes.hasOwnProperty('indexed')) color.rgb = colorIndexes[tabColorNode.attributes.indexed];\n\n                if (tabColorNode.attributes.hasOwnProperty('tint')) color.tint = tabColorNode.attributes.tint;\n\n                return color;\n            })\n            .case(\"string\", rgb => this.tabColor({ rgb }))\n            .case(\"integer\", theme => this.tabColor({ theme }))\n            .case(\"nil\", () => {\n                xmlq.removeChild(this._sheetPrNode, \"tabColor\");\n                return this;\n            })\n            .case(\"object\", color => {\n                const tabColorNode = xmlq.appendChildIfNotFound(this._sheetPrNode, \"tabColor\");\n                xmlq.setAttributes(tabColorNode, {\n                    rgb: color.rgb && color.rgb.toUpperCase(),\n                    indexed: null,\n                    theme: color.theme,\n                    tint: color.tint\n                });\n\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Gets a value indicating whether this sheet is selected.\n     * @returns {boolean} True if selected, false if not.\n     *//**\n     * Sets whether this sheet is selected.\n     * @param {boolean} selected - True to select, false to deselected.\n     * @returns {Sheet} The sheet.\n     */\n    tabSelected() {\n        const sheetViewNode = this._getOrCreateSheetViewNode();\n        return new ArgHandler('Sheet.tabSelected')\n            .case(() => {\n                return sheetViewNode.attributes.tabSelected === 1;\n            })\n            .case('boolean', selected => {\n                if (selected) sheetViewNode.attributes.tabSelected = 1;\n                else delete sheetViewNode.attributes.tabSelected;\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Gets a value indicating whether this sheet is rtl (Right To Left).\n     * @returns {boolean} True if rtl, false if ltr.\n     *//**\n     * Sets whether this sheet is rtl.\n     * @param {boolean} rtl - True to rtl, false to ltr (Left To Right).\n     * @returns {Sheet} The sheet.\n     */\n    rightToLeft() {\n        const sheetViewNode = this._getOrCreateSheetViewNode();\n        return new ArgHandler('Sheet.rightToLeft')\n            .case(() => {\n                return sheetViewNode.attributes.rightToLeft;\n            })\n            .case('boolean', rtl => {\n                if (rtl) sheetViewNode.attributes.rightToLeft = true;\n                else delete sheetViewNode.attributes.rightToLeft;\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Get the range of cells in the sheet that have contained a value or style at any point. Useful for extracting the entire sheet contents.\n     * @returns {Range|undefined} The used range or undefined if no cells in the sheet are used.\n     */\n    usedRange() {\n        const minRowNumber = _.findIndex(this._rows);\n        const maxRowNumber = this._rows.length - 1;\n\n        let minColumnNumber = 0;\n        let maxColumnNumber = 0;\n        for (let i = 0; i < this._rows.length; i++) {\n            const row = this._rows[i];\n            if (!row) continue;\n\n            const minUsedColumnNumber = row.minUsedColumnNumber();\n            const maxUsedColumnNumber = row.maxUsedColumnNumber();\n            if (minUsedColumnNumber > 0 && (!minColumnNumber || minUsedColumnNumber < minColumnNumber)) minColumnNumber = minUsedColumnNumber;\n            if (maxUsedColumnNumber > 0 && (!maxColumnNumber || maxUsedColumnNumber > maxColumnNumber)) maxColumnNumber = maxUsedColumnNumber;\n        }\n\n        // Return undefined if nothing in the sheet is used.\n        if (minRowNumber <= 0 || minColumnNumber <= 0 || maxRowNumber <= 0 || maxColumnNumber <= 0) return;\n\n        return this.range(minRowNumber, minColumnNumber, maxRowNumber, maxColumnNumber);\n    }\n\n    /**\n     * Gets the parent workbook.\n     * @returns {Workbook} The parent workbook.\n     */\n    workbook() {\n        return this._workbook;\n    }\n\n    /**\n     * Gets all page breaks.\n     * @returns {{}} the object holds both vertical and horizontal PageBreaks.\n     */\n    pageBreaks() {\n        return this._pageBreaks;\n    }\n\n    /**\n     * Gets the vertical page breaks.\n     * @returns {PageBreaks} vertical PageBreaks.\n     */\n    verticalPageBreaks() {\n        return this._pageBreaks.colBreaks;\n    }\n\n    /**\n     * Gets the horizontal page breaks.\n     * @returns {PageBreaks} horizontal PageBreaks.\n     */\n    horizontalPageBreaks() {\n        return this._pageBreaks.rowBreaks;\n    }\n\n    /* INTERNAL */\n\n    /**\n     * Clear cells that are using a given shared formula ID.\n     * @param {number} sharedFormulaId - The shared formula ID.\n     * @returns {undefined}\n     * @ignore\n     */\n    clearCellsUsingSharedFormula(sharedFormulaId) {\n        this._rows.forEach(row => {\n            if (!row) return;\n            row.clearCellsUsingSharedFormula(sharedFormulaId);\n        });\n    }\n\n    /**\n     * Get an existing column style ID.\n     * @param {number} columnNumber - The column number.\n     * @returns {undefined|number} The style ID.\n     * @ignore\n     */\n    existingColumnStyleId(columnNumber) {\n        // This will work after setting Column.style because Column updates the attributes live.\n        const colNode = this._colNodes[columnNumber];\n        return colNode && colNode.attributes.style;\n    }\n\n    /**\n     * Call a callback for each column number that has a node defined for it.\n     * @param {Function} callback - The callback.\n     * @returns {undefined}\n     * @ignore\n     */\n    forEachExistingColumnNumber(callback) {\n        _.forEach(this._colNodes, (node, columnNumber) => {\n            if (!node) return;\n            callback(columnNumber);\n        });\n    }\n\n    /**\n     * Call a callback for each existing row.\n     * @param {Function} callback - The callback.\n     * @returns {undefined}\n     * @ignore\n     */\n    forEachExistingRow(callback) {\n        _.forEach(this._rows, (row, rowNumber) => {\n            if (row) callback(row, rowNumber);\n        });\n\n        return this;\n    }\n\n    /**\n     * Get the hyperlink attached to the cell with the given address.\n     * @param {string} address - The address of the hyperlinked cell.\n     * @returns {string|undefined} The hyperlink or undefined if not set.\n     *//**\n     * Set the hyperlink on the cell with the given address.\n     * @param {string} address - The address of the hyperlinked cell.\n     * @param {string} hyperlink - The hyperlink to set or undefined to clear.\n     * @param {boolean} [internal] - The flag to force hyperlink to be internal. If true, then autodetect is skipped.\n     * @returns {Sheet} The sheet.\n     *//**\n     * Set the hyperlink on the cell with the given address. If opts is a Cell an internal hyperlink is added.\n     * @param {string} address - The address of the hyperlinked cell.\n     * @param {object|Cell} opts - Options.\n     * @returns {Sheet} The sheet.\n     * @ignore\n     *//**\n     * Set the hyperlink on the cell with the given address and options.\n     * @param {string} address - The address of the hyperlinked cell.\n     * @param {{}|Cell} opts - Options or Cell. If opts is a Cell then an internal hyperlink is added.\n     * @param {string|Cell} [opts.hyperlink] - The hyperlink to set, can be a Cell or an internal/external string.\n     * @param {string} [opts.tooltip] - Additional text to help the user understand more about the hyperlink.\n     * @param {string} [opts.email] - Email address, ignored if opts.hyperlink is set.\n     * @param {string} [opts.emailSubject] - Email subject, ignored if opts.hyperlink is set.\n     * @returns {Sheet} The sheet.\n     */\n    hyperlink() {\n        return new ArgHandler('Sheet.hyperlink')\n            .case('string', address => {\n                const hyperlinkNode = this._hyperlinks[address];\n                if (!hyperlinkNode) return;\n                const relationship = this._relationships.findById(hyperlinkNode.attributes['r:id']);\n                return relationship && relationship.attributes.Target;\n            })\n            .case(['string', 'nil'], address => {\n                // TODO: delete relationship\n                delete this._hyperlinks[address];\n                return this;\n            })\n            .case(['string', 'string'], (address, hyperlink) => {\n                return this.hyperlink(address, hyperlink, false);\n            })\n            .case(['string', 'string', 'boolean'], (address, hyperlink, internal) => {\n                const isHyperlinkInternalAddress = internal || addressConverter.fromAddress(hyperlink);\n                let nodeAttributes;\n                if (isHyperlinkInternalAddress) {\n                    nodeAttributes = {\n                        ref: address,\n                        location: hyperlink,\n                        display: hyperlink\n                    };\n                } else {\n                    const relationship = this._relationships.add(\"hyperlink\", hyperlink, \"External\");\n                    nodeAttributes = {\n                        ref: address,\n                        'r:id': relationship.attributes.Id\n                    };\n                }\n                this._hyperlinks[address] = {\n                    name: 'hyperlink',\n                    attributes: nodeAttributes,\n                    children: []\n                };\n                return this;\n            })\n            .case(['string', 'object'], (address, opts) => {\n                if (opts instanceof Cell) {\n                    const cell = opts;\n                    const hyperlink = cell.address({ includeSheetName: true });\n                    this.hyperlink(address, hyperlink, true);\n                } else if (opts.hyperlink) {\n                    this.hyperlink(address, opts.hyperlink);\n                } else if (opts.email) {\n                    const email = opts.email;\n                    const subject = opts.emailSubject || '';\n                    this.hyperlink(address, encodeURI(`mailto:${email}?subject=${subject}`));\n                }\n                const hyperlinkNode = this._hyperlinks[address];\n                if (hyperlinkNode) {\n                    if (opts.tooltip) {\n                        hyperlinkNode.attributes.tooltip = opts.tooltip;\n                    }\n                }\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Increment and return the max shared formula ID.\n     * @returns {number} The new max shared formula ID.\n     * @ignore\n     */\n    incrementMaxSharedFormulaId() {\n        return ++this._maxSharedFormulaId;\n    }\n\n    /**\n     * Get a value indicating whether the cells in the given address are merged.\n     * @param {string} address - The address to check.\n     * @returns {boolean} True if merged, false if not merged.\n     * @ignore\n     *//**\n     * Merge/unmerge cells by adding/removing a mergeCell entry.\n     * @param {string} address - The address to merge.\n     * @param {boolean} merged - True to merge, false to unmerge.\n     * @returns {Sheet} The sheet.\n     * @ignore\n     */\n    merged() {\n        return new ArgHandler('Sheet.merge')\n            .case('string', address => {\n                return this._mergeCells.hasOwnProperty(address);\n            })\n            .case(['string', '*'], (address, merge) => {\n                if (merge) {\n                    this._mergeCells[address] = {\n                        name: 'mergeCell',\n                        attributes: { ref: address },\n                        children: []\n                    };\n                } else {\n                    delete this._mergeCells[address];\n                }\n\n                return this;\n            })\n            .handle(arguments);\n    }\n\n\n    /**\n     * Gets a Object or undefined of the cells in the given address.\n     * @param {string} address - The address to check.\n     * @returns {object|boolean} Object or false if not set\n     * @ignore\n     *//**\n     * Removes dataValidation at the given address\n     * @param {string} address - The address to remove.\n     * @param {boolean} obj - false to delete.\n     * @returns {boolean} true if removed.\n     * @ignore\n     *//**\n     * Add dataValidation to cells at the given address if object or string\n     * @param {string} address - The address to set.\n     * @param {object|string} obj - Object or String to set\n     * @returns {Sheet} The sheet.\n     * @ignore\n     */\n    dataValidation() {\n        return new ArgHandler('Sheet.dataValidation')\n            .case('string', address => {\n                if (this._dataValidations[address]) {\n                    return {\n                        type: this._dataValidations[address].attributes.type,\n                        allowBlank: this._dataValidations[address].attributes.allowBlank,\n                        showInputMessage: this._dataValidations[address].attributes.showInputMessage,\n                        prompt: this._dataValidations[address].attributes.prompt,\n                        promptTitle: this._dataValidations[address].attributes.promptTitle,\n                        showErrorMessage: this._dataValidations[address].attributes.showErrorMessage,\n                        error: this._dataValidations[address].attributes.error,\n                        errorTitle: this._dataValidations[address].attributes.errorTitle,\n                        operator: this._dataValidations[address].attributes.operator,\n                        formula1: this._dataValidations[address].children[0].children[0],\n                        formula2: this._dataValidations[address].children[1] ? this._dataValidations[address].children[1].children[0] : undefined\n                    };\n                } else {\n                    return false;\n                }\n            })\n            .case(['string', 'boolean'], (address, obj) => {\n                if (this._dataValidations[address]) {\n                    if (obj === false) return delete this._dataValidations[address];\n                } else {\n                    return false;\n                }\n            })\n            .case(['string', '*'], (address, obj) => {\n                if (typeof obj === 'string') {\n                    this._dataValidations[address] = {\n                        name: 'dataValidation',\n                        attributes: {\n                            type: 'list',\n                            allowBlank: false,\n                            showInputMessage: false,\n                            prompt: '',\n                            promptTitle: '',\n                            showErrorMessage: false,\n                            error: '',\n                            errorTitle: '',\n                            operator: '',\n                            sqref: address\n                        },\n                        children: [\n                            {\n                                name: 'formula1',\n                                atrributes: {},\n                                children: [obj]\n                            },\n                            {\n                                name: 'formula2',\n                                atrributes: {},\n                                children: ['']\n                            }\n                        ]\n                    };\n                } else if (typeof obj === 'object') {\n                    this._dataValidations[address] = {\n                        name: 'dataValidation',\n                        attributes: {\n                            type: obj.type ? obj.type : 'list',\n                            allowBlank: obj.allowBlank,\n                            showInputMessage: obj.showInputMessage,\n                            prompt: obj.prompt,\n                            promptTitle: obj.promptTitle,\n                            showErrorMessage: obj.showErrorMessage,\n                            error: obj.error,\n                            errorTitle: obj.errorTitle,\n                            operator: obj.operator,\n                            sqref: address\n                        },\n                        children: [\n                            {\n                                name: 'formula1',\n                                atrributes: {},\n                                children: [\n                                    obj.formula1\n                                ]\n                            },\n                            {\n                                name: 'formula2',\n                                atrributes: {},\n                                children: [\n                                    obj.formula2\n                                ]\n                            }\n                        ]\n                    };\n                }\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Convert the sheet to a collection of XML objects.\n     * @returns {{}} The XML forms.\n     * @ignore\n     */\n    toXmls() {\n        // Shallow clone the node so we don't have to remove these children later if they don't belong.\n        const node = _.clone(this._node);\n        node.children = node.children.slice();\n\n        // Add the columns if needed.\n        this._colsNode.children = _.filter(this._colNodes, (colNode, i) => {\n            // Columns should only be present if they have attributes other than min/max.\n            return colNode && i === colNode.attributes.min && Object.keys(colNode.attributes).length > 2;\n        });\n        if (this._colsNode.children.length) {\n            xmlq.insertInOrder(node, this._colsNode, nodeOrder);\n        }\n\n        // Add the hyperlinks if needed.\n        this._hyperlinksNode.children = _.values(this._hyperlinks);\n        if (this._hyperlinksNode.children.length) {\n            xmlq.insertInOrder(node, this._hyperlinksNode, nodeOrder);\n        }\n\n        // Add the printOptions if needed.\n        if (this._printOptionsNode) {\n            if (Object.keys(this._printOptionsNode.attributes).length) {\n                xmlq.insertInOrder(node, this._printOptionsNode, nodeOrder);\n            }\n        }\n\n        // Add the pageMargins if needed.\n        if (this._pageMarginsNode && this._pageMarginsPresetName) {\n            // Clone to preserve the current state of this sheet.\n            const childNode = _.clone(this._pageMarginsNode);\n            if (Object.keys(this._pageMarginsNode.attributes).length) {\n                // Fill in any missing attribute values with presets.\n                childNode.attributes = _.assign(\n                    this._pageMarginsPresets[this._pageMarginsPresetName],\n                    this._pageMarginsNode.attributes);\n            } else {\n                // No need to fill in, all attributes is currently empty, simply replace.\n                childNode.attributes = this._pageMarginsPresets[this._pageMarginsPresetName];\n            }\n            xmlq.insertInOrder(node, childNode, nodeOrder);\n        }\n\n        // Add the merge cells if needed.\n        this._mergeCellsNode.children = _.values(this._mergeCells);\n        if (this._mergeCellsNode.children.length) {\n            xmlq.insertInOrder(node, this._mergeCellsNode, nodeOrder);\n        }\n\n        // Add the DataValidation cells if needed.\n        this._dataValidationsNode.children = _.values(this._dataValidations);\n        if (this._dataValidationsNode.children.length) {\n            xmlq.insertInOrder(node, this._dataValidationsNode, nodeOrder);\n        }\n\n        if (this._autoFilter) {\n            xmlq.insertInOrder(node, {\n                name: \"autoFilter\",\n                children: [],\n                attributes: {\n                    ref: this._autoFilter.address()\n                }\n            }, nodeOrder);\n        }\n\n        // Add the PageBreaks nodes if needed.\n        ['colBreaks', 'rowBreaks'].forEach(name => {\n            const breaks = this[`_${name}Node`];\n            if (breaks.attributes.count) {\n                xmlq.insertInOrder(node, breaks, nodeOrder);\n            }\n        });\n\n        return {\n            id: this._idNode,\n            sheet: node,\n            relationships: this._relationships\n        };\n    }\n\n    /**\n     * Update the max shared formula ID to the given value if greater than current.\n     * @param {number} sharedFormulaId - The new shared formula ID.\n     * @returns {undefined}\n     * @ignore\n     */\n    updateMaxSharedFormulaId(sharedFormulaId) {\n        if (sharedFormulaId > this._maxSharedFormulaId) {\n            this._maxSharedFormulaId = sharedFormulaId;\n        }\n    }\n\n    /**\n     * Get the print option given a valid print option attribute.\n     * @param {string} attributeName - Attribute name of the printOptions.\n     *   gridLines - Used in conjunction with gridLinesSet. If both gridLines and gridlinesSet are true, then grid lines shall print. Otherwise, they shall not (i.e., one or both have false values).\n     *   gridLinesSet - Used in conjunction with gridLines. If both gridLines and gridLinesSet are true, then grid lines shall print. Otherwise, they shall not (i.e., one or both have false values).\n     *   headings - Print row and column headings.\n     *   horizontalCentered - Center on page horizontally when printing.\n     *   verticalCentered - Center on page vertically when printing.\n     * @returns {boolean}\n     *//**\n     * Set the print option given a valid print option attribute and a value.\n     * @param {string} attributeName - Attribute name of the printOptions. See get print option for list of valid attributes.\n     * @param {undefined|boolean} attributeEnabled - If `undefined` or `false` then the attribute is removed, otherwise the print option is enabled.\n     * @returns {Sheet} The sheet.\n     */\n    printOptions() {\n        const supportedAttributeNames = [\n            'gridLines', 'gridLinesSet', 'headings', 'horizontalCentered', 'verticalCentered'];\n        const checkAttributeName = this._getCheckAttributeNameHelper('printOptions', supportedAttributeNames);\n        return new ArgHandler('Sheet.printOptions')\n            .case(['string'], attributeName => {\n                checkAttributeName(attributeName);\n                return this._printOptionsNode.attributes[attributeName] === 1;\n            })\n            .case(['string', 'nil'], attributeName => {\n                checkAttributeName(attributeName);\n                delete this._printOptionsNode.attributes[attributeName];\n                return this;\n            })\n            .case(['string', 'boolean'], (attributeName, attributeEnabled) => {\n                checkAttributeName(attributeName);\n                if (attributeEnabled) {\n                    this._printOptionsNode.attributes[attributeName] = 1;\n                    return this;\n                } else {\n                    return this.printOptions(attributeName, undefined);\n                }\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Get the print option for the gridLines attribute value.\n     * @returns {boolean}\n     *//**\n     * Set the print option for the gridLines attribute value.\n     * @param {undefined|boolean} enabled - If `undefined` or `false` then attribute is removed, otherwise gridLines is enabled.\n     * @returns {Sheet} The sheet.\n     */\n    printGridLines() {\n        return new ArgHandler('Sheet.gridLines')\n            .case(() => {\n                return this.printOptions('gridLines') && this.printOptions('gridLinesSet');\n            })\n            .case(['nil'], () => {\n                this.printOptions('gridLines', undefined);\n                this.printOptions('gridLinesSet', undefined);\n                return this;\n            })\n            .case(['boolean'], enabled => {\n                this.printOptions('gridLines', enabled);\n                this.printOptions('gridLinesSet', enabled);\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Get the page margin given a valid attribute name.\n     * If the value is not yet defined, then it will return the current preset value.\n     * @param {string} attributeName - Attribute name of the pageMargins.\n     *     left - Left Page Margin in inches.\n     *     right - Right page margin in inches.\n     *     top - Top Page Margin in inches.\n     *     buttom - Bottom Page Margin in inches.\n     *     footer - Footer Page Margin in inches.\n     *     header - Header Page Margin in inches.\n     * @returns {number} the attribute value.\n     *//**\n     * Set the page margin (or override the preset) given an attribute name and a value.\n     * @param {string} attributeName - Attribute name of the pageMargins. See get page margin for list of valid attributes.\n     * @param {undefined|number|string} attributeStringValue - If `undefined` then set back to preset value, otherwise, set the given attribute value.\n     * @returns {Sheet} The sheet.\n     */\n    pageMargins() {\n        if (this.pageMarginsPreset() === undefined) {\n            throw new Error('Sheet.pageMargins: preset is undefined.');\n        }\n        const supportedAttributeNames = [\n            'left', 'right', 'top', 'bottom', 'header', 'footer'];\n        const checkAttributeName = this._getCheckAttributeNameHelper('pageMargins', supportedAttributeNames);\n        const checkRange = this._getCheckRangeHelper('pageMargins', 0, undefined);\n        return new ArgHandler('Sheet.pageMargins')\n            .case(['string'], attributeName => {\n                checkAttributeName(attributeName);\n                const attributeValue = this._pageMarginsNode.attributes[attributeName];\n                if (attributeValue !== undefined) {\n                    return parseFloat(attributeValue);\n                } else if (this._pageMarginsPresetName) {\n                    return parseFloat(this._pageMarginsPresets[this._pageMarginsPresetName][attributeName]);\n                } else {\n                    return undefined;\n                }\n            })\n            .case(['string', 'nil'], attributeName => {\n                checkAttributeName(attributeName);\n                delete this._pageMarginsNode.attributes[attributeName];\n                return this;\n            })\n            .case(['string', 'number'], (attributeName, attributeNumberValue) => {\n                checkAttributeName(attributeName);\n                checkRange(attributeNumberValue);\n                this._pageMarginsNode.attributes[attributeName] = attributeNumberValue;\n                return this;\n            })\n            .case(['string', 'string'], (attributeName, attributeStringValue) => {\n                return this.pageMargins(attributeName, parseFloat(attributeStringValue));\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Page margins preset is a set of page margins associated with a name.\n     * The page margin preset acts as a fallback when not explicitly defined by `Sheet.pageMargins`.\n     * If a sheet already contains page margins, it attempts to auto-detect, otherwise they are defined as the template preset.\n     * If no page margins exist, then the preset is undefined and will not be included in the output of `Sheet.toXmls`.\n     * Available presets include: normal, wide, narrow, template.\n     *\n     * Get the page margins preset name. The registered name of a predefined set of attributes.\n     * @returns {string} The preset name.\n     *//**\n     * Set the page margins preset by name, clearing any existing/temporary attribute values.\n     * @param {undefined|string} presetName - The preset name. If `undefined`, page margins will not be included in the output of `Sheet.toXmls`.\n     * @returns {Sheet} The sheet.\n     *//**\n     * Set a new page margins preset by name and attributes object.\n     * @param {string} presetName - The preset name.\n     * @param {object} presetAttributes - The preset attributes.\n     * @returns {Sheet} The sheet.\n     */\n    pageMarginsPreset() {\n        return new ArgHandler('Sheet.pageMarginsPreset')\n            .case(() => {\n                return this._pageMarginsPresetName;\n            })\n            .case(['nil'], () => {\n                // Remove all preset overrides and exclude from sheet\n                this._pageMarginsPresetName = undefined;\n\n                // Remove all preset overrides\n                this._pageMarginsNode.attributes = {};\n                return this;\n            })\n            .case(['string'], presetName => {\n                const checkPresetName = this._getCheckAttributeNameHelper(\n                    'pageMarginsPreset', Object.keys(this._pageMarginsPresets));\n                checkPresetName(presetName);\n\n                // Change to new preset\n                this._pageMarginsPresetName = presetName;\n\n                // Remove all preset overrides\n                this._pageMarginsNode.attributes = {};\n                return this;\n            })\n            .case(['string', 'object'], (presetName, presetAttributes) => {\n                if (this._pageMarginsPresets.hasOwnProperty(presetName)) {\n                    throw new Error(`Sheet.pageMarginsPreset: The preset ${presetName} already exists!`);\n                }\n\n                // Validate preset attribute keys.\n                const pageMarginsAttributeNames = [\n                    'left', 'right', 'top', 'bottom', 'header', 'footer'];\n                const isValidPresetAttributeKeys = _.isEqual(\n                    _.sortBy(pageMarginsAttributeNames),\n                    _.sortBy(Object.keys(presetAttributes)));\n                if (isValidPresetAttributeKeys === false) {\n                    throw new Error(`Sheet.pageMarginsPreset: Invalid preset attributes for one or key(s)! - \"${Object.keys(presetAttributes)}\"`);\n                }\n\n                // Validate preset attribute values.\n                _.forEach((attributeValue, attributeName) => {\n                    const attributeNumberValue = parseFloat(attributeValue);\n                    if (_.isNaN(attributeNumberValue) || _.isNumber(attributeNumberValue) === false) {\n                        throw new Error(`Sheet.pageMarginsPreset: Invalid preset attribute value! - \"${attributeValue}\"`);\n                    }\n                });\n\n                // Change to new preset\n                this._pageMarginsPresetName = presetName;\n\n                // Remove all preset overrides\n                this._pageMarginsNode.attributes = {};\n\n                // Register the preset\n                this._pageMarginsPresets[presetName] = presetAttributes;\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * https://docs.microsoft.com/en-us/dotnet/api/documentformat.openxml.spreadsheet.pane?view=openxml-2.8.1\n     * @typedef {Object} PaneOptions\n     * @property {string} activePane=bottomRight Active Pane. The pane that is active.\n     * @property {string} state Split State. Indicates whether the pane has horizontal / vertical splits,\n     * and whether those splits are frozen.\n     * @property {string} topLeftCell Top Left Visible Cell. Location of the top left visible cell in the bottom\n     * right pane (when in Left-To-Right mode).\n     * @property {number} xSplit (Horizontal Split Position) Horizontal position of the split, in 1/20th of a point;\n     * 0 (zero) if none. If the pane is frozen, this value indicates the number of columns visible in the top pane.\n     * @property {number} ySplit (Vertical Split Position) Vertical position of the split, in 1/20th of a point; 0\n     * (zero) if none. If the pane is frozen, this value indicates the number of rows visible in the left pane.\n     *//**\n     * Gets sheet view pane options\n     * @return {PaneOptions} sheet view pane options\n     *//**\n     * Sets sheet view pane options\n     * @param {PaneOptions|null|undefined} paneOptions sheet view pane options\n     * @return {Sheet} The sheet\n     */\n    panes() {\n        const supportedStates = ['split', 'frozen', 'frozenSplit'];\n        const supportedActivePanes = ['bottomLeft', 'bottomRight', 'topLeft', 'topRight'];\n        const checkStateName = this._getCheckAttributeNameHelper('pane.state', supportedStates);\n        const checkActivePane = this._getCheckAttributeNameHelper('pane.activePane', supportedActivePanes);\n        const sheetViewNode = this._getOrCreateSheetViewNode();\n        let paneNode = xmlq.findChild(sheetViewNode, 'pane');\n        return new ArgHandler('Sheet.pane')\n            .case(() => {\n                if (paneNode) {\n                    const result = _.cloneDeep(paneNode.attributes);\n                    if (!result.state) result.state = 'split';\n                    return result;\n                }\n            })\n            .case(['nil'], () => {\n                xmlq.removeChild(sheetViewNode, 'pane');\n                return this;\n            })\n            .case(['object'], paneAttributes => {\n                const attributes = _.assign({ activePane: 'bottomRight' }, paneAttributes);\n                checkStateName(attributes.state);\n                checkActivePane(attributes.activePane);\n                if (paneNode) {\n                    paneNode.attributes = attributes;\n                } else {\n                    paneNode = {\n                        name: \"pane\",\n                        attributes,\n                        children: []\n                    };\n                    xmlq.appendChild(sheetViewNode, paneNode);\n                }\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Freezes Panes for this sheet.\n     * @param {number} xSplit the number of columns visible in the top pane. 0 (zero) if none.\n     * @param {number} ySplit the number of rows visible in the left pane. 0 (zero) if none.\n     * @return {Sheet} The sheet\n     *//**\n     * freezes Panes for this sheet.\n     * @param {string} topLeftCell Top Left Visible Cell. Location of the top left visible cell in the bottom\n     * right pane (when in Left-To-Right mode).\n     * @return {Sheet} The sheet\n     */\n    freezePanes() {\n        return new ArgHandler('Sheet.feezePanes')\n            .case(['integer', 'integer'], (xSplit, ySplit) => {\n                const topLeftCell = addressConverter.columnNumberToName(xSplit + 1) + (ySplit + 1);\n                let activePane = xSplit === 0 ? 'bottomLeft' : 'bottomRight';\n                activePane = ySplit === 0 ? 'topRight' : activePane;\n                return this.panes({ state: 'frozen', topLeftCell, xSplit, ySplit, activePane });\n            })\n            .case(['string'], topLeftCell => {\n                const ref = addressConverter.fromAddress(topLeftCell);\n                const xSplit = ref.columnNumber - 1, ySplit = ref.rowNumber - 1;\n                let activePane = xSplit === 0 ? 'bottomLeft' : 'bottomRight';\n                activePane = ySplit === 0 ? 'topRight' : activePane;\n                return this.panes({ state: 'frozen', topLeftCell, xSplit, ySplit, activePane });\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Splits Panes for this sheet.\n     * @param {number} xSplit (Horizontal Split Position) Horizontal position of the split,\n     * in 1/20th of a point; 0 (zero) if none.\n     * @param {number} ySplit (Vertical Split Position) VVertical position of the split,\n     * in 1/20th of a point; 0 (zero) if none.\n     * @return {Sheet} The sheet\n     */\n    splitPanes(xSplit, ySplit) {\n        return this.panes({ state: 'split', xSplit, ySplit });\n    }\n\n    /**\n     * resets to default sheet view panes.\n     * @return {Sheet} The sheet\n     */\n    resetPanes() {\n        return this.panes(null);\n    }\n\n    /* PRIVATE */\n\n    /**\n     * Get a helper function to check that the attribute name provided is supported.\n     * @param {string} functionName - Name of the parent function.\n     * @param {array} supportedAttributeNames - Array of supported attribute name strings.\n     * @returns {function} The helper function, which takes an attribute name. If the array of supported attribute names does not contain the given attribute name, then an Error is thrown.\n     * @ignore\n     */\n    _getCheckAttributeNameHelper(functionName, supportedAttributeNames) {\n        return attributeName => {\n            if (!_.includes(supportedAttributeNames, attributeName)) {\n                throw new Error(`Sheet.${functionName}: \"${attributeName}\" is not supported.`);\n            }\n        };\n    }\n\n    /**\n     * Get a helper function to check that the value is of the expected type.\n     * @param {string} functionName - Name of the parent function.\n     * @param {string} valueType - A string produced by typeof.\n     * @returns {function} The helper function, which takes a value. If the value type is not expected, a TypeError is thrown.\n     * @ignore\n     */\n    _getCheckTypeHelper(functionName, valueType) {\n        return value => {\n            if (typeof value !== valueType) {\n                throw new TypeError(`Sheet.${functionName}: invalid type - value must be of type ${valueType}.`);\n            }\n        };\n    }\n\n    /**\n     * Get a helper function to check that the value is within the expected range.\n     * @param {string} functionName - Name of the parent function.\n     * @param {undefined|number} valueMin - The minimum value of the range. This value is range-inclusive.\n     * @param {undefined|number} valueMax - The maximum value of the range. This value is range-exclusive.\n     * @returns {function} The helper function, which takes a value. If the value type is not 'number', a TypeError is thrown. If the value is not within the range, a RangeError is thrown.\n     * @ignore\n     */\n    _getCheckRangeHelper(functionName, valueMin, valueMax) {\n        const checkType = this._getCheckTypeHelper(functionName, 'number');\n        return value => {\n            checkType(value);\n            if (valueMin !== undefined) {\n                if (value < valueMin) {\n                    throw new RangeError(`Sheet.${functionName}: value too small - value must be greater than or equal to ${valueMin}.`);\n                }\n            }\n            if (valueMax !== undefined) {\n                if (valueMax <= value) {\n                    throw new RangeError(`Sheet.${functionName}: value too large - value must be less than ${valueMax}.`);\n                }\n            }\n        };\n    }\n\n    /**\n     * Get the sheet view node if it exists or create it if it doesn't.\n     * @returns {{}} The sheet view node.\n     * @private\n     */\n    _getOrCreateSheetViewNode() {\n        let sheetViewsNode = xmlq.findChild(this._node, \"sheetViews\");\n        if (!sheetViewsNode) {\n            sheetViewsNode = {\n                name: \"sheetViews\",\n                attributes: {},\n                children: [{\n                    name: \"sheetView\",\n                    attributes: {\n                        workbookViewId: 0\n                    },\n                    children: []\n                }]\n            };\n\n            xmlq.insertInOrder(this._node, sheetViewsNode, nodeOrder);\n        }\n\n        return xmlq.findChild(sheetViewsNode, \"sheetView\");\n    }\n\n    /**\n     * Initializes the sheet.\n     * @param {Workbook} workbook - The parent workbook.\n     * @param {{}} idNode - The sheet ID node (from the parent workbook).\n     * @param {{}} node - The sheet node.\n     * @param {{}} [relationshipsNode] - The optional sheet relationships node.\n     * @returns {undefined}\n     * @private\n     */\n    _init(workbook, idNode, node, relationshipsNode) {\n        if (!node) {\n            node = {\n                name: \"worksheet\",\n                attributes: {\n                    xmlns: \"http://schemas.openxmlformats.org/spreadsheetml/2006/main\",\n                    'xmlns:r': \"http://schemas.openxmlformats.org/officeDocument/2006/relationships\",\n                    'xmlns:mc': \"http://schemas.openxmlformats.org/markup-compatibility/2006\",\n                    'mc:Ignorable': \"x14ac\",\n                    'xmlns:x14ac': \"http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac\"\n                },\n                children: [{\n                    name: \"sheetData\",\n                    attributes: {},\n                    children: []\n                }]\n            };\n        }\n\n        this._workbook = workbook;\n        this._idNode = idNode;\n        this._node = node;\n        this._maxSharedFormulaId = -1;\n        this._mergeCells = {};\n        this._dataValidations = {};\n        this._hyperlinks = {};\n        this._autoFilter = null;\n\n        // Create the relationships.\n        this._relationships = new Relationships(relationshipsNode);\n\n        // Delete the optional dimension node\n        xmlq.removeChild(this._node, \"dimension\");\n\n        // Create the rows.\n        this._rows = [];\n        this._sheetDataNode = xmlq.findChild(this._node, \"sheetData\");\n        this._sheetDataNode.children.forEach(rowNode => {\n            const row = new Row(this, rowNode);\n            this._rows[row.rowNumber()] = row;\n        });\n        this._sheetDataNode.children = this._rows;\n\n        // Create the columns node.\n        this._columns = [];\n        this._colsNode = xmlq.findChild(this._node, \"cols\");\n        if (this._colsNode) {\n            xmlq.removeChild(this._node, this._colsNode);\n        } else {\n            this._colsNode = { name: 'cols', attributes: {}, children: [] };\n        }\n\n        // Cache the col nodes.\n        this._colNodes = [];\n        _.forEach(this._colsNode.children, colNode => {\n            const min = colNode.attributes.min;\n            const max = colNode.attributes.max;\n            for (let i = min; i <= max; i++) {\n                this._colNodes[i] = colNode;\n            }\n        });\n\n        // Create the sheet properties node.\n        this._sheetPrNode = xmlq.findChild(this._node, \"sheetPr\");\n        if (!this._sheetPrNode) {\n            this._sheetPrNode = { name: 'sheetPr', attributes: {}, children: [] };\n            xmlq.insertInOrder(this._node, this._sheetPrNode, nodeOrder);\n        }\n\n        // Create the merge cells.\n        this._mergeCellsNode = xmlq.findChild(this._node, \"mergeCells\");\n        if (this._mergeCellsNode) {\n            xmlq.removeChild(this._node, this._mergeCellsNode);\n        } else {\n            this._mergeCellsNode = { name: 'mergeCells', attributes: {}, children: [] };\n        }\n\n        const mergeCellNodes = this._mergeCellsNode.children;\n        this._mergeCellsNode.children = [];\n        mergeCellNodes.forEach(mergeCellNode => {\n            this._mergeCells[mergeCellNode.attributes.ref] = mergeCellNode;\n        });\n\n\n        // Create the DataValidations.\n        this._dataValidationsNode = xmlq.findChild(this._node, \"dataValidations\");\n        if (this._dataValidationsNode) {\n            xmlq.removeChild(this._node, this._dataValidationsNode);\n        } else {\n            this._dataValidationsNode = { name: 'dataValidations', attributes: {}, children: [] };\n        }\n\n        const dataValidationNodes = this._dataValidationsNode.children;\n        this._dataValidationsNode.children = [];\n        dataValidationNodes.forEach(dataValidationNode => {\n            this._dataValidations[dataValidationNode.attributes.sqref] = dataValidationNode;\n        });\n\n\n        // Create the hyperlinks.\n        this._hyperlinksNode = xmlq.findChild(this._node, \"hyperlinks\");\n        if (this._hyperlinksNode) {\n            xmlq.removeChild(this._node, this._hyperlinksNode);\n        } else {\n            this._hyperlinksNode = { name: 'hyperlinks', attributes: {}, children: [] };\n        }\n\n        const hyperlinkNodes = this._hyperlinksNode.children;\n        this._hyperlinksNode.children = [];\n        hyperlinkNodes.forEach(hyperlinkNode => {\n            this._hyperlinks[hyperlinkNode.attributes.ref] = hyperlinkNode;\n        });\n\n\n        // Create the printOptions.\n        this._printOptionsNode = xmlq.findChild(this._node, \"printOptions\");\n        if (this._printOptionsNode) {\n            xmlq.removeChild(this._node, this._printOptionsNode);\n        } else {\n            this._printOptionsNode = { name: 'printOptions', attributes: {}, children: [] };\n        }\n\n\n        // Create the pageMargins.\n        this._pageMarginsPresets = {\n            normal: {\n                left: 0.7,\n                right: 0.7,\n                top: 0.75,\n                bottom: 0.75,\n                header: 0.3,\n                footer: 0.3\n            },\n            wide: {\n                left: 1,\n                right: 1,\n                top: 1,\n                bottom: 1,\n                header: 0.5,\n                footer: 0.5\n            },\n            narrow: {\n                left: 0.25,\n                right: 0.25,\n                top: 0.75,\n                bottom: 0.75,\n                header: 0.3,\n                footer: 0.3\n            }\n        };\n        this._pageMarginsNode = xmlq.findChild(this._node, \"pageMargins\");\n        if (this._pageMarginsNode) {\n            // Sheet has page margins, assume preset is template.\n            this._pageMarginsPresetName = 'template';\n\n            // Search for a preset that matches existing attributes.\n            for (const presetName in this._pageMarginsPresets) {\n                if (_.isEqual(this._pageMarginsNode.attributes, this._pageMarginsPresets[presetName])) {\n                    this._pageMarginsPresetName = presetName;\n                    break;\n                }\n            }\n\n            // If template preset, then register as template preset, and clear attributes.\n            if (this._pageMarginsPresetName === 'template') {\n                this._pageMarginsPresets.template = this._pageMarginsNode.attributes;\n                this._pageMarginsNode.attributes = {};\n            }\n\n            xmlq.removeChild(this._node, this._pageMarginsNode);\n        } else {\n            // Sheet has no page margins, the preset assignment is therefore undefined.\n            this._pageMarginsPresetName = undefined;\n            this._pageMarginsNode = { name: 'pageMargins', attributes: {}, children: [] };\n        }\n\n        // Create the pageBreaks\n        ['colBreaks', 'rowBreaks'].forEach(name => {\n            this[`_${name}Node`] = xmlq.findChild(this._node, name);\n            if (this[`_${name}Node`]) {\n                xmlq.removeChild(this._node, this[`_${name}Node`]);\n            } else {\n                this[`_${name}Node`] = {\n                    name,\n                    children: [],\n                    attributes: {\n                        count: 0,\n                        manualBreakCount: 0\n                    }\n                };\n            }\n        });\n        this._pageBreaks = {\n            colBreaks: new PageBreaks(this._colBreaksNode),\n            rowBreaks: new PageBreaks(this._rowBreaksNode)\n        };\n    }\n}\n\nmodule.exports = Sheet;\n\n/*\nxl/workbook.xml\n\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<worksheet ...>\n    ...\n\n    <printOptions headings=\"1\" gridLines=\"1\" />\n    <pageMargins left=\"0.7\" right=\"0.7\" top=\"0.75\" bottom=\"0.75\" header=\"0.3\" footer=\"0.3\" />\n    <pageSetup orientation=\"portrait\" horizontalDpi=\"0\" verticalDpi=\"0\" />\n</worksheet>\n// */\n"]},"metadata":{},"sourceType":"script"}