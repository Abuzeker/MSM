{"ast":null,"code":"\"use strict\";\n\nconst _ = require(\"lodash\");\n\nconst RichTextFragment = require(\"./RichTextFragment\");\n/**\n * A RichText class that contains many {@link RichTextFragment}.\n */\n\n\nclass RichText {\n  /**\n   * Creates a new instance of RichText. If you get the instance by calling `Cell.value()`,\n   * adding a text contains line separator will trigger {@link Cell.style}('wrapText', true), which\n   * will make MS Excel show the new line. i.e. In MS Excel, Tap \"alt+Enter\" in a cell, the cell\n   * will set wrap text to true automatically.\n   *\n   * @param {undefined|null|Object} [node] - The node stored in the shared string\n   */\n  constructor(node) {\n    this._node = [];\n    this._cell = null;\n    this._remainingNodes = [];\n\n    if (node) {\n      for (let i = 0; i < node.length; i++) {\n        const fragment = node[i];\n\n        if (fragment.name === 'r') {\n          this._node.push(new RichTextFragment(fragment, null, this));\n        } else {\n          // special node, e.g. rPh, phoneticPr in Japanese language.\n          this._remainingNodes.push(fragment);\n        }\n      }\n    }\n  }\n  /**\n   * Gets which cell this {@link RichText} instance belongs to.\n   * @return {Cell|undefined} The cell this instance belongs to.\n   */\n\n\n  get cell() {\n    return this._cell;\n  }\n  /**\n   * Gets the how many rich text fragment this {@link RichText} instance contains\n   * @return {number} The number of fragments this {@link RichText} instance has.\n   */\n\n\n  get length() {\n    return this._node.length;\n  }\n  /**\n   * Gets concatenated text without styles.\n   * @return {string} concatenated text\n   */\n\n\n  text() {\n    let text = '';\n\n    for (let i = 0; i < this._node.length; i++) {\n      text += this.get(i).value();\n    }\n\n    return text;\n  }\n  /**\n   * Gets the instance with cell reference defined.\n   * @param {Cell} cell - Cell reference.\n   * @return {RichText} The instance with cell reference defined.\n   */\n\n\n  getInstanceWithCellRef(cell) {\n    this._cell = cell;\n    return this;\n  }\n  /**\n   * Returns a deep copy of this instance.\n   * If cell reference is provided, it checks line separators and calls\n   * `cell.style('wrapText', true)` when needed.\n   * @param {Cell|undefined} [cell] - The cell reference.\n   * @return {RichText} A deep copied instance\n   */\n\n\n  copy(cell) {\n    const newRichText = new RichText(_.cloneDeep(this.toXml()));\n\n    if (cell && _.includes(this.text(), '\\n')) {\n      cell.style('wrapText', true);\n    }\n\n    return newRichText;\n  }\n  /**\n   * Gets the ith fragment of this {@link RichText} instance.\n   * @param {number} index - The index\n   * @return {RichTextFragment} A rich text fragment\n   */\n\n\n  get(index) {\n    return this._node[index];\n  }\n  /**\n   * Removes a rich text fragment. This instance will be mutated.\n   * @param {number} index - the index of the fragment to remove\n   * @return {RichText} the rich text instance\n   */\n\n\n  remove(index) {\n    this._node.splice(index, 1);\n\n    this.removeUnsupportedNodes();\n    return this;\n  }\n  /**\n   * Adds a rich text fragment to the last or after the given index. This instance will be mutated.\n   * @param {string} text - the text\n   * @param {{}} [styles] - the styles js object, i.e. {fontSize: 12}\n   * @param {number|undefined|null} [index] - the index of the fragment to add\n   * @return {RichText} the rich text instance\n   */\n\n\n  add(text, styles, index) {\n    if (index === undefined || index === null) {\n      this._node.push(new RichTextFragment(text, styles, this));\n    } else {\n      this._node.splice(index, 0, new RichTextFragment(text, styles, this));\n    }\n\n    this.removeUnsupportedNodes();\n    return this;\n  }\n  /**\n   * Clears this rich text\n   * @return {RichText} the rich text instance\n   */\n\n\n  clear() {\n    this._node = [];\n    this._remainingNodes = [];\n    this._cell = undefined;\n    return this;\n  }\n  /**\n   * Remove all unsupported nodes (phoneticPr, rPh for Japanese language).\n   * @return {undefined}\n   */\n\n\n  removeUnsupportedNodes() {\n    this._remainingNodes = [];\n  }\n  /**\n   * Convert the rich text to an XML object.\n   * @returns {Array.<{}>} The XML form.\n   * @ignore\n   */\n\n\n  toXml() {\n    const node = [];\n\n    for (let i = 0; i < this._node.length; i++) {\n      node.push(this._node[i].toXml());\n    }\n\n    return node.concat(this._remainingNodes);\n  }\n\n} // IE doesn't support function names so explicitly set it.\n\n\nif (!RichText.name) RichText.name = \"RichText\";\nmodule.exports = RichText;","map":{"version":3,"sources":["C:/Users/tzika/Desktop/MSM-Front/MSM/node_modules/xlsx-populate/lib/RichText.js"],"names":["_","require","RichTextFragment","RichText","constructor","node","_node","_cell","_remainingNodes","i","length","fragment","name","push","cell","text","get","value","getInstanceWithCellRef","copy","newRichText","cloneDeep","toXml","includes","style","index","remove","splice","removeUnsupportedNodes","add","styles","undefined","clear","concat","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst _ = require(\"lodash\");\nconst RichTextFragment = require(\"./RichTextFragment\");\n\n/**\n * A RichText class that contains many {@link RichTextFragment}.\n */\nclass RichText {\n    /**\n     * Creates a new instance of RichText. If you get the instance by calling `Cell.value()`,\n     * adding a text contains line separator will trigger {@link Cell.style}('wrapText', true), which\n     * will make MS Excel show the new line. i.e. In MS Excel, Tap \"alt+Enter\" in a cell, the cell\n     * will set wrap text to true automatically.\n     *\n     * @param {undefined|null|Object} [node] - The node stored in the shared string\n     */\n    constructor(node) {\n        this._node = [];\n        this._cell = null;\n        this._remainingNodes = [];\n        if (node) {\n            for (let i = 0; i < node.length; i++) {\n                const fragment = node[i];\n                if (fragment.name === 'r') {\n                    this._node.push(new RichTextFragment(fragment, null, this));\n                } else {\n                    // special node, e.g. rPh, phoneticPr in Japanese language.\n                    this._remainingNodes.push(fragment);\n                }\n            }\n        }\n    }\n\n    /**\n     * Gets which cell this {@link RichText} instance belongs to.\n     * @return {Cell|undefined} The cell this instance belongs to.\n     */\n    get cell() {\n        return this._cell;\n    }\n\n    /**\n     * Gets the how many rich text fragment this {@link RichText} instance contains\n     * @return {number} The number of fragments this {@link RichText} instance has.\n     */\n    get length() {\n        return this._node.length;\n    }\n\n    /**\n     * Gets concatenated text without styles.\n     * @return {string} concatenated text\n     */\n    text() {\n        let text = '';\n        for (let i = 0; i < this._node.length; i++) {\n            text += this.get(i).value();\n        }\n        return text;\n    }\n\n    /**\n     * Gets the instance with cell reference defined.\n     * @param {Cell} cell - Cell reference.\n     * @return {RichText} The instance with cell reference defined.\n     */\n    getInstanceWithCellRef(cell) {\n        this._cell = cell;\n        return this;\n    }\n\n    /**\n     * Returns a deep copy of this instance.\n     * If cell reference is provided, it checks line separators and calls\n     * `cell.style('wrapText', true)` when needed.\n     * @param {Cell|undefined} [cell] - The cell reference.\n     * @return {RichText} A deep copied instance\n     */\n    copy(cell) {\n        const newRichText = new RichText(_.cloneDeep(this.toXml()));\n        if (cell && _.includes(this.text(), '\\n')) {\n            cell.style('wrapText', true);\n        }\n        return newRichText;\n    }\n\n    /**\n     * Gets the ith fragment of this {@link RichText} instance.\n     * @param {number} index - The index\n     * @return {RichTextFragment} A rich text fragment\n     */\n    get(index) {\n        return this._node[index];\n    }\n\n    /**\n     * Removes a rich text fragment. This instance will be mutated.\n     * @param {number} index - the index of the fragment to remove\n     * @return {RichText} the rich text instance\n     */\n    remove(index) {\n        this._node.splice(index, 1);\n        this.removeUnsupportedNodes();\n        return this;\n    }\n\n    /**\n     * Adds a rich text fragment to the last or after the given index. This instance will be mutated.\n     * @param {string} text - the text\n     * @param {{}} [styles] - the styles js object, i.e. {fontSize: 12}\n     * @param {number|undefined|null} [index] - the index of the fragment to add\n     * @return {RichText} the rich text instance\n     */\n    add(text, styles, index) {\n        if (index === undefined || index === null) {\n            this._node.push(new RichTextFragment(text, styles, this));\n        } else {\n            this._node.splice(index, 0, new RichTextFragment(text, styles, this));\n        }\n        this.removeUnsupportedNodes();\n        return this;\n    }\n\n    /**\n     * Clears this rich text\n     * @return {RichText} the rich text instance\n     */\n    clear() {\n        this._node = [];\n        this._remainingNodes = [];\n        this._cell = undefined;\n        return this;\n    }\n\n    /**\n     * Remove all unsupported nodes (phoneticPr, rPh for Japanese language).\n     * @return {undefined}\n     */\n    removeUnsupportedNodes() {\n        this._remainingNodes = [];\n    }\n\n    /**\n     * Convert the rich text to an XML object.\n     * @returns {Array.<{}>} The XML form.\n     * @ignore\n     */\n    toXml() {\n        const node = [];\n        for (let i = 0; i < this._node.length; i++) {\n            node.push(this._node[i].toXml());\n        }\n        return node.concat(this._remainingNodes);\n    }\n}\n\n// IE doesn't support function names so explicitly set it.\nif (!RichText.name) RichText.name = \"RichText\";\n\nmodule.exports = RichText;\n"]},"metadata":{},"sourceType":"script"}