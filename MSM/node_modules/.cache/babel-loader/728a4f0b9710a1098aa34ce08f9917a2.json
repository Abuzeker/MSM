{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:/Users/tzika/Desktop/Polymerlink-Front/polymerlink-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/tzika/Desktop/Polymerlink-Front/polymerlink-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _ = require(\"lodash\");\n\nvar Cell = require(\"./Cell\");\n\nvar regexify = require(\"./regexify\");\n\nvar ArgHandler = require(\"./ArgHandler\");\n\nvar addressConverter = require('./addressConverter');\n/**\n * A row.\n */\n\n\nvar Row = /*#__PURE__*/function () {\n  // /**\n  //  * Creates a new instance of Row.\n  //  * @param {Sheet} sheet - The parent sheet.\n  //  * @param {{}} node - The row node.\n  //  */\n  function Row(sheet, node) {\n    _classCallCheck(this, Row);\n\n    this._sheet = sheet;\n\n    this._init(node);\n  }\n  /* PUBLIC */\n\n  /**\n   * Get the address of the row.\n   * @param {{}} [opts] - Options\n   * @param {boolean} [opts.includeSheetName] - Include the sheet name in the address.\n   * @param {boolean} [opts.anchored] - Anchor the address.\n   * @returns {string} The address\n   */\n\n\n  _createClass(Row, [{\n    key: \"address\",\n    value: function address(opts) {\n      return addressConverter.toAddress({\n        type: 'row',\n        rowNumber: this.rowNumber(),\n        sheetName: opts && opts.includeSheetName && this.sheet().name(),\n        rowAnchored: opts && opts.anchored\n      });\n    }\n    /**\n     * Get a cell in the row.\n     * @param {string|number} columnNameOrNumber - The name or number of the column.\n     * @returns {Cell} The cell.\n     */\n\n  }, {\n    key: \"cell\",\n    value: function cell(columnNameOrNumber) {\n      var columnNumber = columnNameOrNumber;\n\n      if (typeof columnNameOrNumber === 'string') {\n        columnNumber = addressConverter.columnNameToNumber(columnNameOrNumber);\n      }\n\n      if (columnNumber < 1) throw new RangeError(\"Invalid column number \".concat(columnNumber, \". Remember that spreadsheets use 1-based indexing.\")); // Return an existing cell.\n\n      if (this._cells[columnNumber]) return this._cells[columnNumber]; // No cell exists for this.\n      // Check if there is an existing row/column style for the new cell.\n\n      var styleId;\n      var rowStyleId = this._node.attributes.s;\n      var columnStyleId = this.sheet().existingColumnStyleId(columnNumber); // Row style takes priority. If a cell has both row and column styles it should have created a cell entry with a cell-specific style.\n\n      if (!_.isNil(rowStyleId)) styleId = rowStyleId;else if (!_.isNil(columnStyleId)) styleId = columnStyleId; // Create the new cell.\n\n      var cell = new Cell(this, columnNumber, styleId);\n      this._cells[columnNumber] = cell;\n      return cell;\n    }\n    /**\n     * Gets the row height.\n     * @returns {undefined|number} The height (or undefined).\n     */\n\n    /**\n    * Sets the row height.\n    * @param {number} height - The height of the row.\n    * @returns {Row} The row.\n    */\n\n  }, {\n    key: \"height\",\n    value: function height() {\n      var _this = this;\n\n      return new ArgHandler('Row.height').case(function () {\n        return _this._node.attributes.customHeight ? _this._node.attributes.ht : undefined;\n      }).case('number', function (height) {\n        _this._node.attributes.ht = height;\n        _this._node.attributes.customHeight = 1;\n        return _this;\n      }).case('nil', function () {\n        delete _this._node.attributes.ht;\n        delete _this._node.attributes.customHeight;\n        return _this;\n      }).handle(arguments);\n    }\n    /**\n     * Gets a value indicating whether the row is hidden.\n     * @returns {boolean} A flag indicating whether the row is hidden.\n     */\n\n    /**\n    * Sets whether the row is hidden.\n    * @param {boolean} hidden - A flag indicating whether to hide the row.\n    * @returns {Row} The row.\n    */\n\n  }, {\n    key: \"hidden\",\n    value: function hidden() {\n      var _this2 = this;\n\n      return new ArgHandler(\"Row.hidden\").case(function () {\n        return _this2._node.attributes.hidden === 1;\n      }).case('boolean', function (hidden) {\n        if (hidden) _this2._node.attributes.hidden = 1;else delete _this2._node.attributes.hidden;\n        return _this2;\n      }).handle(arguments);\n    }\n    /**\n     * Gets the row number.\n     * @returns {number} The row number.\n     */\n\n  }, {\n    key: \"rowNumber\",\n    value: function rowNumber() {\n      return this._node.attributes.r;\n    }\n    /**\n     * Gets the parent sheet of the row.\n     * @returns {Sheet} The parent sheet.\n     */\n\n  }, {\n    key: \"sheet\",\n    value: function sheet() {\n      return this._sheet;\n    }\n    /**\n     * Gets an individual style.\n     * @param {string} name - The name of the style.\n     * @returns {*} The style.\n     */\n\n    /**\n    * Gets multiple styles.\n    * @param {Array.<string>} names - The names of the style.\n    * @returns {object.<string, *>} Object whose keys are the style names and values are the styles.\n    */\n\n    /**\n    * Sets an individual style.\n    * @param {string} name - The name of the style.\n    * @param {*} value - The value to set.\n    * @returns {Cell} The cell.\n    */\n\n    /**\n    * Sets multiple styles.\n    * @param {object.<string, *>} styles - Object whose keys are the style names and values are the styles to set.\n    * @returns {Cell} The cell.\n    */\n\n    /**\n    * Sets to a specific style\n    * @param {Style} style - Style object given from stylesheet.createStyle\n    * @returns {Cell} The cell.\n    */\n\n  }, {\n    key: \"style\",\n    value: function style() {\n      var _this3 = this;\n\n      return new ArgHandler(\"Row.style\").case('string', function (name) {\n        // Get single value\n        _this3._createStyleIfNeeded();\n\n        return _this3._style.style(name);\n      }).case('array', function (names) {\n        // Get list of values\n        var values = {};\n        names.forEach(function (name) {\n          values[name] = _this3.style(name);\n        });\n        return values;\n      }).case(['string', '*'], function (name, value) {\n        _this3._createCellStylesIfNeeded(); // Style each existing cell within this row. (Cells don't inherit ow/column styles.)\n\n\n        _.forEach(_this3._cells, function (cell) {\n          if (cell) cell.style(name, value);\n        }); // Set the style on the row.\n\n\n        _this3._createStyleIfNeeded();\n\n        _this3._style.style(name, value);\n\n        return _this3;\n      }).case('object', function (nameValues) {\n        // Object of key value pairs to set\n        for (var name in nameValues) {\n          if (!nameValues.hasOwnProperty(name)) continue;\n          var value = nameValues[name];\n\n          _this3.style(name, value);\n        }\n\n        return _this3;\n      }).case('Style', function (style) {\n        _this3._createCellStylesIfNeeded(); // Style each existing cell within this row. (Cells don't inherit ow/column styles.)\n\n\n        _.forEach(_this3._cells, function (cell) {\n          if (cell) cell.style(style);\n        });\n\n        _this3._style = style;\n        _this3._node.attributes.s = style.id();\n        _this3._node.attributes.customFormat = 1;\n        return _this3;\n      }).handle(arguments);\n    }\n    /**\n     * Get the parent workbook.\n     * @returns {Workbook} The parent workbook.\n     */\n\n  }, {\n    key: \"workbook\",\n    value: function workbook() {\n      return this.sheet().workbook();\n    }\n    /**\n     * Append horizontal page break after the row.\n     * @returns {Row} the row.\n     */\n\n  }, {\n    key: \"addPageBreak\",\n    value: function addPageBreak() {\n      this.sheet().horizontalPageBreaks().add(this.rowNumber());\n      return this;\n    }\n    /* INTERNAL */\n\n    /**\n     * Clear cells that are using a given shared formula ID.\n     * @param {number} sharedFormulaId - The shared formula ID.\n     * @returns {undefined}\n     * @ignore\n     */\n\n  }, {\n    key: \"clearCellsUsingSharedFormula\",\n    value: function clearCellsUsingSharedFormula(sharedFormulaId) {\n      this._cells.forEach(function (cell) {\n        if (!cell) return;\n        if (cell.sharesFormula(sharedFormulaId)) cell.clear();\n      });\n    }\n    /**\n     * Find a pattern in the row and optionally replace it.\n     * @param {string|RegExp} pattern - The search pattern.\n     * @param {string} [replacement] - The replacement text.\n     * @returns {Array.<Cell>} The matched cells.\n     * @ignore\n     */\n\n  }, {\n    key: \"find\",\n    value: function find(pattern, replacement) {\n      pattern = regexify(pattern);\n      var matches = [];\n\n      this._cells.forEach(function (cell) {\n        if (!cell) return;\n        if (cell.find(pattern, replacement)) matches.push(cell);\n      });\n\n      return matches;\n    }\n    /**\n     * Check if the row has a cell at the given column number.\n     * @param {number} columnNumber - The column number.\n     * @returns {boolean} True if a cell exists, false otherwise.\n     * @ignore\n     */\n\n  }, {\n    key: \"hasCell\",\n    value: function hasCell(columnNumber) {\n      if (columnNumber < 1) throw new RangeError(\"Invalid column number \".concat(columnNumber, \". Remember that spreadsheets use 1-based indexing.\"));\n      return !!this._cells[columnNumber];\n    }\n    /**\n     * Check if the column has a style defined.\n     * @returns {boolean} True if a style exists, false otherwise.\n     * @ignore\n     */\n\n  }, {\n    key: \"hasStyle\",\n    value: function hasStyle() {\n      return !_.isNil(this._node.attributes.s);\n    }\n    /**\n     * Returns the nax used column number.\n     * @returns {number} The max used column number.\n     * @ignore\n     */\n\n  }, {\n    key: \"minUsedColumnNumber\",\n    value: function minUsedColumnNumber() {\n      return _.findIndex(this._cells);\n    }\n    /**\n     * Returns the nax used column number.\n     * @returns {number} The max used column number.\n     * @ignore\n     */\n\n  }, {\n    key: \"maxUsedColumnNumber\",\n    value: function maxUsedColumnNumber() {\n      return this._cells.length - 1;\n    }\n    /**\n     * Convert the row to an object.\n     * @returns {{}} The object form.\n     * @ignore\n     */\n\n  }, {\n    key: \"toXml\",\n    value: function toXml() {\n      return this._node;\n    }\n    /* PRIVATE */\n\n    /**\n     * If a column node is already defined that intersects with this row and that column has a style set, we\n     * need to make sure that a cell node exists at the intersection so we can style it appropriately.\n     * Fetching the cell will force a new cell node to be created with a style matching the column.\n     * @returns {undefined}\n     * @private\n     */\n\n  }, {\n    key: \"_createCellStylesIfNeeded\",\n    value: function _createCellStylesIfNeeded() {\n      var _this4 = this;\n\n      this.sheet().forEachExistingColumnNumber(function (columnNumber) {\n        if (!_.isNil(_this4.sheet().existingColumnStyleId(columnNumber))) _this4.cell(columnNumber);\n      });\n    }\n    /**\n     * Create a style for this row if it doesn't already exist.\n     * @returns {undefined}\n     * @private\n     */\n\n  }, {\n    key: \"_createStyleIfNeeded\",\n    value: function _createStyleIfNeeded() {\n      if (!this._style) {\n        var styleId = this._node.attributes.s;\n        this._style = this.workbook().styleSheet().createStyle(styleId);\n        this._node.attributes.s = this._style.id();\n        this._node.attributes.customFormat = 1;\n      }\n    }\n    /**\n     * Initialize the row node.\n     * @param {{}} node - The row node.\n     * @returns {undefined}\n     * @private\n     */\n\n  }, {\n    key: \"_init\",\n    value: function _init(node) {\n      var _this5 = this;\n\n      this._node = node;\n      this._cells = [];\n\n      this._node.children.forEach(function (cellNode) {\n        var cell = new Cell(_this5, cellNode);\n        _this5._cells[cell.columnNumber()] = cell;\n      });\n\n      this._node.children = this._cells;\n    }\n  }]);\n\n  return Row;\n}();\n\nmodule.exports = Row;\n/*\n<row r=\"6\" spans=\"1:9\" x14ac:dyDescent=\"0.25\">\n    <c r=\"A6\" s=\"1\" t=\"s\">\n        <v>2</v>\n    </c>\n    <c r=\"B6\" s=\"1\"/>\n    <c r=\"C6\" s=\"1\"/>\n</row>\n*/","map":{"version":3,"sources":["C:/Users/tzika/Desktop/Polymerlink-Front/polymerlink-2/node_modules/xlsx-populate/lib/Row.js"],"names":["_","require","Cell","regexify","ArgHandler","addressConverter","Row","sheet","node","_sheet","_init","opts","toAddress","type","rowNumber","sheetName","includeSheetName","name","rowAnchored","anchored","columnNameOrNumber","columnNumber","columnNameToNumber","RangeError","_cells","styleId","rowStyleId","_node","attributes","s","columnStyleId","existingColumnStyleId","isNil","cell","case","customHeight","ht","undefined","height","handle","arguments","hidden","r","_createStyleIfNeeded","_style","style","names","values","forEach","value","_createCellStylesIfNeeded","nameValues","hasOwnProperty","id","customFormat","workbook","horizontalPageBreaks","add","sharedFormulaId","sharesFormula","clear","pattern","replacement","matches","find","push","findIndex","length","forEachExistingColumnNumber","styleSheet","createStyle","children","cellNode","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst _ = require(\"lodash\");\nconst Cell = require(\"./Cell\");\nconst regexify = require(\"./regexify\");\nconst ArgHandler = require(\"./ArgHandler\");\nconst addressConverter = require('./addressConverter');\n\n/**\n * A row.\n */\nclass Row {\n    // /**\n    //  * Creates a new instance of Row.\n    //  * @param {Sheet} sheet - The parent sheet.\n    //  * @param {{}} node - The row node.\n    //  */\n    constructor(sheet, node) {\n        this._sheet = sheet;\n        this._init(node);\n    }\n\n    /* PUBLIC */\n\n    /**\n     * Get the address of the row.\n     * @param {{}} [opts] - Options\n     * @param {boolean} [opts.includeSheetName] - Include the sheet name in the address.\n     * @param {boolean} [opts.anchored] - Anchor the address.\n     * @returns {string} The address\n     */\n    address(opts) {\n        return addressConverter.toAddress({\n            type: 'row',\n            rowNumber: this.rowNumber(),\n            sheetName: opts && opts.includeSheetName && this.sheet().name(),\n            rowAnchored: opts && opts.anchored\n        });\n    }\n\n    /**\n     * Get a cell in the row.\n     * @param {string|number} columnNameOrNumber - The name or number of the column.\n     * @returns {Cell} The cell.\n     */\n    cell(columnNameOrNumber) {\n        let columnNumber = columnNameOrNumber;\n        if (typeof columnNameOrNumber === 'string') {\n            columnNumber = addressConverter.columnNameToNumber(columnNameOrNumber);\n        }\n\n        if (columnNumber < 1) throw new RangeError(`Invalid column number ${columnNumber}. Remember that spreadsheets use 1-based indexing.`);\n\n        // Return an existing cell.\n        if (this._cells[columnNumber]) return this._cells[columnNumber];\n\n        // No cell exists for this.\n        // Check if there is an existing row/column style for the new cell.\n        let styleId;\n        const rowStyleId = this._node.attributes.s;\n        const columnStyleId = this.sheet().existingColumnStyleId(columnNumber);\n\n        // Row style takes priority. If a cell has both row and column styles it should have created a cell entry with a cell-specific style.\n        if (!_.isNil(rowStyleId)) styleId = rowStyleId;\n        else if (!_.isNil(columnStyleId)) styleId = columnStyleId;\n\n        // Create the new cell.\n        const cell = new Cell(this, columnNumber, styleId);\n        this._cells[columnNumber] = cell;\n        return cell;\n    }\n\n    /**\n     * Gets the row height.\n     * @returns {undefined|number} The height (or undefined).\n     *//**\n     * Sets the row height.\n     * @param {number} height - The height of the row.\n     * @returns {Row} The row.\n     */\n    height() {\n        return new ArgHandler('Row.height')\n            .case(() => {\n                return this._node.attributes.customHeight ? this._node.attributes.ht : undefined;\n            })\n            .case('number', height => {\n                this._node.attributes.ht = height;\n                this._node.attributes.customHeight = 1;\n                return this;\n            })\n            .case('nil', () => {\n                delete this._node.attributes.ht;\n                delete this._node.attributes.customHeight;\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Gets a value indicating whether the row is hidden.\n     * @returns {boolean} A flag indicating whether the row is hidden.\n     *//**\n     * Sets whether the row is hidden.\n     * @param {boolean} hidden - A flag indicating whether to hide the row.\n     * @returns {Row} The row.\n     */\n    hidden() {\n        return new ArgHandler(\"Row.hidden\")\n            .case(() => {\n                return this._node.attributes.hidden === 1;\n            })\n            .case('boolean', hidden => {\n                if (hidden) this._node.attributes.hidden = 1;\n                else delete this._node.attributes.hidden;\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Gets the row number.\n     * @returns {number} The row number.\n     */\n    rowNumber() {\n        return this._node.attributes.r;\n    }\n\n    /**\n     * Gets the parent sheet of the row.\n     * @returns {Sheet} The parent sheet.\n     */\n    sheet() {\n        return this._sheet;\n    }\n\n    /**\n     * Gets an individual style.\n     * @param {string} name - The name of the style.\n     * @returns {*} The style.\n     *//**\n     * Gets multiple styles.\n     * @param {Array.<string>} names - The names of the style.\n     * @returns {object.<string, *>} Object whose keys are the style names and values are the styles.\n     *//**\n     * Sets an individual style.\n     * @param {string} name - The name of the style.\n     * @param {*} value - The value to set.\n     * @returns {Cell} The cell.\n     *//**\n\t * Sets multiple styles.\n\t * @param {object.<string, *>} styles - Object whose keys are the style names and values are the styles to set.\n\t * @returns {Cell} The cell.\n     *//**\n     * Sets to a specific style\n     * @param {Style} style - Style object given from stylesheet.createStyle\n     * @returns {Cell} The cell.\n     */\n    style() {\n        return new ArgHandler(\"Row.style\")\n            .case('string', name => {\n                // Get single value\n                this._createStyleIfNeeded();\n                return this._style.style(name);\n            })\n            .case('array', names => {\n                // Get list of values\n                const values = {};\n                names.forEach(name => {\n                    values[name] = this.style(name);\n                });\n\n                return values;\n            })\n            .case(['string', '*'], (name, value) => {\n                this._createCellStylesIfNeeded();\n\n                // Style each existing cell within this row. (Cells don't inherit ow/column styles.)\n                _.forEach(this._cells, cell => {\n                    if (cell) cell.style(name, value);\n                });\n\n                // Set the style on the row.\n                this._createStyleIfNeeded();\n                this._style.style(name, value);\n\n                return this;\n            })\n            .case('object', nameValues => {\n                // Object of key value pairs to set\n                for (const name in nameValues) {\n                    if (!nameValues.hasOwnProperty(name)) continue;\n                    const value = nameValues[name];\n                    this.style(name, value);\n                }\n\n                return this;\n            })\n            .case('Style', style => {\n                this._createCellStylesIfNeeded();\n\n                // Style each existing cell within this row. (Cells don't inherit ow/column styles.)\n                _.forEach(this._cells, cell => {\n                    if (cell) cell.style(style);\n                });\n\n                this._style = style;\n                this._node.attributes.s = style.id();\n                this._node.attributes.customFormat = 1;\n\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Get the parent workbook.\n     * @returns {Workbook} The parent workbook.\n     */\n    workbook() {\n        return this.sheet().workbook();\n    }\n\n    /**\n     * Append horizontal page break after the row.\n     * @returns {Row} the row.\n     */\n    addPageBreak() {\n        this.sheet().horizontalPageBreaks().add(this.rowNumber());\n        return this;\n    }\n\n    /* INTERNAL */\n\n    /**\n     * Clear cells that are using a given shared formula ID.\n     * @param {number} sharedFormulaId - The shared formula ID.\n     * @returns {undefined}\n     * @ignore\n     */\n    clearCellsUsingSharedFormula(sharedFormulaId) {\n        this._cells.forEach(cell => {\n            if (!cell) return;\n            if (cell.sharesFormula(sharedFormulaId)) cell.clear();\n        });\n    }\n\n    /**\n     * Find a pattern in the row and optionally replace it.\n     * @param {string|RegExp} pattern - The search pattern.\n     * @param {string} [replacement] - The replacement text.\n     * @returns {Array.<Cell>} The matched cells.\n     * @ignore\n     */\n    find(pattern, replacement) {\n        pattern = regexify(pattern);\n\n        const matches = [];\n        this._cells.forEach(cell => {\n            if (!cell) return;\n            if (cell.find(pattern, replacement)) matches.push(cell);\n        });\n\n        return matches;\n    }\n\n    /**\n     * Check if the row has a cell at the given column number.\n     * @param {number} columnNumber - The column number.\n     * @returns {boolean} True if a cell exists, false otherwise.\n     * @ignore\n     */\n    hasCell(columnNumber) {\n        if (columnNumber < 1) throw new RangeError(`Invalid column number ${columnNumber}. Remember that spreadsheets use 1-based indexing.`);\n        return !!this._cells[columnNumber];\n    }\n\n    /**\n     * Check if the column has a style defined.\n     * @returns {boolean} True if a style exists, false otherwise.\n     * @ignore\n     */\n    hasStyle() {\n        return !_.isNil(this._node.attributes.s);\n    }\n\n    /**\n     * Returns the nax used column number.\n     * @returns {number} The max used column number.\n     * @ignore\n     */\n    minUsedColumnNumber() {\n        return _.findIndex(this._cells);\n    }\n\n    /**\n     * Returns the nax used column number.\n     * @returns {number} The max used column number.\n     * @ignore\n     */\n    maxUsedColumnNumber() {\n        return this._cells.length - 1;\n    }\n\n    /**\n     * Convert the row to an object.\n     * @returns {{}} The object form.\n     * @ignore\n     */\n    toXml() {\n        return this._node;\n    }\n\n    /* PRIVATE */\n\n    /**\n     * If a column node is already defined that intersects with this row and that column has a style set, we\n     * need to make sure that a cell node exists at the intersection so we can style it appropriately.\n     * Fetching the cell will force a new cell node to be created with a style matching the column.\n     * @returns {undefined}\n     * @private\n     */\n    _createCellStylesIfNeeded() {\n        this.sheet().forEachExistingColumnNumber(columnNumber => {\n            if (!_.isNil(this.sheet().existingColumnStyleId(columnNumber))) this.cell(columnNumber);\n        });\n    }\n\n    /**\n     * Create a style for this row if it doesn't already exist.\n     * @returns {undefined}\n     * @private\n     */\n    _createStyleIfNeeded() {\n        if (!this._style) {\n            const styleId = this._node.attributes.s;\n            this._style = this.workbook().styleSheet().createStyle(styleId);\n            this._node.attributes.s = this._style.id();\n            this._node.attributes.customFormat = 1;\n        }\n    }\n\n    /**\n     * Initialize the row node.\n     * @param {{}} node - The row node.\n     * @returns {undefined}\n     * @private\n     */\n    _init(node) {\n        this._node = node;\n        this._cells = [];\n        this._node.children.forEach(cellNode => {\n            const cell = new Cell(this, cellNode);\n            this._cells[cell.columnNumber()] = cell;\n        });\n        this._node.children = this._cells;\n    }\n}\n\nmodule.exports = Row;\n\n/*\n<row r=\"6\" spans=\"1:9\" x14ac:dyDescent=\"0.25\">\n    <c r=\"A6\" s=\"1\" t=\"s\">\n        <v>2</v>\n    </c>\n    <c r=\"B6\" s=\"1\"/>\n    <c r=\"C6\" s=\"1\"/>\n</row>\n*/\n"]},"metadata":{},"sourceType":"script"}