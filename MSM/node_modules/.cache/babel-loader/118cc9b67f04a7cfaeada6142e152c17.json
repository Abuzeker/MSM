{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:/Users/tzika/Desktop/Polymerlink-Front/polymerlink-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/tzika/Desktop/Polymerlink-Front/polymerlink-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _ = require(\"lodash\");\n\nvar fs = require(\"fs\");\n\nvar JSZip = require('jszip');\n\nvar externals = require(\"./externals\");\n\nvar regexify = require(\"./regexify\");\n\nvar blank = require(\"./blank\")();\n\nvar xmlq = require(\"./xmlq\");\n\nvar Sheet = require(\"./Sheet\");\n\nvar ContentTypes = require(\"./ContentTypes\");\n\nvar AppProperties = require(\"./AppProperties\");\n\nvar CoreProperties = require(\"./CoreProperties\");\n\nvar Relationships = require(\"./Relationships\");\n\nvar SharedStrings = require(\"./SharedStrings\");\n\nvar StyleSheet = require(\"./StyleSheet\");\n\nvar Encryptor = require(\"./Encryptor\");\n\nvar XmlParser = require(\"./XmlParser\");\n\nvar XmlBuilder = require(\"./XmlBuilder\");\n\nvar ArgHandler = require(\"./ArgHandler\");\n\nvar addressConverter = require(\"./addressConverter\"); // Options for adding files to zip. Do not create folders and use a fixed time at epoch.\n// The default JSZip behavior uses current time, which causes idential workbooks to be different each time.\n\n\nvar zipFileOpts = {\n  date: new Date(0),\n  createFolders: false\n}; // Initialize the parser and builder.\n\nvar xmlParser = new XmlParser();\nvar xmlBuilder = new XmlBuilder(); // Initialize the encryptor if present (can be excluded in browser build).\n\nvar encryptor = typeof Encryptor === \"function\" && new Encryptor(); // Characters not allowed in sheet names.\n\nvar badSheetNameChars = ['\\\\', '/', '*', '[', ']', ':', '?']; // Excel limits sheet names to 31 chars.\n\nvar maxSheetNameLength = 31; // Order of the nodes as defined by the spec.\n\nvar nodeOrder = [\"fileVersion\", \"fileSharing\", \"workbookPr\", \"workbookProtection\", \"bookViews\", \"sheets\", \"functionGroups\", \"externalReferences\", \"definedNames\", \"calcPr\", \"oleSize\", \"customWorkbookViews\", \"pivotCaches\", \"smartTagPr\", \"smartTagTypes\", \"webPublishing\", \"fileRecoveryPr\", \"webPublishObjects\", \"extLst\"];\n/**\n * A workbook.\n */\n\nvar Workbook = /*#__PURE__*/function () {\n  function Workbook() {\n    _classCallCheck(this, Workbook);\n  }\n\n  _createClass(Workbook, [{\n    key: \"activeSheet\",\n    value:\n    /**\n     * Get the active sheet in the workbook.\n     * @returns {Sheet} The active sheet.\n     */\n\n    /**\n    * Set the active sheet in the workbook.\n    * @param {Sheet|string|number} sheet - The sheet or name of sheet or index of sheet to activate. The sheet must not be hidden.\n    * @returns {Workbook} The workbook.\n    */\n    function activeSheet() {\n      var _this = this;\n\n      return new ArgHandler('Workbook.activeSheet').case(function () {\n        return _this._activeSheet;\n      }).case('*', function (sheet) {\n        // Get the sheet from name/index if needed.\n        if (!(sheet instanceof Sheet)) sheet = _this.sheet(sheet); // Check if the sheet is hidden.\n\n        if (sheet.hidden()) throw new Error(\"You may not activate a hidden sheet.\"); // Deselect all sheets except the active one (mirroring ying Excel behavior).\n\n        _.forEach(_this._sheets, function (current) {\n          current.tabSelected(current === sheet);\n        });\n\n        _this._activeSheet = sheet;\n        return _this;\n      }).handle(arguments);\n    }\n    /**\n     * Add a new sheet to the workbook.\n     * @param {string} name - The name of the sheet. Must be unique, less than 31 characters, and may not contain the following characters: \\ / * [ ] : ?\n     * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.\n     * @returns {Sheet} The new sheet.\n     */\n\n  }, {\n    key: \"addSheet\",\n    value: function addSheet(name, indexOrBeforeSheet) {\n      return this._addSheet(name, indexOrBeforeSheet);\n    }\n    /**\n     * Gets a defined name scoped to the workbook.\n     * @param {string} name - The defined name.\n     * @returns {undefined|string|Cell|Range|Row|Column} What the defined name refers to or undefined if not found. Will return the string formula if not a Row, Column, Cell, or Range.\n     */\n\n    /**\n    * Set a defined name scoped to the workbook.\n    * @param {string} name - The defined name.\n    * @param {string|Cell|Range|Row|Column} refersTo - What the name refers to.\n    * @returns {Workbook} The workbook.\n    */\n\n  }, {\n    key: \"definedName\",\n    value: function definedName() {\n      var _this2 = this;\n\n      return new ArgHandler(\"Workbook.definedName\").case('string', function (name) {\n        return _this2.scopedDefinedName(undefined, name);\n      }).case(['string', '*'], function (name, refersTo) {\n        _this2.scopedDefinedName(undefined, name, refersTo);\n\n        return _this2;\n      }).handle(arguments);\n    }\n    /**\n     * Delete a sheet from the workbook.\n     * @param {Sheet|string|number} sheet - The sheet or name of sheet or index of sheet to move.\n     * @returns {Workbook} The workbook.\n     */\n\n  }, {\n    key: \"deleteSheet\",\n    value: function deleteSheet(sheet) {\n      // Get the sheet to move.\n      if (!(sheet instanceof Sheet)) {\n        sheet = this.sheet(sheet);\n        if (!sheet) throw new Error(\"Invalid move sheet reference.\");\n      } // Make sure we are not deleting the only visible sheet.\n\n\n      var visibleSheets = _.filter(this._sheets, function (sheet) {\n        return !sheet.hidden();\n      });\n\n      if (visibleSheets.length === 1 && visibleSheets[0] === sheet) {\n        throw new Error(\"This sheet may not be deleted as a workbook must contain at least one visible sheet.\");\n      } // Remove the sheet.\n\n\n      var index = this._sheets.indexOf(sheet);\n\n      this._sheets.splice(index, 1); // Set the new active sheet.\n\n\n      if (sheet === this.activeSheet()) {\n        if (index >= this._sheets.length) index--;\n        this.activeSheet(index);\n      }\n\n      return this;\n    }\n    /**\n     * Find the given pattern in the workbook and optionally replace it.\n     * @param {string|RegExp} pattern - The pattern to look for. Providing a string will result in a case-insensitive substring search. Use a RegExp for more sophisticated searches.\n     * @param {string|function} [replacement] - The text to replace or a String.replace callback function. If pattern is a string, all occurrences of the pattern in each cell will be replaced.\n     * @returns {boolean} A flag indicating if the pattern was found.\n     */\n\n  }, {\n    key: \"find\",\n    value: function find(pattern, replacement) {\n      pattern = regexify(pattern);\n      var matches = [];\n\n      this._sheets.forEach(function (sheet) {\n        matches = matches.concat(sheet.find(pattern, replacement));\n      });\n\n      return matches;\n    }\n    /**\n     * Move a sheet to a new position.\n     * @param {Sheet|string|number} sheet - The sheet or name of sheet or index of sheet to move.\n     * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.\n     * @returns {Workbook} The workbook.\n     */\n\n  }, {\n    key: \"moveSheet\",\n    value: function moveSheet(sheet, indexOrBeforeSheet) {\n      // Get the sheet to move.\n      if (!(sheet instanceof Sheet)) {\n        sheet = this.sheet(sheet);\n        if (!sheet) throw new Error(\"Invalid move sheet reference.\");\n      } // Get the to/from indexes.\n\n\n      var from = this._sheets.indexOf(sheet);\n\n      var to;\n\n      if (_.isNil(indexOrBeforeSheet)) {\n        to = this._sheets.length - 1;\n      } else if (_.isInteger(indexOrBeforeSheet)) {\n        to = indexOrBeforeSheet;\n      } else {\n        if (!(indexOrBeforeSheet instanceof Sheet)) {\n          indexOrBeforeSheet = this.sheet(indexOrBeforeSheet);\n          if (!indexOrBeforeSheet) throw new Error(\"Invalid before sheet reference.\");\n        }\n\n        to = this._sheets.indexOf(indexOrBeforeSheet);\n      } // Insert the sheet at the appropriate place.\n\n\n      this._sheets.splice(to, 0, this._sheets.splice(from, 1)[0]);\n\n      return this;\n    }\n    /**\n     * Generates the workbook output.\n     * @param {string} [type] - The type of the data to return: base64, binarystring, uint8array, arraybuffer, blob, nodebuffer. Defaults to 'nodebuffer' in Node.js and 'blob' in browsers.\n     * @returns {Promise<string|Uint8Array|ArrayBuffer|Blob|Buffer>} The data.\n     */\n\n    /**\n    * Generates the workbook output.\n    * @param {{}} [opts] Options\n    * @param {string} [opts.type] - The type of the data to return: base64, binarystring, uint8array, arraybuffer, blob, nodebuffer. Defaults to 'nodebuffer' in Node.js and 'blob' in browsers.\n    * @param {string} [opts.password] - The password to use to encrypt the workbook.\n    * @returns {Promise<string|Uint8Array|ArrayBuffer|Blob|Buffer>} The data.\n    */\n\n  }, {\n    key: \"outputAsync\",\n    value: function outputAsync(opts) {\n      var _this3 = this;\n\n      opts = opts || {};\n      if (typeof opts === 'string') opts = {\n        type: opts\n      };\n\n      this._setSheetRefs();\n\n      var definedNamesNode = xmlq.findChild(this._node, \"definedNames\");\n\n      this._sheets.forEach(function (sheet, i) {\n        if (!sheet._autoFilter) return;\n\n        if (!definedNamesNode) {\n          definedNamesNode = {\n            name: \"definedNames\",\n            attributes: {},\n            children: []\n          };\n          xmlq.insertInOrder(_this3._node, definedNamesNode, nodeOrder);\n        }\n\n        xmlq.appendChild(definedNamesNode, {\n          name: \"definedName\",\n          attributes: {\n            name: \"_xlnm._FilterDatabase\",\n            localSheetId: i,\n            hidden: \"1\"\n          },\n          children: [sheet._autoFilter.address({\n            includeSheetName: true,\n            anchored: true\n          })]\n        });\n      });\n\n      this._sheetsNode.children = [];\n\n      this._sheets.forEach(function (sheet, i) {\n        var sheetPath = \"xl/worksheets/sheet\".concat(i + 1, \".xml\");\n        var sheetRelsPath = \"xl/worksheets/_rels/sheet\".concat(i + 1, \".xml.rels\");\n        var sheetXmls = sheet.toXmls();\n\n        var relationship = _this3._relationships.findById(sheetXmls.id.attributes['r:id']);\n\n        relationship.attributes.Target = \"worksheets/sheet\".concat(i + 1, \".xml\");\n\n        _this3._sheetsNode.children.push(sheetXmls.id);\n\n        _this3._zip.file(sheetPath, xmlBuilder.build(sheetXmls.sheet), zipFileOpts);\n\n        var relationshipsXml = xmlBuilder.build(sheetXmls.relationships);\n\n        if (relationshipsXml) {\n          _this3._zip.file(sheetRelsPath, relationshipsXml, zipFileOpts);\n        } else {\n          _this3._zip.remove(sheetRelsPath);\n        }\n      }); // Set the app security to true if a password is set, false if not.\n      // this._appProperties.isSecure(!!opts.password);\n      // Convert the various components to XML strings and add them to the zip.\n\n\n      this._zip.file(\"[Content_Types].xml\", xmlBuilder.build(this._contentTypes), zipFileOpts);\n\n      this._zip.file(\"docProps/app.xml\", xmlBuilder.build(this._appProperties), zipFileOpts);\n\n      this._zip.file(\"docProps/core.xml\", xmlBuilder.build(this._coreProperties), zipFileOpts);\n\n      this._zip.file(\"xl/_rels/workbook.xml.rels\", xmlBuilder.build(this._relationships), zipFileOpts);\n\n      this._zip.file(\"xl/sharedStrings.xml\", xmlBuilder.build(this._sharedStrings), zipFileOpts);\n\n      this._zip.file(\"xl/styles.xml\", xmlBuilder.build(this._styleSheet), zipFileOpts);\n\n      this._zip.file(\"xl/workbook.xml\", xmlBuilder.build(this._node), zipFileOpts); // Generate the zip.\n\n\n      return this._zip.generateAsync({\n        type: \"nodebuffer\",\n        compression: \"DEFLATE\"\n      }).then(function (output) {\n        // If a password is set, encrypt the workbook.\n        if (opts.password) output = encryptor.encrypt(output, opts.password); // Convert and return\n\n        return _this3._convertBufferToOutput(output, opts.type);\n      });\n    }\n    /**\n     * Gets the sheet with the provided name or index (0-based).\n     * @param {string|number} sheetNameOrIndex - The sheet name or index.\n     * @returns {Sheet|undefined} The sheet or undefined if not found.\n     */\n\n  }, {\n    key: \"sheet\",\n    value: function sheet(sheetNameOrIndex) {\n      if (_.isInteger(sheetNameOrIndex)) return this._sheets[sheetNameOrIndex];\n      return _.find(this._sheets, function (sheet) {\n        return sheet.name() === sheetNameOrIndex;\n      });\n    }\n    /**\n     * Get an array of all the sheets in the workbook.\n     * @returns {Array.<Sheet>} The sheets.\n     */\n\n  }, {\n    key: \"sheets\",\n    value: function sheets() {\n      return this._sheets.slice();\n    }\n    /**\n     * Gets an individual property.\n     * @param {string} name - The name of the property.\n     * @returns {*} The property.\n     */\n\n    /**\n    * Gets multiple properties.\n    * @param {Array.<string>} names - The names of the properties.\n    * @returns {object.<string, *>} Object whose keys are the property names and values are the properties.\n    */\n\n    /**\n    * Sets an individual property.\n    * @param {string} name - The name of the property.\n    * @param {*} value - The value to set.\n    * @returns {Workbook} The workbook.\n    */\n\n    /**\n    * Sets multiple properties.\n    * @param {object.<string, *>} properties - Object whose keys are the property names and values are the values to set.\n    * @returns {Workbook} The workbook.\n    */\n\n  }, {\n    key: \"property\",\n    value: function property() {\n      var _this4 = this;\n\n      return new ArgHandler(\"Workbook.property\").case('string', function (name) {\n        // Get single value\n        return _this4._coreProperties.get(name);\n      }).case('array', function (names) {\n        // Get list of values\n        var values = {};\n        names.forEach(function (name) {\n          values[name] = _this4._coreProperties.get(name);\n        });\n        return values;\n      }).case(['string', '*'], function (name, value) {\n        // Set a single value for all cells to a single value\n        _this4._coreProperties.set(name, value);\n\n        return _this4;\n      }).case('object', function (nameValues) {\n        // Object of key value pairs to set\n        for (var name in nameValues) {\n          if (!nameValues.hasOwnProperty(name)) continue;\n          var value = nameValues[name];\n\n          _this4._coreProperties.set(name, value);\n        }\n\n        return _this4;\n      }).handle(arguments);\n    }\n    /**\n     * Get access to core properties object\n     * @returns {CoreProperties} The core properties.\n     */\n\n  }, {\n    key: \"properties\",\n    value: function properties() {\n      return this._coreProperties;\n    }\n    /**\n     * Write the workbook to file. (Not supported in browsers.)\n     * @param {string} path - The path of the file to write.\n     * @param {{}} [opts] - Options\n     * @param {string} [opts.password] - The password to encrypt the workbook.\n     * @returns {Promise.<undefined>} A promise.\n     */\n\n  }, {\n    key: \"toFileAsync\",\n    value: function toFileAsync(path, opts) {\n      if (process.browser) throw new Error(\"Workbook.toFileAsync is not supported in the browser.\");\n      return this.outputAsync(opts).then(function (data) {\n        return new externals.Promise(function (resolve, reject) {\n          fs.writeFile(path, data, function (err) {\n            if (err) return reject(err);\n            resolve();\n          });\n        });\n      });\n    }\n    /**\n     * Gets a scoped defined name.\n     * @param {Sheet} sheetScope - The sheet the name is scoped to. Use undefined for workbook scope.\n     * @param {string} name - The defined name.\n     * @returns {undefined|Cell|Range|Row|Column} What the defined name refers to.\n     * @ignore\n     */\n\n    /**\n    * Sets a scoped defined name.\n    * @param {Sheet} sheetScope - The sheet the name is scoped to. Use undefined for workbook scope.\n    * @param {string} name - The defined name.\n    * @param {undefined|Cell|Range|Row|Column} refersTo - What the defined name refers to.\n    * @returns {Workbook} The workbook.\n    * @ignore\n    */\n\n  }, {\n    key: \"scopedDefinedName\",\n    value: function scopedDefinedName(sheetScope, name, refersTo) {\n      var _this5 = this;\n\n      var definedNamesNode = xmlq.findChild(this._node, \"definedNames\");\n\n      var definedNameNode = definedNamesNode && _.find(definedNamesNode.children, function (node) {\n        return node.attributes.name === name && node.localSheet === sheetScope;\n      });\n\n      return new ArgHandler('Workbook.scopedDefinedName').case(['*', 'string'], function () {\n        // Get the address from the definedNames node.\n        var refersTo = definedNameNode && definedNameNode.children[0];\n        if (!refersTo) return undefined; // Try to parse the address.\n\n        var ref = addressConverter.fromAddress(refersTo);\n        if (!ref) return refersTo; // Load the appropriate selection type.\n\n        var sheet = _this5.sheet(ref.sheetName);\n\n        if (ref.type === 'cell') return sheet.cell(ref.rowNumber, ref.columnNumber);\n        if (ref.type === 'range') return sheet.range(ref.startRowNumber, ref.startColumnNumber, ref.endRowNumber, ref.endColumnNumber);\n        if (ref.type === 'row') return sheet.row(ref.rowNumber);\n        if (ref.type === 'column') return sheet.column(ref.columnNumber);\n        return refersTo;\n      }).case(['*', 'string', 'nil'], function () {\n        if (definedNameNode) xmlq.removeChild(definedNamesNode, definedNameNode);\n        if (definedNamesNode && !definedNamesNode.children.length) xmlq.removeChild(_this5._node, definedNamesNode);\n        return _this5;\n      }).case(['*', 'string', '*'], function () {\n        if (typeof refersTo !== 'string') {\n          refersTo = refersTo.address({\n            includeSheetName: true,\n            anchored: true\n          });\n        }\n\n        if (!definedNamesNode) {\n          definedNamesNode = {\n            name: \"definedNames\",\n            attributes: {},\n            children: []\n          };\n          xmlq.insertInOrder(_this5._node, definedNamesNode, nodeOrder);\n        }\n\n        if (!definedNameNode) {\n          definedNameNode = {\n            name: \"definedName\",\n            attributes: {\n              name: name\n            },\n            children: [refersTo]\n          };\n          if (sheetScope) definedNameNode.localSheet = sheetScope;\n          xmlq.appendChild(definedNamesNode, definedNameNode);\n        }\n\n        definedNameNode.children = [refersTo];\n        return _this5;\n      }).handle(arguments);\n    }\n    /**\n     * Get the shared strings table.\n     * @returns {SharedStrings} The shared strings table.\n     * @ignore\n     */\n\n  }, {\n    key: \"sharedStrings\",\n    value: function sharedStrings() {\n      return this._sharedStrings;\n    }\n    /**\n     * Get the style sheet.\n     * @returns {StyleSheet} The style sheet.\n     * @ignore\n     */\n\n  }, {\n    key: \"styleSheet\",\n    value: function styleSheet() {\n      return this._styleSheet;\n    }\n    /**\n     * Add a new sheet to the workbook.\n     * \n     * **WARN:** this function has limits:  if you clone a sheet with some images or other things link outside the Sheet object, these things in the cloned sheet will be locked when you open in MS Excel app.\n     * @param {Sheet} from - The sheet to be cloned.\n     * @param {string} name - The name of the new sheet. Must be unique, less than 31 characters, and may not contain the following characters: \\ / * [ ] : ?\n     * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.\n     * @returns {Sheet} The new sheet.\n     */\n\n  }, {\n    key: \"cloneSheet\",\n    value: function cloneSheet(from, name, indexOrBeforeSheet) {\n      if (!from || !(from instanceof Sheet)) throw new Error(\"Invalid clone from.\");\n      return this._addSheet(name, indexOrBeforeSheet, function () {\n        var cloneXml = function cloneXml(node) {\n          // If the node has a toXml method, call it.\n          if (node && _.isFunction(node.toXml)) node = node.toXml();\n\n          if (typeof node === 'object') {\n            if (node.name) {\n              var result = {\n                name: node.name,\n                attributes: {},\n                children: []\n              };\n\n              _.forOwn(node.attributes, function (value, name) {\n                result.attributes[name] = value;\n              });\n\n              var chld;\n\n              if (node.children) {\n                node.children.forEach(function (child) {\n                  chld = cloneXml(child);\n\n                  if (child !== null) {\n                    result.children.push(chld);\n                  }\n                });\n              }\n\n              return result;\n            }\n          } else if (node !== null) {\n            return node;\n          }\n\n          return null;\n        }; // clone SheetNode & relationshipNode from source\n\n\n        var fromXml = from.toXmls();\n        var sheetNode = cloneXml(fromXml.sheet);\n        var relationshipNode = cloneXml(fromXml.relationships);\n        return {\n          sheetNode: sheetNode,\n          relationshipNode: relationshipNode\n        };\n      });\n    }\n    /**\n     * Add a new sheet to the workbook.\n     * @param {string} name - The name of the sheet. Must be unique, less than 31 characters, and may not contain the following characters: \\ / * [ ] : ?\n     * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.\n     * @param {callback} [getTemplateNodes] optional callback function for template nodes\n     * @returns {Sheet} The new sheet.\n     * @private\n     */\n\n  }, {\n    key: \"_addSheet\",\n    value: function _addSheet(name, indexOrBeforeSheet, getTemplateNodes) {\n      // Validate the sheet name.\n      if (!name || typeof name !== \"string\") throw new Error(\"Invalid sheet name.\");\n      if (_.some(badSheetNameChars, function (char) {\n        return name.indexOf(char) >= 0;\n      })) throw new Error(\"Sheet name may not contain any of the following characters: \".concat(badSheetNameChars.join(\" \")));\n      if (name.length > maxSheetNameLength) throw new Error(\"Sheet name may not be greater than \".concat(maxSheetNameLength, \" characters.\"));\n      if (this.sheet(name)) throw new Error(\"Sheet with name \\\"\".concat(name, \"\\\" already exists.\")); // Get the destination index of new sheet.\n\n      var index;\n\n      if (_.isNil(indexOrBeforeSheet)) {\n        index = this._sheets.length;\n      } else if (_.isInteger(indexOrBeforeSheet)) {\n        index = indexOrBeforeSheet;\n      } else {\n        if (!(indexOrBeforeSheet instanceof Sheet)) {\n          indexOrBeforeSheet = this.sheet(indexOrBeforeSheet);\n          if (!indexOrBeforeSheet) throw new Error(\"Invalid before sheet reference.\");\n        }\n\n        index = this._sheets.indexOf(indexOrBeforeSheet);\n      } // Add a new relationship for the new sheet and create the new sheet ID node.\n\n\n      var relationship = this._relationships.add(\"worksheet\"); // Leave target blank as it will be filled later.\n\n\n      var sheetIdNode = {\n        name: \"sheet\",\n        attributes: {\n          name: name,\n          sheetId: ++this._maxSheetId,\n          'r:id': relationship.attributes.Id\n        },\n        children: []\n      }; // Create the new sheet.\n\n      var sheet;\n\n      if (getTemplateNodes) {\n        var _getTemplateNodes = getTemplateNodes(),\n            sheetNode = _getTemplateNodes.sheetNode,\n            relationshipNode = _getTemplateNodes.relationshipNode;\n\n        sheet = new Sheet(this, sheetIdNode, sheetNode, relationshipNode);\n      } else {\n        sheet = new Sheet(this, sheetIdNode);\n      } // Insert the sheet at the appropriate index.\n\n\n      this._sheets.splice(index, 0, sheet);\n\n      return sheet;\n    }\n    /**\n     * Initialize the workbook. (This is separated from the constructor to ease testing.)\n     * @param {string|ArrayBuffer|Uint8Array|Buffer|Blob} data - The data to load.\n     * @param {{}} [opts] - Options\n     * @param {boolean} [opts.base64=false] - No used unless input is a string. True if the input string is base64 encoded, false for binary.\n     * @returns {Promise.<Workbook>} The workbook.\n     * @private\n     */\n\n  }, {\n    key: \"_initAsync\",\n    value: function _initAsync(data, opts) {\n      var _this6 = this;\n\n      opts = opts || {};\n      this._maxSheetId = 0;\n      this._sheets = [];\n      return externals.Promise.resolve().then(function () {\n        // Make sure the input is a Buffer\n        return _this6._convertInputToBufferAsync(data, opts.base64).then(function (buffer) {\n          data = buffer;\n        });\n      }).then(function () {\n        if (!opts.password) return;\n        return encryptor.decryptAsync(data, opts.password).then(function (decrypted) {\n          data = decrypted;\n        });\n      }).then(function () {\n        return JSZip.loadAsync(data);\n      }).then(function (zip) {\n        _this6._zip = zip;\n        return _this6._parseNodesAsync([\"[Content_Types].xml\", \"docProps/app.xml\", \"docProps/core.xml\", \"xl/_rels/workbook.xml.rels\", \"xl/sharedStrings.xml\", \"xl/styles.xml\", \"xl/workbook.xml\"]);\n      }).then(function (nodes) {\n        var contentTypesNode = nodes[0];\n        var appPropertiesNode = nodes[1];\n        var corePropertiesNode = nodes[2];\n        var relationshipsNode = nodes[3];\n        var sharedStringsNode = nodes[4];\n        var styleSheetNode = nodes[5];\n        var workbookNode = nodes[6]; // Load the various components.\n\n        _this6._contentTypes = new ContentTypes(contentTypesNode);\n        _this6._appProperties = new AppProperties(appPropertiesNode);\n        _this6._coreProperties = new CoreProperties(corePropertiesNode);\n        _this6._relationships = new Relationships(relationshipsNode);\n        _this6._sharedStrings = new SharedStrings(sharedStringsNode);\n        _this6._styleSheet = new StyleSheet(styleSheetNode);\n        _this6._node = workbookNode; // Add the shared strings relationship if it doesn't exist.\n\n        if (!_this6._relationships.findByType(\"sharedStrings\")) {\n          _this6._relationships.add(\"sharedStrings\", \"sharedStrings.xml\");\n        } // Add the shared string content type if it doesn't exist.\n\n\n        if (!_this6._contentTypes.findByPartName(\"/xl/sharedStrings.xml\")) {\n          _this6._contentTypes.add(\"/xl/sharedStrings.xml\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml\");\n        } // Kill the calc chain. It's not required and the workbook will corrupt unless we keep it up to date.\n\n\n        _this6._zip.remove(\"xl/calcChain.xml\"); // Load each sheet.\n\n\n        _this6._sheetsNode = xmlq.findChild(_this6._node, \"sheets\");\n        return externals.Promise.all(_.map(_this6._sheetsNode.children, function (sheetIdNode, i) {\n          if (sheetIdNode.attributes.sheetId > _this6._maxSheetId) _this6._maxSheetId = sheetIdNode.attributes.sheetId;\n          return _this6._parseNodesAsync([\"xl/worksheets/sheet\".concat(i + 1, \".xml\"), \"xl/worksheets/_rels/sheet\".concat(i + 1, \".xml.rels\")]).then(function (nodes) {\n            var sheetNode = nodes[0];\n            var sheetRelationshipsNode = nodes[1]; // Insert at position i as the promises will resolve at different times.\n\n            _this6._sheets[i] = new Sheet(_this6, sheetIdNode, sheetNode, sheetRelationshipsNode);\n          });\n        }));\n      }).then(function () {\n        return _this6._parseSheetRefs();\n      }).then(function () {\n        return _this6;\n      });\n    }\n    /**\n     * Parse files out of zip into XML node objects.\n     * @param {Array.<string>} names - The file names to parse.\n     * @returns {Promise.<Array.<{}>>} An array of the parsed objects.\n     * @private\n     */\n\n  }, {\n    key: \"_parseNodesAsync\",\n    value: function _parseNodesAsync(names) {\n      var _this7 = this;\n\n      return externals.Promise.all(_.map(names, function (name) {\n        return _this7._zip.file(name);\n      })).then(function (files) {\n        return externals.Promise.all(_.map(files, function (file) {\n          return file && file.async(\"string\");\n        }));\n      }).then(function (texts) {\n        return externals.Promise.all(_.map(texts, function (text) {\n          return text && xmlParser.parseAsync(text);\n        }));\n      });\n    }\n    /**\n     * Parse the sheet references out so we can reorder freely.\n     * @returns {undefined}\n     * @private\n     */\n\n  }, {\n    key: \"_parseSheetRefs\",\n    value: function _parseSheetRefs() {\n      var _this8 = this;\n\n      // Parse the active sheet.\n      var bookViewsNode = xmlq.findChild(this._node, \"bookViews\");\n      var workbookViewNode = bookViewsNode && xmlq.findChild(bookViewsNode, \"workbookView\");\n      var activeTabId = workbookViewNode && workbookViewNode.attributes.activeTab || 0;\n      this._activeSheet = this._sheets[activeTabId]; // Set the location sheet on the defined name nodes. The defined name should point to the index of the sheet\n      // but reordering sheets messes this up. So store it on the node and we'll update the index on XML build.\n\n      var definedNamesNode = xmlq.findChild(this._node, \"definedNames\");\n\n      if (definedNamesNode) {\n        _.forEach(definedNamesNode.children, function (definedNameNode) {\n          if (definedNameNode.attributes.hasOwnProperty(\"localSheetId\")) {\n            definedNameNode.localSheet = _this8._sheets[definedNameNode.attributes.localSheetId];\n          }\n        });\n      }\n    }\n    /**\n     * Set the proper sheet references in the XML.\n     * @returns {undefined}\n     * @private\n     */\n\n  }, {\n    key: \"_setSheetRefs\",\n    value: function _setSheetRefs() {\n      var _this9 = this;\n\n      // Set the active sheet.\n      var bookViewsNode = xmlq.findChild(this._node, \"bookViews\");\n\n      if (!bookViewsNode) {\n        bookViewsNode = {\n          name: 'bookViews',\n          attributes: {},\n          children: []\n        };\n        xmlq.insertInOrder(this._node, bookViewsNode, nodeOrder);\n      }\n\n      var workbookViewNode = xmlq.findChild(bookViewsNode, \"workbookView\");\n\n      if (!workbookViewNode) {\n        workbookViewNode = {\n          name: 'workbookView',\n          attributes: {},\n          children: []\n        };\n        xmlq.appendChild(bookViewsNode, workbookViewNode);\n      }\n\n      workbookViewNode.attributes.activeTab = this._sheets.indexOf(this._activeSheet); // Set the defined names local sheet indexes.\n\n      var definedNamesNode = xmlq.findChild(this._node, \"definedNames\");\n\n      if (definedNamesNode) {\n        _.forEach(definedNamesNode.children, function (definedNameNode) {\n          if (definedNameNode.localSheet) {\n            definedNameNode.attributes.localSheetId = _this9._sheets.indexOf(definedNameNode.localSheet);\n          }\n        });\n      }\n    }\n    /**\n     * Convert buffer to desired output format\n     * @param {Buffer} buffer - The buffer\n     * @param {string} type - The type to convert to: buffer/nodebuffer, blob, base64, binarystring, uint8array, arraybuffer\n     * @returns {Buffer|Blob|string|Uint8Array|ArrayBuffer} The output\n     * @private\n     */\n\n  }, {\n    key: \"_convertBufferToOutput\",\n    value: function _convertBufferToOutput(buffer, type) {\n      if (!type) type = process.browser ? \"blob\" : \"nodebuffer\";\n      if (type === \"buffer\" || type === \"nodebuffer\") return buffer;\n      if (process.browser && type === \"blob\") return new Blob([buffer], {\n        type: Workbook.MIME_TYPE\n      });\n      if (type === \"base64\") return buffer.toString(\"base64\");\n      if (type === \"binarystring\") return buffer.toString(\"utf8\");\n      if (type === \"uint8array\") return new Uint8Array(buffer);\n      if (type === \"arraybuffer\") return new Uint8Array(buffer).buffer;\n      throw new Error(\"Output type '\".concat(type, \"' not supported.\"));\n    }\n    /**\n     * Convert input to buffer\n     * @param {Buffer|Blob|string|Uint8Array|ArrayBuffer} input - The input\n     * @param {boolean} [base64=false] - Only applies if input is a string. If true, the string is base64 encoded, false for binary\n     * @returns {Promise.<Buffer>} The buffer.\n     * @private\n     */\n\n  }, {\n    key: \"_convertInputToBufferAsync\",\n    value: function _convertInputToBufferAsync(input, base64) {\n      return externals.Promise.resolve().then(function () {\n        if (Buffer.isBuffer(input)) return input;\n\n        if (process.browser && input instanceof Blob) {\n          return new externals.Promise(function (resolve) {\n            var fileReader = new FileReader();\n\n            fileReader.onload = function (event) {\n              resolve(Buffer.from(event.target.result));\n            };\n\n            fileReader.readAsArrayBuffer(input);\n          });\n        }\n\n        if (typeof input === \"string\" && base64) return Buffer.from(input, \"base64\");\n        if (typeof input === \"string\" && !base64) return Buffer.from(input, \"utf8\");\n        if (input instanceof Uint8Array || input instanceof ArrayBuffer) return Buffer.from(input);\n        throw new Error(\"Input type unknown.\");\n      });\n    }\n  }], [{\n    key: \"fromBlankAsync\",\n    value:\n    /**\n     * Create a new blank workbook.\n     * @returns {Promise.<Workbook>} The workbook.\n     * @ignore\n     */\n    function fromBlankAsync() {\n      return Workbook.fromDataAsync(blank);\n    }\n    /**\n     * Loads a workbook from a data object. (Supports any supported [JSZip data types]{@link https://stuk.github.io/jszip/documentation/api_jszip/load_async.html}.)\n     * @param {string|Array.<number>|ArrayBuffer|Uint8Array|Buffer|Blob|Promise.<*>} data - The data to load.\n     * @param {{}} [opts] - Options\n     * @returns {Promise.<Workbook>} The workbook.\n     * @ignore\n     */\n\n  }, {\n    key: \"fromDataAsync\",\n    value: function fromDataAsync(data, opts) {\n      return new Workbook()._initAsync(data, opts);\n    }\n    /**\n     * Loads a workbook from file.\n     * @param {string} path - The path to the workbook.\n     * @param {{}} [opts] - Options\n     * @returns {Promise.<Workbook>} The workbook.\n     * @ignore\n     */\n\n  }, {\n    key: \"fromFileAsync\",\n    value: function fromFileAsync(path, opts) {\n      if (process.browser) throw new Error(\"Workbook.fromFileAsync is not supported in the browser\");\n      return new externals.Promise(function (resolve, reject) {\n        fs.readFile(path, function (err, data) {\n          if (err) return reject(err);\n          resolve(data);\n        });\n      }).then(function (data) {\n        return Workbook.fromDataAsync(data, opts);\n      });\n    }\n  }]);\n\n  return Workbook;\n}();\n/**\n * The XLSX mime type.\n * @type {string}\n * @ignore\n */\n\n\nWorkbook.MIME_TYPE = \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\";\nmodule.exports = Workbook;\n/*\nxl/workbook.xml\n\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<workbook xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" mc:Ignorable=\"x15\" xmlns:x15=\"http://schemas.microsoft.com/office/spreadsheetml/2010/11/main\">\n\t<fileVersion appName=\"xl\" lastEdited=\"7\" lowestEdited=\"7\" rupBuild=\"16925\"/>\n\t<workbookPr defaultThemeVersion=\"164011\"/>\n\t<mc:AlternateContent xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\">\n\t\t<mc:Choice Requires=\"x15\">\n\t\t\t<x15ac:absPath url=\"\\path\\to\\file\" xmlns:x15ac=\"http://schemas.microsoft.com/office/spreadsheetml/2010/11/ac\"/>\n\t\t</mc:Choice>\n\t</mc:AlternateContent>\n\t<bookViews>\n\t\t<workbookView xWindow=\"3720\" yWindow=\"0\" windowWidth=\"27870\" windowHeight=\"12795\"/>\n\t</bookViews>\n\t<sheets>\n\t\t<sheet name=\"Sheet1\" sheetId=\"1\" r:id=\"rId1\"/>\n\t</sheets>\n\t<calcPr calcId=\"171027\"/>\n\t<extLst>\n\t\t<ext uri=\"{140A7094-0E35-4892-8432-C4D2E57EDEB5}\" xmlns:x15=\"http://schemas.microsoft.com/office/spreadsheetml/2010/11/main\">\n\t\t\t<x15:workbookPr chartTrackingRefBase=\"1\"/>\n\t\t</ext>\n\t</extLst>\n</workbook>\n// */","map":{"version":3,"sources":["C:/Users/tzika/Desktop/Polymerlink-Front/polymerlink-2/node_modules/xlsx-populate/lib/Workbook.js"],"names":["_","require","fs","JSZip","externals","regexify","blank","xmlq","Sheet","ContentTypes","AppProperties","CoreProperties","Relationships","SharedStrings","StyleSheet","Encryptor","XmlParser","XmlBuilder","ArgHandler","addressConverter","zipFileOpts","date","Date","createFolders","xmlParser","xmlBuilder","encryptor","badSheetNameChars","maxSheetNameLength","nodeOrder","Workbook","case","_activeSheet","sheet","hidden","Error","forEach","_sheets","current","tabSelected","handle","arguments","name","indexOrBeforeSheet","_addSheet","scopedDefinedName","undefined","refersTo","visibleSheets","filter","length","index","indexOf","splice","activeSheet","pattern","replacement","matches","concat","find","from","to","isNil","isInteger","opts","type","_setSheetRefs","definedNamesNode","findChild","_node","i","_autoFilter","attributes","children","insertInOrder","appendChild","localSheetId","address","includeSheetName","anchored","_sheetsNode","sheetPath","sheetRelsPath","sheetXmls","toXmls","relationship","_relationships","findById","id","Target","push","_zip","file","build","relationshipsXml","relationships","remove","_contentTypes","_appProperties","_coreProperties","_sharedStrings","_styleSheet","generateAsync","compression","then","output","password","encrypt","_convertBufferToOutput","sheetNameOrIndex","slice","get","names","values","value","set","nameValues","hasOwnProperty","path","process","browser","outputAsync","data","Promise","resolve","reject","writeFile","err","sheetScope","definedNameNode","node","localSheet","ref","fromAddress","sheetName","cell","rowNumber","columnNumber","range","startRowNumber","startColumnNumber","endRowNumber","endColumnNumber","row","column","removeChild","cloneXml","isFunction","toXml","result","forOwn","chld","child","fromXml","sheetNode","relationshipNode","getTemplateNodes","some","char","join","add","sheetIdNode","sheetId","_maxSheetId","Id","_convertInputToBufferAsync","base64","buffer","decryptAsync","decrypted","loadAsync","zip","_parseNodesAsync","nodes","contentTypesNode","appPropertiesNode","corePropertiesNode","relationshipsNode","sharedStringsNode","styleSheetNode","workbookNode","findByType","findByPartName","all","map","sheetRelationshipsNode","_parseSheetRefs","files","async","texts","text","parseAsync","bookViewsNode","workbookViewNode","activeTabId","activeTab","Blob","MIME_TYPE","toString","Uint8Array","input","Buffer","isBuffer","fileReader","FileReader","onload","event","target","readAsArrayBuffer","ArrayBuffer","fromDataAsync","_initAsync","readFile","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst _ = require(\"lodash\");\nconst fs = require(\"fs\");\nconst JSZip = require('jszip');\n\nconst externals = require(\"./externals\");\nconst regexify = require(\"./regexify\");\nconst blank = require(\"./blank\")();\nconst xmlq = require(\"./xmlq\");\nconst Sheet = require(\"./Sheet\");\nconst ContentTypes = require(\"./ContentTypes\");\nconst AppProperties = require(\"./AppProperties\");\nconst CoreProperties = require(\"./CoreProperties\");\nconst Relationships = require(\"./Relationships\");\nconst SharedStrings = require(\"./SharedStrings\");\nconst StyleSheet = require(\"./StyleSheet\");\nconst Encryptor = require(\"./Encryptor\");\nconst XmlParser = require(\"./XmlParser\");\nconst XmlBuilder = require(\"./XmlBuilder\");\nconst ArgHandler = require(\"./ArgHandler\");\nconst addressConverter = require(\"./addressConverter\");\n\n// Options for adding files to zip. Do not create folders and use a fixed time at epoch.\n// The default JSZip behavior uses current time, which causes idential workbooks to be different each time.\nconst zipFileOpts = {\n    date: new Date(0),\n    createFolders: false\n};\n\n// Initialize the parser and builder.\nconst xmlParser = new XmlParser();\nconst xmlBuilder = new XmlBuilder();\n\n// Initialize the encryptor if present (can be excluded in browser build).\nconst encryptor = typeof Encryptor === \"function\" && new Encryptor();\n\n// Characters not allowed in sheet names.\nconst badSheetNameChars = ['\\\\', '/', '*', '[', ']', ':', '?'];\n\n// Excel limits sheet names to 31 chars.\nconst maxSheetNameLength = 31;\n\n// Order of the nodes as defined by the spec.\nconst nodeOrder = [\n    \"fileVersion\", \"fileSharing\", \"workbookPr\", \"workbookProtection\", \"bookViews\", \"sheets\", \"functionGroups\",\n    \"externalReferences\", \"definedNames\", \"calcPr\", \"oleSize\", \"customWorkbookViews\", \"pivotCaches\", \"smartTagPr\",\n    \"smartTagTypes\", \"webPublishing\", \"fileRecoveryPr\", \"webPublishObjects\", \"extLst\"\n];\n\n/**\n * A workbook.\n */\nclass Workbook {\n    /**\n     * Create a new blank workbook.\n     * @returns {Promise.<Workbook>} The workbook.\n     * @ignore\n     */\n    static fromBlankAsync() {\n        return Workbook.fromDataAsync(blank);\n    }\n\n    /**\n     * Loads a workbook from a data object. (Supports any supported [JSZip data types]{@link https://stuk.github.io/jszip/documentation/api_jszip/load_async.html}.)\n     * @param {string|Array.<number>|ArrayBuffer|Uint8Array|Buffer|Blob|Promise.<*>} data - The data to load.\n     * @param {{}} [opts] - Options\n     * @returns {Promise.<Workbook>} The workbook.\n     * @ignore\n     */\n    static fromDataAsync(data, opts) {\n        return new Workbook()._initAsync(data, opts);\n    }\n\n    /**\n     * Loads a workbook from file.\n     * @param {string} path - The path to the workbook.\n     * @param {{}} [opts] - Options\n     * @returns {Promise.<Workbook>} The workbook.\n     * @ignore\n     */\n    static fromFileAsync(path, opts) {\n        if (process.browser) throw new Error(\"Workbook.fromFileAsync is not supported in the browser\");\n        return new externals.Promise((resolve, reject) => {\n            fs.readFile(path, (err, data) => {\n                if (err) return reject(err);\n                resolve(data);\n            });\n        }).then(data => Workbook.fromDataAsync(data, opts));\n    }\n\n    /**\n     * Get the active sheet in the workbook.\n     * @returns {Sheet} The active sheet.\n     *//**\n     * Set the active sheet in the workbook.\n     * @param {Sheet|string|number} sheet - The sheet or name of sheet or index of sheet to activate. The sheet must not be hidden.\n     * @returns {Workbook} The workbook.\n     */\n    activeSheet() {\n        return new ArgHandler('Workbook.activeSheet')\n            .case(() => {\n                return this._activeSheet;\n            })\n            .case('*', sheet => {\n                // Get the sheet from name/index if needed.\n                if (!(sheet instanceof Sheet)) sheet = this.sheet(sheet);\n\n                // Check if the sheet is hidden.\n                if (sheet.hidden()) throw new Error(\"You may not activate a hidden sheet.\");\n\n                // Deselect all sheets except the active one (mirroring ying Excel behavior).\n                _.forEach(this._sheets, current => {\n                    current.tabSelected(current === sheet);\n                });\n\n                this._activeSheet = sheet;\n\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Add a new sheet to the workbook.\n     * @param {string} name - The name of the sheet. Must be unique, less than 31 characters, and may not contain the following characters: \\ / * [ ] : ?\n     * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.\n     * @returns {Sheet} The new sheet.\n     */\n    addSheet(name, indexOrBeforeSheet) {\n        return this._addSheet(name, indexOrBeforeSheet);\n    }\n    \n    /**\n     * Gets a defined name scoped to the workbook.\n     * @param {string} name - The defined name.\n     * @returns {undefined|string|Cell|Range|Row|Column} What the defined name refers to or undefined if not found. Will return the string formula if not a Row, Column, Cell, or Range.\n     *//**\n     * Set a defined name scoped to the workbook.\n     * @param {string} name - The defined name.\n     * @param {string|Cell|Range|Row|Column} refersTo - What the name refers to.\n     * @returns {Workbook} The workbook.\n     */\n    definedName() {\n        return new ArgHandler(\"Workbook.definedName\")\n            .case('string', name => {\n                return this.scopedDefinedName(undefined, name);\n            })\n            .case(['string', '*'], (name, refersTo) => {\n                this.scopedDefinedName(undefined, name, refersTo);\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Delete a sheet from the workbook.\n     * @param {Sheet|string|number} sheet - The sheet or name of sheet or index of sheet to move.\n     * @returns {Workbook} The workbook.\n     */\n    deleteSheet(sheet) {\n        // Get the sheet to move.\n        if (!(sheet instanceof Sheet)) {\n            sheet = this.sheet(sheet);\n            if (!sheet) throw new Error(\"Invalid move sheet reference.\");\n        }\n\n        // Make sure we are not deleting the only visible sheet.\n        const visibleSheets = _.filter(this._sheets, sheet => !sheet.hidden());\n        if (visibleSheets.length === 1 && visibleSheets[0] === sheet) {\n            throw new Error(\"This sheet may not be deleted as a workbook must contain at least one visible sheet.\");\n        }\n\n        // Remove the sheet.\n        let index = this._sheets.indexOf(sheet);\n        this._sheets.splice(index, 1);\n\n        // Set the new active sheet.\n        if (sheet === this.activeSheet()) {\n            if (index >= this._sheets.length) index--;\n            this.activeSheet(index);\n        }\n\n        return this;\n    }\n\n    /**\n     * Find the given pattern in the workbook and optionally replace it.\n     * @param {string|RegExp} pattern - The pattern to look for. Providing a string will result in a case-insensitive substring search. Use a RegExp for more sophisticated searches.\n     * @param {string|function} [replacement] - The text to replace or a String.replace callback function. If pattern is a string, all occurrences of the pattern in each cell will be replaced.\n     * @returns {boolean} A flag indicating if the pattern was found.\n     */\n    find(pattern, replacement) {\n        pattern = regexify(pattern);\n\n        let matches = [];\n        this._sheets.forEach(sheet => {\n            matches = matches.concat(sheet.find(pattern, replacement));\n        });\n\n        return matches;\n    }\n\n    /**\n     * Move a sheet to a new position.\n     * @param {Sheet|string|number} sheet - The sheet or name of sheet or index of sheet to move.\n     * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.\n     * @returns {Workbook} The workbook.\n     */\n    moveSheet(sheet, indexOrBeforeSheet) {\n        // Get the sheet to move.\n        if (!(sheet instanceof Sheet)) {\n            sheet = this.sheet(sheet);\n            if (!sheet) throw new Error(\"Invalid move sheet reference.\");\n        }\n\n        // Get the to/from indexes.\n        const from = this._sheets.indexOf(sheet);\n        let to;\n        if (_.isNil(indexOrBeforeSheet)) {\n            to = this._sheets.length - 1;\n        } else if (_.isInteger(indexOrBeforeSheet)) {\n            to = indexOrBeforeSheet;\n        } else {\n            if (!(indexOrBeforeSheet instanceof Sheet)) {\n                indexOrBeforeSheet = this.sheet(indexOrBeforeSheet);\n                if (!indexOrBeforeSheet) throw new Error(\"Invalid before sheet reference.\");\n            }\n\n            to = this._sheets.indexOf(indexOrBeforeSheet);\n        }\n\n        // Insert the sheet at the appropriate place.\n        this._sheets.splice(to, 0, this._sheets.splice(from, 1)[0]);\n\n        return this;\n    }\n\n    /**\n     * Generates the workbook output.\n     * @param {string} [type] - The type of the data to return: base64, binarystring, uint8array, arraybuffer, blob, nodebuffer. Defaults to 'nodebuffer' in Node.js and 'blob' in browsers.\n     * @returns {Promise<string|Uint8Array|ArrayBuffer|Blob|Buffer>} The data.\n     *//**\n     * Generates the workbook output.\n     * @param {{}} [opts] Options\n     * @param {string} [opts.type] - The type of the data to return: base64, binarystring, uint8array, arraybuffer, blob, nodebuffer. Defaults to 'nodebuffer' in Node.js and 'blob' in browsers.\n     * @param {string} [opts.password] - The password to use to encrypt the workbook.\n     * @returns {Promise<string|Uint8Array|ArrayBuffer|Blob|Buffer>} The data.\n     */\n    outputAsync(opts) {\n        opts = opts || {};\n        if (typeof opts === 'string') opts = { type: opts };\n\n        this._setSheetRefs();\n\n        let definedNamesNode = xmlq.findChild(this._node, \"definedNames\");\n\n        this._sheets.forEach((sheet, i) => {\n            if (!sheet._autoFilter) return;\n\n            if (!definedNamesNode) {\n                definedNamesNode = {\n                    name: \"definedNames\",\n                    attributes: {},\n                    children: []\n                };\n\n                xmlq.insertInOrder(this._node, definedNamesNode, nodeOrder);\n            }\n\n            xmlq.appendChild(definedNamesNode, {\n                name: \"definedName\",\n                attributes: {\n                    name: \"_xlnm._FilterDatabase\",\n                    localSheetId: i,\n                    hidden: \"1\"\n                },\n                children: [sheet._autoFilter.address({ includeSheetName: true, anchored: true })]\n            });\n        });\n\n        this._sheetsNode.children = [];\n        this._sheets.forEach((sheet, i) => {\n            const sheetPath = `xl/worksheets/sheet${i + 1}.xml`;\n            const sheetRelsPath = `xl/worksheets/_rels/sheet${i + 1}.xml.rels`;\n            const sheetXmls = sheet.toXmls();\n            const relationship = this._relationships.findById(sheetXmls.id.attributes['r:id']);\n            relationship.attributes.Target = `worksheets/sheet${i + 1}.xml`;\n            this._sheetsNode.children.push(sheetXmls.id);\n            this._zip.file(sheetPath, xmlBuilder.build(sheetXmls.sheet), zipFileOpts);\n\n            const relationshipsXml = xmlBuilder.build(sheetXmls.relationships);\n            if (relationshipsXml) {\n                this._zip.file(sheetRelsPath, relationshipsXml, zipFileOpts);\n            } else {\n                this._zip.remove(sheetRelsPath);\n            }\n        });\n\n        // Set the app security to true if a password is set, false if not.\n        // this._appProperties.isSecure(!!opts.password);\n\n        // Convert the various components to XML strings and add them to the zip.\n        this._zip.file(\"[Content_Types].xml\", xmlBuilder.build(this._contentTypes), zipFileOpts);\n        this._zip.file(\"docProps/app.xml\", xmlBuilder.build(this._appProperties), zipFileOpts);\n        this._zip.file(\"docProps/core.xml\", xmlBuilder.build(this._coreProperties), zipFileOpts);\n        this._zip.file(\"xl/_rels/workbook.xml.rels\", xmlBuilder.build(this._relationships), zipFileOpts);\n        this._zip.file(\"xl/sharedStrings.xml\", xmlBuilder.build(this._sharedStrings), zipFileOpts);\n        this._zip.file(\"xl/styles.xml\", xmlBuilder.build(this._styleSheet), zipFileOpts);\n        this._zip.file(\"xl/workbook.xml\", xmlBuilder.build(this._node), zipFileOpts);\n\n        // Generate the zip.\n        return this._zip.generateAsync({\n            type: \"nodebuffer\",\n            compression: \"DEFLATE\"\n        }).then(output => {\n            // If a password is set, encrypt the workbook.\n            if (opts.password) output = encryptor.encrypt(output, opts.password);\n\n            // Convert and return\n            return this._convertBufferToOutput(output, opts.type);\n        });\n    }\n\n    /**\n     * Gets the sheet with the provided name or index (0-based).\n     * @param {string|number} sheetNameOrIndex - The sheet name or index.\n     * @returns {Sheet|undefined} The sheet or undefined if not found.\n     */\n    sheet(sheetNameOrIndex) {\n        if (_.isInteger(sheetNameOrIndex)) return this._sheets[sheetNameOrIndex];\n        return _.find(this._sheets, sheet => sheet.name() === sheetNameOrIndex);\n    }\n\n    /**\n     * Get an array of all the sheets in the workbook.\n     * @returns {Array.<Sheet>} The sheets.\n     */\n    sheets() {\n        return this._sheets.slice();\n    }\n\n    /**\n     * Gets an individual property.\n     * @param {string} name - The name of the property.\n     * @returns {*} The property.\n     *//**\n     * Gets multiple properties.\n     * @param {Array.<string>} names - The names of the properties.\n     * @returns {object.<string, *>} Object whose keys are the property names and values are the properties.\n     *//**\n     * Sets an individual property.\n     * @param {string} name - The name of the property.\n     * @param {*} value - The value to set.\n     * @returns {Workbook} The workbook.\n     *//**\n     * Sets multiple properties.\n     * @param {object.<string, *>} properties - Object whose keys are the property names and values are the values to set.\n     * @returns {Workbook} The workbook.\n     */\n    property() {\n        return new ArgHandler(\"Workbook.property\")\n            .case('string', name => {\n                // Get single value\n                return this._coreProperties.get(name);\n            })\n            .case('array', names => {\n                // Get list of values\n                const values = {};\n                names.forEach(name => {\n                    values[name] = this._coreProperties.get(name);\n                });\n\n                return values;\n            })\n            .case(['string', '*'], (name, value) => {\n                // Set a single value for all cells to a single value\n                this._coreProperties.set(name, value);\n                return this;\n            })\n            .case('object', nameValues => {\n                // Object of key value pairs to set\n                for (const name in nameValues) {\n                    if (!nameValues.hasOwnProperty(name)) continue;\n                    const value = nameValues[name];\n                    this._coreProperties.set(name, value);\n                }\n\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Get access to core properties object\n     * @returns {CoreProperties} The core properties.\n     */\n    properties() {\n        return this._coreProperties;\n    }\n\n    /**\n     * Write the workbook to file. (Not supported in browsers.)\n     * @param {string} path - The path of the file to write.\n     * @param {{}} [opts] - Options\n     * @param {string} [opts.password] - The password to encrypt the workbook.\n     * @returns {Promise.<undefined>} A promise.\n     */\n    toFileAsync(path, opts) {\n        if (process.browser) throw new Error(\"Workbook.toFileAsync is not supported in the browser.\");\n        return this.outputAsync(opts)\n            .then(data => new externals.Promise((resolve, reject) => {\n                fs.writeFile(path, data, err => {\n                    if (err) return reject(err);\n                    resolve();\n                });\n            }));\n    }\n\n    /**\n     * Gets a scoped defined name.\n     * @param {Sheet} sheetScope - The sheet the name is scoped to. Use undefined for workbook scope.\n     * @param {string} name - The defined name.\n     * @returns {undefined|Cell|Range|Row|Column} What the defined name refers to.\n     * @ignore\n     *//**\n     * Sets a scoped defined name.\n     * @param {Sheet} sheetScope - The sheet the name is scoped to. Use undefined for workbook scope.\n     * @param {string} name - The defined name.\n     * @param {undefined|Cell|Range|Row|Column} refersTo - What the defined name refers to.\n     * @returns {Workbook} The workbook.\n     * @ignore\n     */\n    scopedDefinedName(sheetScope, name, refersTo) {\n        let definedNamesNode = xmlq.findChild(this._node, \"definedNames\");\n        let definedNameNode = definedNamesNode && _.find(definedNamesNode.children, node => node.attributes.name === name && node.localSheet === sheetScope);\n\n        return new ArgHandler('Workbook.scopedDefinedName')\n            .case(['*', 'string'], () => {\n                // Get the address from the definedNames node.\n                const refersTo = definedNameNode && definedNameNode.children[0];\n                if (!refersTo) return undefined;\n\n                // Try to parse the address.\n                const ref = addressConverter.fromAddress(refersTo);\n                if (!ref) return refersTo;\n\n                // Load the appropriate selection type.\n                const sheet = this.sheet(ref.sheetName);\n                if (ref.type === 'cell') return sheet.cell(ref.rowNumber, ref.columnNumber);\n                if (ref.type === 'range') return sheet.range(ref.startRowNumber, ref.startColumnNumber, ref.endRowNumber, ref.endColumnNumber);\n                if (ref.type === 'row') return sheet.row(ref.rowNumber);\n                if (ref.type === 'column') return sheet.column(ref.columnNumber);\n                return refersTo;\n            })\n            .case(['*', 'string', 'nil'], () => {\n                if (definedNameNode) xmlq.removeChild(definedNamesNode, definedNameNode);\n                if (definedNamesNode && !definedNamesNode.children.length) xmlq.removeChild(this._node, definedNamesNode);\n                return this;\n            })\n            .case(['*', 'string', '*'], () => {\n                if (typeof refersTo !== 'string') {\n                    refersTo = refersTo.address({\n                        includeSheetName: true,\n                        anchored: true\n                    });\n                }\n\n                if (!definedNamesNode) {\n                    definedNamesNode = {\n                        name: \"definedNames\",\n                        attributes: {},\n                        children: []\n                    };\n\n                    xmlq.insertInOrder(this._node, definedNamesNode, nodeOrder);\n                }\n\n                if (!definedNameNode) {\n                    definedNameNode = {\n                        name: \"definedName\",\n                        attributes: { name },\n                        children: [refersTo]\n                    };\n\n                    if (sheetScope) definedNameNode.localSheet = sheetScope;\n\n                    xmlq.appendChild(definedNamesNode, definedNameNode);\n                }\n\n                definedNameNode.children = [refersTo];\n\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Get the shared strings table.\n     * @returns {SharedStrings} The shared strings table.\n     * @ignore\n     */\n    sharedStrings() {\n        return this._sharedStrings;\n    }\n\n    /**\n     * Get the style sheet.\n     * @returns {StyleSheet} The style sheet.\n     * @ignore\n     */\n    styleSheet() {\n        return this._styleSheet;\n    }\n\n    /**\n     * Add a new sheet to the workbook.\n     * \n     * **WARN:** this function has limits:  if you clone a sheet with some images or other things link outside the Sheet object, these things in the cloned sheet will be locked when you open in MS Excel app.\n     * @param {Sheet} from - The sheet to be cloned.\n     * @param {string} name - The name of the new sheet. Must be unique, less than 31 characters, and may not contain the following characters: \\ / * [ ] : ?\n     * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.\n     * @returns {Sheet} The new sheet.\n     */\n    cloneSheet(from, name, indexOrBeforeSheet) {\n        if (!from || !(from instanceof Sheet)) throw new Error(\"Invalid clone from.\");\n\n        return this._addSheet(name, indexOrBeforeSheet, () => {\n            const cloneXml = node => {\n                // If the node has a toXml method, call it.\n                if (node && _.isFunction(node.toXml)) node = node.toXml();\n        \n                if (typeof node === 'object') {\n                    if (node.name) {\n                        const result = {\n                            name: node.name,\n                            attributes: {},\n                            children: []\n                        };\n                        \n                        _.forOwn(node.attributes, (value, name) => {\n                            result.attributes[name] = value;\n                        }); \n                    \n                        let chld;\n                        if (node.children) { \n                            node.children.forEach(child => {\n                                chld = cloneXml(child);\n                                if (child !== null) {\n                                    result.children.push(chld);\n                                }\n                            });\n                        }\n                        return result;\n                    }\n                } else if (node !== null) {\n                    return node;\n                } \n                return null;\n            };\n\n            // clone SheetNode & relationshipNode from source\n            const fromXml = from.toXmls();\n            const sheetNode = cloneXml(fromXml.sheet);\n            const relationshipNode = cloneXml(fromXml.relationships);\n            return { sheetNode, relationshipNode };\n        });\n    }\n\n    /**\n     * Add a new sheet to the workbook.\n     * @param {string} name - The name of the sheet. Must be unique, less than 31 characters, and may not contain the following characters: \\ / * [ ] : ?\n     * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.\n     * @param {callback} [getTemplateNodes] optional callback function for template nodes\n     * @returns {Sheet} The new sheet.\n     * @private\n     */\n    _addSheet(name, indexOrBeforeSheet, getTemplateNodes) {\n        // Validate the sheet name.\n        if (!name || typeof name !== \"string\") throw new Error(\"Invalid sheet name.\");\n        if (_.some(badSheetNameChars, char => name.indexOf(char) >= 0)) throw new Error(`Sheet name may not contain any of the following characters: ${badSheetNameChars.join(\" \")}`);\n        if (name.length > maxSheetNameLength) throw new Error(`Sheet name may not be greater than ${maxSheetNameLength} characters.`);\n        if (this.sheet(name)) throw new Error(`Sheet with name \"${name}\" already exists.`);\n\n        // Get the destination index of new sheet.\n        let index;\n        if (_.isNil(indexOrBeforeSheet)) {\n            index = this._sheets.length;\n        } else if (_.isInteger(indexOrBeforeSheet)) {\n            index = indexOrBeforeSheet;\n        } else {\n            if (!(indexOrBeforeSheet instanceof Sheet)) {\n                indexOrBeforeSheet = this.sheet(indexOrBeforeSheet);\n                if (!indexOrBeforeSheet) throw new Error(\"Invalid before sheet reference.\");\n            }\n\n            index = this._sheets.indexOf(indexOrBeforeSheet);\n        }\n\n        // Add a new relationship for the new sheet and create the new sheet ID node.\n        const relationship = this._relationships.add(\"worksheet\"); // Leave target blank as it will be filled later.\n        const sheetIdNode = {\n            name: \"sheet\",\n            attributes: {\n                name,\n                sheetId: ++this._maxSheetId,\n                'r:id': relationship.attributes.Id\n            },\n            children: []\n        };\n\n        // Create the new sheet.\n        let sheet;\n        if (getTemplateNodes) {\n            const { sheetNode, relationshipNode } = getTemplateNodes();\n            sheet = new Sheet(this, sheetIdNode, sheetNode, relationshipNode);\n        } else {\n            sheet = new Sheet(this, sheetIdNode);\n        }\n\n        // Insert the sheet at the appropriate index.\n        this._sheets.splice(index, 0, sheet);\n\n        return sheet;\n    }\n\n    /**\n     * Initialize the workbook. (This is separated from the constructor to ease testing.)\n     * @param {string|ArrayBuffer|Uint8Array|Buffer|Blob} data - The data to load.\n     * @param {{}} [opts] - Options\n     * @param {boolean} [opts.base64=false] - No used unless input is a string. True if the input string is base64 encoded, false for binary.\n     * @returns {Promise.<Workbook>} The workbook.\n     * @private\n     */\n    _initAsync(data, opts) {\n        opts = opts || {};\n\n        this._maxSheetId = 0;\n        this._sheets = [];\n\n        return externals.Promise.resolve()\n            .then(() => {\n                // Make sure the input is a Buffer\n                return this._convertInputToBufferAsync(data, opts.base64)\n                    .then(buffer => {\n                        data = buffer;\n                    });\n            })\n            .then(() => {\n                if (!opts.password) return;\n                return encryptor.decryptAsync(data, opts.password)\n                    .then(decrypted => {\n                        data = decrypted;\n                    });\n            })\n            .then(() => JSZip.loadAsync(data))\n            .then(zip => {\n                this._zip = zip;\n                return this._parseNodesAsync([\n                    \"[Content_Types].xml\",\n                    \"docProps/app.xml\",\n                    \"docProps/core.xml\",\n                    \"xl/_rels/workbook.xml.rels\",\n                    \"xl/sharedStrings.xml\",\n                    \"xl/styles.xml\",\n                    \"xl/workbook.xml\"\n                ]);\n            })\n            .then(nodes => {\n                const contentTypesNode = nodes[0];\n                const appPropertiesNode = nodes[1];\n                const corePropertiesNode = nodes[2];\n                const relationshipsNode = nodes[3];\n                const sharedStringsNode = nodes[4];\n                const styleSheetNode = nodes[5];\n                const workbookNode = nodes[6];\n\n                // Load the various components.\n                this._contentTypes = new ContentTypes(contentTypesNode);\n                this._appProperties = new AppProperties(appPropertiesNode);\n                this._coreProperties = new CoreProperties(corePropertiesNode);\n                this._relationships = new Relationships(relationshipsNode);\n                this._sharedStrings = new SharedStrings(sharedStringsNode);\n                this._styleSheet = new StyleSheet(styleSheetNode);\n                this._node = workbookNode;\n\n                // Add the shared strings relationship if it doesn't exist.\n                if (!this._relationships.findByType(\"sharedStrings\")) {\n                    this._relationships.add(\"sharedStrings\", \"sharedStrings.xml\");\n                }\n\n                // Add the shared string content type if it doesn't exist.\n                if (!this._contentTypes.findByPartName(\"/xl/sharedStrings.xml\")) {\n                    this._contentTypes.add(\"/xl/sharedStrings.xml\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml\");\n                }\n\n                // Kill the calc chain. It's not required and the workbook will corrupt unless we keep it up to date.\n                this._zip.remove(\"xl/calcChain.xml\");\n\n                // Load each sheet.\n                this._sheetsNode = xmlq.findChild(this._node, \"sheets\");\n                return externals.Promise.all(_.map(this._sheetsNode.children, (sheetIdNode, i) => {\n                    if (sheetIdNode.attributes.sheetId > this._maxSheetId) this._maxSheetId = sheetIdNode.attributes.sheetId;\n\n                    return this._parseNodesAsync([`xl/worksheets/sheet${i + 1}.xml`, `xl/worksheets/_rels/sheet${i + 1}.xml.rels`])\n                        .then(nodes => {\n                            const sheetNode = nodes[0];\n                            const sheetRelationshipsNode = nodes[1];\n\n                            // Insert at position i as the promises will resolve at different times.\n                            this._sheets[i] = new Sheet(this, sheetIdNode, sheetNode, sheetRelationshipsNode);\n                        });\n                }));\n            })\n            .then(() => this._parseSheetRefs())\n            .then(() => this);\n    }\n\n    /**\n     * Parse files out of zip into XML node objects.\n     * @param {Array.<string>} names - The file names to parse.\n     * @returns {Promise.<Array.<{}>>} An array of the parsed objects.\n     * @private\n     */\n    _parseNodesAsync(names) {\n        return externals.Promise.all(_.map(names, name => this._zip.file(name)))\n            .then(files => externals.Promise.all(_.map(files, file => file && file.async(\"string\"))))\n            .then(texts => externals.Promise.all(_.map(texts, text => text && xmlParser.parseAsync(text))));\n    }\n\n    /**\n     * Parse the sheet references out so we can reorder freely.\n     * @returns {undefined}\n     * @private\n     */\n    _parseSheetRefs() {\n        // Parse the active sheet.\n        const bookViewsNode = xmlq.findChild(this._node, \"bookViews\");\n        const workbookViewNode = bookViewsNode && xmlq.findChild(bookViewsNode, \"workbookView\");\n        const activeTabId = workbookViewNode && workbookViewNode.attributes.activeTab || 0;\n        this._activeSheet = this._sheets[activeTabId];\n\n        // Set the location sheet on the defined name nodes. The defined name should point to the index of the sheet\n        // but reordering sheets messes this up. So store it on the node and we'll update the index on XML build.\n        const definedNamesNode = xmlq.findChild(this._node, \"definedNames\");\n        if (definedNamesNode) {\n            _.forEach(definedNamesNode.children, definedNameNode => {\n                if (definedNameNode.attributes.hasOwnProperty(\"localSheetId\")) {\n                    definedNameNode.localSheet = this._sheets[definedNameNode.attributes.localSheetId];\n                }\n            });\n        }\n    }\n\n    /**\n     * Set the proper sheet references in the XML.\n     * @returns {undefined}\n     * @private\n     */\n    _setSheetRefs() {\n        // Set the active sheet.\n        let bookViewsNode = xmlq.findChild(this._node, \"bookViews\");\n        if (!bookViewsNode) {\n            bookViewsNode = { name: 'bookViews', attributes: {}, children: [] };\n            xmlq.insertInOrder(this._node, bookViewsNode, nodeOrder);\n        }\n\n        let workbookViewNode = xmlq.findChild(bookViewsNode, \"workbookView\");\n        if (!workbookViewNode) {\n            workbookViewNode = { name: 'workbookView', attributes: {}, children: [] };\n            xmlq.appendChild(bookViewsNode, workbookViewNode);\n        }\n\n        workbookViewNode.attributes.activeTab = this._sheets.indexOf(this._activeSheet);\n\n        // Set the defined names local sheet indexes.\n        const definedNamesNode = xmlq.findChild(this._node, \"definedNames\");\n        if (definedNamesNode) {\n            _.forEach(definedNamesNode.children, definedNameNode => {\n                if (definedNameNode.localSheet) {\n                    definedNameNode.attributes.localSheetId = this._sheets.indexOf(definedNameNode.localSheet);\n                }\n            });\n        }\n    }\n\n    /**\n     * Convert buffer to desired output format\n     * @param {Buffer} buffer - The buffer\n     * @param {string} type - The type to convert to: buffer/nodebuffer, blob, base64, binarystring, uint8array, arraybuffer\n     * @returns {Buffer|Blob|string|Uint8Array|ArrayBuffer} The output\n     * @private\n     */\n    _convertBufferToOutput(buffer, type) {\n        if (!type) type = process.browser ? \"blob\" : \"nodebuffer\";\n\n        if (type === \"buffer\" || type === \"nodebuffer\") return buffer;\n        if (process.browser && type === \"blob\") return new Blob([buffer], { type: Workbook.MIME_TYPE });\n        if (type === \"base64\") return buffer.toString(\"base64\");\n        if (type === \"binarystring\") return buffer.toString(\"utf8\");\n        if (type === \"uint8array\") return new Uint8Array(buffer);\n        if (type === \"arraybuffer\") return new Uint8Array(buffer).buffer;\n\n        throw new Error(`Output type '${type}' not supported.`);\n    }\n\n    /**\n     * Convert input to buffer\n     * @param {Buffer|Blob|string|Uint8Array|ArrayBuffer} input - The input\n     * @param {boolean} [base64=false] - Only applies if input is a string. If true, the string is base64 encoded, false for binary\n     * @returns {Promise.<Buffer>} The buffer.\n     * @private\n     */\n    _convertInputToBufferAsync(input, base64) {\n        return externals.Promise.resolve()\n            .then(() => {\n                if (Buffer.isBuffer(input)) return input;\n\n                if (process.browser && input instanceof Blob) {\n                    return new externals.Promise(resolve => {\n                        const fileReader = new FileReader();\n                        fileReader.onload = event => {\n                            resolve(Buffer.from(event.target.result));\n                        };\n                        fileReader.readAsArrayBuffer(input);\n                    });\n                }\n\n                if (typeof input === \"string\" && base64) return Buffer.from(input, \"base64\");\n                if (typeof input === \"string\" && !base64) return Buffer.from(input, \"utf8\");\n                if (input instanceof Uint8Array || input instanceof ArrayBuffer) return Buffer.from(input);\n\n                throw new Error(`Input type unknown.`);\n            });\n    }\n}\n\n/**\n * The XLSX mime type.\n * @type {string}\n * @ignore\n */\nWorkbook.MIME_TYPE = \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\";\n\nmodule.exports = Workbook;\n\n/*\nxl/workbook.xml\n\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<workbook xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" mc:Ignorable=\"x15\" xmlns:x15=\"http://schemas.microsoft.com/office/spreadsheetml/2010/11/main\">\n\t<fileVersion appName=\"xl\" lastEdited=\"7\" lowestEdited=\"7\" rupBuild=\"16925\"/>\n\t<workbookPr defaultThemeVersion=\"164011\"/>\n\t<mc:AlternateContent xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\">\n\t\t<mc:Choice Requires=\"x15\">\n\t\t\t<x15ac:absPath url=\"\\path\\to\\file\" xmlns:x15ac=\"http://schemas.microsoft.com/office/spreadsheetml/2010/11/ac\"/>\n\t\t</mc:Choice>\n\t</mc:AlternateContent>\n\t<bookViews>\n\t\t<workbookView xWindow=\"3720\" yWindow=\"0\" windowWidth=\"27870\" windowHeight=\"12795\"/>\n\t</bookViews>\n\t<sheets>\n\t\t<sheet name=\"Sheet1\" sheetId=\"1\" r:id=\"rId1\"/>\n\t</sheets>\n\t<calcPr calcId=\"171027\"/>\n\t<extLst>\n\t\t<ext uri=\"{140A7094-0E35-4892-8432-C4D2E57EDEB5}\" xmlns:x15=\"http://schemas.microsoft.com/office/spreadsheetml/2010/11/main\">\n\t\t\t<x15:workbookPr chartTrackingRefBase=\"1\"/>\n\t\t</ext>\n\t</extLst>\n</workbook>\n// */\n"]},"metadata":{},"sourceType":"script"}