{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:/Users/tzika/Desktop/Polymerlink-Front/polymerlink-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/tzika/Desktop/Polymerlink-Front/polymerlink-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar sax = require(\"sax\");\n\nvar externals = require(\"./externals\"); // Regex to check if string is all whitespace.\n\n\nvar allWhitespaceRegex = /^\\s+$/;\n/**\n * XML parser.\n * @private\n */\n\nvar XmlParser = /*#__PURE__*/function () {\n  function XmlParser() {\n    _classCallCheck(this, XmlParser);\n  }\n\n  _createClass(XmlParser, [{\n    key: \"parseAsync\",\n    value:\n    /**\n     * Parse the XML text into a JSON object.\n     * @param {string} xmlText - The XML text.\n     * @returns {{}} The JSON object.\n     */\n    function parseAsync(xmlText) {\n      var _this = this;\n\n      return new externals.Promise(function (resolve, reject) {\n        // Create the SAX parser.\n        var parser = sax.parser(true); // Parsed is the full parsed object. Current is the current node being parsed. Stack is the current stack of\n        // nodes leading to the current one.\n\n        var parsed, current;\n        var stack = []; // On error: Reject the promise.\n\n        parser.onerror = reject; // On text nodes: If it is all whitespace, do nothing. Otherwise, try to convert to a number and add as a child.\n\n        parser.ontext = function (text) {\n          if (allWhitespaceRegex.test(text)) {\n            if (current && current.attributes['xml:space'] === 'preserve') {\n              current.children.push(text);\n            }\n          } else {\n            current.children.push(_this._covertToNumberIfNumber(text));\n          }\n        }; // On open tag start: Create a child element. If this is the root element, set it as parsed. Otherwise, add\n        // it as a child to the current node.\n\n\n        parser.onopentagstart = function (node) {\n          var child = {\n            name: node.name,\n            attributes: {},\n            children: []\n          };\n\n          if (current) {\n            current.children.push(child);\n          } else {\n            parsed = child;\n          }\n\n          stack.push(child);\n          current = child;\n        }; // On close tag: Pop the stack.\n\n\n        parser.onclosetag = function (node) {\n          stack.pop();\n          current = stack[stack.length - 1];\n        }; // On attribute: Try to convert the value to a number and add to the current node.\n\n\n        parser.onattribute = function (attribute) {\n          current.attributes[attribute.name] = _this._covertToNumberIfNumber(attribute.value);\n        }; // On end: Resolve the promise.\n\n\n        parser.onend = function () {\n          return resolve(parsed);\n        }; // Start parsing the text.\n\n\n        parser.write(xmlText).close();\n      });\n    }\n    /**\n     * Convert the string to a number if it looks like one.\n     * @param {string} str - The string to convert.\n     * @returns {string|number} The number if converted or the string if not.\n     * @private\n     */\n\n  }, {\n    key: \"_covertToNumberIfNumber\",\n    value: function _covertToNumberIfNumber(str) {\n      var num = Number(str);\n      return num.toString() === str ? num : str;\n    }\n  }]);\n\n  return XmlParser;\n}();\n\nmodule.exports = XmlParser;","map":{"version":3,"sources":["C:/Users/tzika/Desktop/Polymerlink-Front/polymerlink-2/node_modules/xlsx-populate/lib/XmlParser.js"],"names":["sax","require","externals","allWhitespaceRegex","XmlParser","xmlText","Promise","resolve","reject","parser","parsed","current","stack","onerror","ontext","text","test","attributes","children","push","_covertToNumberIfNumber","onopentagstart","node","child","name","onclosetag","pop","length","onattribute","attribute","value","onend","write","close","str","num","Number","toString","module","exports"],"mappings":"AAAA;;;;;;AAEA,IAAMA,GAAG,GAAGC,OAAO,CAAC,KAAD,CAAnB;;AACA,IAAMC,SAAS,GAAGD,OAAO,CAAC,aAAD,CAAzB,C,CAEA;;;AACA,IAAME,kBAAkB,GAAG,OAA3B;AAEA;AACA;AACA;AACA;;IACMC,S;;;;;;;;AACF;AACJ;AACA;AACA;AACA;AACI,wBAAWC,OAAX,EAAoB;AAAA;;AAChB,aAAO,IAAIH,SAAS,CAACI,OAAd,CAAsB,UAACC,OAAD,EAAUC,MAAV,EAAqB;AAC9C;AACA,YAAMC,MAAM,GAAGT,GAAG,CAACS,MAAJ,CAAW,IAAX,CAAf,CAF8C,CAI9C;AACA;;AACA,YAAIC,MAAJ,EAAYC,OAAZ;AACA,YAAMC,KAAK,GAAG,EAAd,CAP8C,CAS9C;;AACAH,QAAAA,MAAM,CAACI,OAAP,GAAiBL,MAAjB,CAV8C,CAY9C;;AACAC,QAAAA,MAAM,CAACK,MAAP,GAAgB,UAAAC,IAAI,EAAI;AACpB,cAAIZ,kBAAkB,CAACa,IAAnB,CAAwBD,IAAxB,CAAJ,EAAmC;AAC/B,gBAAIJ,OAAO,IAAIA,OAAO,CAACM,UAAR,CAAmB,WAAnB,MAAoC,UAAnD,EAA+D;AAC3DN,cAAAA,OAAO,CAACO,QAAR,CAAiBC,IAAjB,CAAsBJ,IAAtB;AACH;AACJ,WAJD,MAIO;AACHJ,YAAAA,OAAO,CAACO,QAAR,CAAiBC,IAAjB,CAAsB,KAAI,CAACC,uBAAL,CAA6BL,IAA7B,CAAtB;AACH;AACJ,SARD,CAb8C,CAuB9C;AACA;;;AACAN,QAAAA,MAAM,CAACY,cAAP,GAAwB,UAAAC,IAAI,EAAI;AAC5B,cAAMC,KAAK,GAAG;AAAEC,YAAAA,IAAI,EAAEF,IAAI,CAACE,IAAb;AAAmBP,YAAAA,UAAU,EAAE,EAA/B;AAAmCC,YAAAA,QAAQ,EAAE;AAA7C,WAAd;;AACA,cAAIP,OAAJ,EAAa;AACTA,YAAAA,OAAO,CAACO,QAAR,CAAiBC,IAAjB,CAAsBI,KAAtB;AACH,WAFD,MAEO;AACHb,YAAAA,MAAM,GAAGa,KAAT;AACH;;AAEDX,UAAAA,KAAK,CAACO,IAAN,CAAWI,KAAX;AACAZ,UAAAA,OAAO,GAAGY,KAAV;AACH,SAVD,CAzB8C,CAqC9C;;;AACAd,QAAAA,MAAM,CAACgB,UAAP,GAAoB,UAAAH,IAAI,EAAI;AACxBV,UAAAA,KAAK,CAACc,GAAN;AACAf,UAAAA,OAAO,GAAGC,KAAK,CAACA,KAAK,CAACe,MAAN,GAAe,CAAhB,CAAf;AACH,SAHD,CAtC8C,CA2C9C;;;AACAlB,QAAAA,MAAM,CAACmB,WAAP,GAAqB,UAAAC,SAAS,EAAI;AAC9BlB,UAAAA,OAAO,CAACM,UAAR,CAAmBY,SAAS,CAACL,IAA7B,IAAqC,KAAI,CAACJ,uBAAL,CAA6BS,SAAS,CAACC,KAAvC,CAArC;AACH,SAFD,CA5C8C,CAgD9C;;;AACArB,QAAAA,MAAM,CAACsB,KAAP,GAAe;AAAA,iBAAMxB,OAAO,CAACG,MAAD,CAAb;AAAA,SAAf,CAjD8C,CAmD9C;;;AACAD,QAAAA,MAAM,CAACuB,KAAP,CAAa3B,OAAb,EAAsB4B,KAAtB;AACH,OArDM,CAAP;AAsDH;AAED;AACJ;AACA;AACA;AACA;AACA;;;;WACI,iCAAwBC,GAAxB,EAA6B;AACzB,UAAMC,GAAG,GAAGC,MAAM,CAACF,GAAD,CAAlB;AACA,aAAOC,GAAG,CAACE,QAAJ,OAAmBH,GAAnB,GAAyBC,GAAzB,GAA+BD,GAAtC;AACH;;;;;;AAGLI,MAAM,CAACC,OAAP,GAAiBnC,SAAjB","sourcesContent":["\"use strict\";\n\nconst sax = require(\"sax\");\nconst externals = require(\"./externals\");\n\n// Regex to check if string is all whitespace.\nconst allWhitespaceRegex = /^\\s+$/;\n\n/**\n * XML parser.\n * @private\n */\nclass XmlParser {\n    /**\n     * Parse the XML text into a JSON object.\n     * @param {string} xmlText - The XML text.\n     * @returns {{}} The JSON object.\n     */\n    parseAsync(xmlText) {\n        return new externals.Promise((resolve, reject) => {\n            // Create the SAX parser.\n            const parser = sax.parser(true);\n\n            // Parsed is the full parsed object. Current is the current node being parsed. Stack is the current stack of\n            // nodes leading to the current one.\n            let parsed, current;\n            const stack = [];\n\n            // On error: Reject the promise.\n            parser.onerror = reject;\n\n            // On text nodes: If it is all whitespace, do nothing. Otherwise, try to convert to a number and add as a child.\n            parser.ontext = text => {\n                if (allWhitespaceRegex.test(text)) {\n                    if (current && current.attributes['xml:space'] === 'preserve') {\n                        current.children.push(text);\n                    }\n                } else {\n                    current.children.push(this._covertToNumberIfNumber(text));\n                }\n            };\n\n            // On open tag start: Create a child element. If this is the root element, set it as parsed. Otherwise, add\n            // it as a child to the current node.\n            parser.onopentagstart = node => {\n                const child = { name: node.name, attributes: {}, children: [] };\n                if (current) {\n                    current.children.push(child);\n                } else {\n                    parsed = child;\n                }\n\n                stack.push(child);\n                current = child;\n            };\n\n            // On close tag: Pop the stack.\n            parser.onclosetag = node => {\n                stack.pop();\n                current = stack[stack.length - 1];\n            };\n\n            // On attribute: Try to convert the value to a number and add to the current node.\n            parser.onattribute = attribute => {\n                current.attributes[attribute.name] = this._covertToNumberIfNumber(attribute.value);\n            };\n\n            // On end: Resolve the promise.\n            parser.onend = () => resolve(parsed);\n\n            // Start parsing the text.\n            parser.write(xmlText).close();\n        });\n    }\n\n    /**\n     * Convert the string to a number if it looks like one.\n     * @param {string} str - The string to convert.\n     * @returns {string|number} The number if converted or the string if not.\n     * @private\n     */\n    _covertToNumberIfNumber(str) {\n        const num = Number(str);\n        return num.toString() === str ? num : str;\n    }\n}\n\nmodule.exports = XmlParser;\n"]},"metadata":{},"sourceType":"script"}