{"ast":null,"code":"\"use strict\";\n/**\n * OOXML uses the CFB file format with Agile Encryption. The details of the encryption are here:\n * https://msdn.microsoft.com/en-us/library/dd950165(v=office.12).aspx\n *\n * Helpful guidance also take from this Github project:\n * https://github.com/nolze/ms-offcrypto-tool\n */\n\nvar _classCallCheck = require(\"C:/Users/tzika/Desktop/Polymerlink-Front/polymerlink-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/tzika/Desktop/Polymerlink-Front/polymerlink-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _ = require(\"lodash\");\n\nvar cfb = require(\"cfb\");\n\nvar crypto = require(\"crypto\");\n\nvar externals = require(\"./externals\");\n\nvar XmlParser = require(\"./XmlParser\");\n\nvar XmlBuilder = require(\"./XmlBuilder\");\n\nvar xmlq = require(\"./xmlq\");\n\nvar ENCRYPTION_INFO_PREFIX = Buffer.from([0x04, 0x00, 0x04, 0x00, 0x40, 0x00, 0x00, 0x00]); // First 4 bytes are the version number, second 4 bytes are reserved.\n\nvar PACKAGE_ENCRYPTION_CHUNK_SIZE = 4096;\nvar PACKAGE_OFFSET = 8; // First 8 bytes are the size of the stream\n// Block keys used for encryption\n\nvar BLOCK_KEYS = {\n  dataIntegrity: {\n    hmacKey: Buffer.from([0x5f, 0xb2, 0xad, 0x01, 0x0c, 0xb9, 0xe1, 0xf6]),\n    hmacValue: Buffer.from([0xa0, 0x67, 0x7f, 0x02, 0xb2, 0x2c, 0x84, 0x33])\n  },\n  key: Buffer.from([0x14, 0x6e, 0x0b, 0xe7, 0xab, 0xac, 0xd0, 0xd6]),\n  verifierHash: {\n    input: Buffer.from([0xfe, 0xa7, 0xd2, 0x76, 0x3b, 0x4b, 0x9e, 0x79]),\n    value: Buffer.from([0xd7, 0xaa, 0x0f, 0x6d, 0x30, 0x61, 0x34, 0x4e])\n  }\n};\n/**\n * Encrypts/decrypts XLSXs.\n * @private\n */\n\nvar Encryptor = /*#__PURE__*/function () {\n  function Encryptor() {\n    _classCallCheck(this, Encryptor);\n  }\n\n  _createClass(Encryptor, [{\n    key: \"encrypt\",\n    value:\n    /**\n     * Encrypt the data with the password.\n     * @param {Buffer} data - The data to encrypt\n     * @param {string} password - The password\n     * @returns {Buffer} The encrypted data\n     */\n    function encrypt(data, password) {\n      // Generate a random key to use to encrypt the document. Excel uses 32 bytes. We'll use the password to encrypt this key.\n      // N.B. The number of bits needs to correspond to an algorithm available in crypto (e.g. aes-256-cbc).\n      var packageKey = crypto.randomBytes(32); // Create the encryption info. We'll use this for all of the encryption operations and for building the encryption info XML entry\n\n      var encryptionInfo = {\n        package: {\n          // Info on the encryption of the package.\n          cipherAlgorithm: 'AES',\n          // Cipher algorithm to use. Excel uses AES.\n          cipherChaining: 'ChainingModeCBC',\n          // Cipher chaining mode to use. Excel uses CBC.\n          saltValue: crypto.randomBytes(16),\n          // Random value to use as encryption salt. Excel uses 16 bytes.\n          hashAlgorithm: 'SHA512',\n          // Hash algorithm to use. Excel uses SHA512.\n          hashSize: 64,\n          // The size of the hash in bytes. SHA512 results in 64-byte hashes\n          blockSize: 16,\n          // The number of bytes used to encrypt one block of data. It MUST be at least 2, no greater than 4096, and a multiple of 2. Excel uses 16\n          keyBits: packageKey.length * 8 // The number of bits in the package key.\n\n        },\n        key: {\n          // Info on the encryption of the package key.\n          cipherAlgorithm: 'AES',\n          // Cipher algorithm to use. Excel uses AES.\n          cipherChaining: 'ChainingModeCBC',\n          // Cipher chaining mode to use. Excel uses CBC.\n          saltValue: crypto.randomBytes(16),\n          // Random value to use as encryption salt. Excel uses 16 bytes.\n          hashAlgorithm: 'SHA512',\n          // Hash algorithm to use. Excel uses SHA512.\n          hashSize: 64,\n          // The size of the hash in bytes. SHA512 results in 64-byte hashes\n          blockSize: 16,\n          // The number of bytes used to encrypt one block of data. It MUST be at least 2, no greater than 4096, and a multiple of 2. Excel uses 16\n          spinCount: 100000,\n          // The number of times to iterate on a hash of a password. It MUST NOT be greater than 10,000,000. Excel uses 100,000.\n          keyBits: 256 // The length of the key to generate from the password. Must be a multiple of 8. Excel uses 256.\n\n        }\n      };\n      /* Package Encryption */\n      // Encrypt package using the package key.\n\n      var encryptedPackage = this._cryptPackage(true, encryptionInfo.package.cipherAlgorithm, encryptionInfo.package.cipherChaining, encryptionInfo.package.hashAlgorithm, encryptionInfo.package.blockSize, encryptionInfo.package.saltValue, packageKey, data);\n      /* Data Integrity */\n      // Create the data integrity fields used by clients for integrity checks.\n      // First generate a random array of bytes to use in HMAC. The docs say to use the same length as the key salt, but Excel seems to use 64.\n\n\n      var hmacKey = crypto.randomBytes(64); // Then create an initialization vector using the package encryption info and the appropriate block key.\n\n      var hmacKeyIV = this._createIV(encryptionInfo.package.hashAlgorithm, encryptionInfo.package.saltValue, encryptionInfo.package.blockSize, BLOCK_KEYS.dataIntegrity.hmacKey); // Use the package key and the IV to encrypt the HMAC key\n\n\n      var encryptedHmacKey = this._crypt(true, encryptionInfo.package.cipherAlgorithm, encryptionInfo.package.cipherChaining, packageKey, hmacKeyIV, hmacKey); // Now create the HMAC\n\n\n      var hmacValue = this._hmac(encryptionInfo.package.hashAlgorithm, hmacKey, encryptedPackage); // Next generate an initialization vector for encrypting the resulting HMAC value.\n\n\n      var hmacValueIV = this._createIV(encryptionInfo.package.hashAlgorithm, encryptionInfo.package.saltValue, encryptionInfo.package.blockSize, BLOCK_KEYS.dataIntegrity.hmacValue); // Now encrypt the value\n\n\n      var encryptedHmacValue = this._crypt(true, encryptionInfo.package.cipherAlgorithm, encryptionInfo.package.cipherChaining, packageKey, hmacValueIV, hmacValue); // Put the encrypted key and value on the encryption info\n\n\n      encryptionInfo.dataIntegrity = {\n        encryptedHmacKey: encryptedHmacKey,\n        encryptedHmacValue: encryptedHmacValue\n      };\n      /* Key Encryption */\n      // Convert the password to an encryption key\n\n      var key = this._convertPasswordToKey(password, encryptionInfo.key.hashAlgorithm, encryptionInfo.key.saltValue, encryptionInfo.key.spinCount, encryptionInfo.key.keyBits, BLOCK_KEYS.key); // Encrypt the package key with the\n\n\n      encryptionInfo.key.encryptedKeyValue = this._crypt(true, encryptionInfo.key.cipherAlgorithm, encryptionInfo.key.cipherChaining, key, encryptionInfo.key.saltValue, packageKey);\n      /* Verifier hash */\n      // Create a random byte array for hashing\n\n      var verifierHashInput = crypto.randomBytes(16); // Create an encryption key from the password for the input\n\n      var verifierHashInputKey = this._convertPasswordToKey(password, encryptionInfo.key.hashAlgorithm, encryptionInfo.key.saltValue, encryptionInfo.key.spinCount, encryptionInfo.key.keyBits, BLOCK_KEYS.verifierHash.input); // Use the key to encrypt the verifier input\n\n\n      encryptionInfo.key.encryptedVerifierHashInput = this._crypt(true, encryptionInfo.key.cipherAlgorithm, encryptionInfo.key.cipherChaining, verifierHashInputKey, encryptionInfo.key.saltValue, verifierHashInput); // Create a hash of the input\n\n      var verifierHashValue = this._hash(encryptionInfo.key.hashAlgorithm, verifierHashInput); // Create an encryption key from the password for the hash\n\n\n      var verifierHashValueKey = this._convertPasswordToKey(password, encryptionInfo.key.hashAlgorithm, encryptionInfo.key.saltValue, encryptionInfo.key.spinCount, encryptionInfo.key.keyBits, BLOCK_KEYS.verifierHash.value); // Use the key to encrypt the hash value\n\n\n      encryptionInfo.key.encryptedVerifierHashValue = this._crypt(true, encryptionInfo.key.cipherAlgorithm, encryptionInfo.key.cipherChaining, verifierHashValueKey, encryptionInfo.key.saltValue, verifierHashValue); // Build the encryption info buffer\n\n      var encryptionInfoBuffer = this._buildEncryptionInfo(encryptionInfo); // Create a new CFB\n\n\n      var output = cfb.utils.cfb_new(); // Add the encryption info and encrypted package\n\n      cfb.utils.cfb_add(output, \"EncryptionInfo\", encryptionInfoBuffer);\n      cfb.utils.cfb_add(output, \"EncryptedPackage\", encryptedPackage); // Delete the SheetJS entry that is added at initialization\n\n      cfb.utils.cfb_del(output, \"\\x01Sh33tJ5\"); // Write to a buffer and return\n\n      output = cfb.write(output); // The cfb library writes to a Uint8array in the browser. Convert to a Buffer.\n\n      if (!Buffer.isBuffer(output)) output = Buffer.from(output);\n      return output;\n    }\n    /**\n     * Decrypt the data with the given password\n     * @param {Buffer} data - The data to decrypt\n     * @param {string} password - The password\n     * @returns {Promise.<Buffer>} The decrypted data\n     */\n\n  }, {\n    key: \"decryptAsync\",\n    value: function decryptAsync(data, password) {\n      var _this = this;\n\n      // Parse the CFB input and pull out the encryption info and encrypted package entries.\n      var parsed = cfb.parse(data);\n\n      var encryptionInfoBuffer = _.find(parsed.FileIndex, {\n        name: \"EncryptionInfo\"\n      }).content;\n\n      var encryptedPackageBuffer = _.find(parsed.FileIndex, {\n        name: \"EncryptedPackage\"\n      }).content; // In the browser the CFB content is an array. Convert to a Buffer.\n\n\n      if (!Buffer.isBuffer(encryptionInfoBuffer)) encryptionInfoBuffer = Buffer.from(encryptionInfoBuffer);\n      if (!Buffer.isBuffer(encryptedPackageBuffer)) encryptedPackageBuffer = Buffer.from(encryptedPackageBuffer);\n      return externals.Promise.resolve().then(function () {\n        return _this._parseEncryptionInfoAsync(encryptionInfoBuffer);\n      }) // Parse the encryption info XML into an object\n      .then(function (encryptionInfo) {\n        // Convert the password into an encryption key\n        var key = _this._convertPasswordToKey(password, encryptionInfo.key.hashAlgorithm, encryptionInfo.key.saltValue, encryptionInfo.key.spinCount, encryptionInfo.key.keyBits, BLOCK_KEYS.key); // Use the key to decrypt the package key\n\n\n        var packageKey = _this._crypt(false, encryptionInfo.key.cipherAlgorithm, encryptionInfo.key.cipherChaining, key, encryptionInfo.key.saltValue, encryptionInfo.key.encryptedKeyValue); // Use the package key to decrypt the package\n\n\n        return _this._cryptPackage(false, encryptionInfo.package.cipherAlgorithm, encryptionInfo.package.cipherChaining, encryptionInfo.package.hashAlgorithm, encryptionInfo.package.blockSize, encryptionInfo.package.saltValue, packageKey, encryptedPackageBuffer);\n      });\n    }\n    /**\n     * Build the encryption info XML/buffer\n     * @param {{}} encryptionInfo - The encryption info object\n     * @returns {Buffer} The buffer\n     * @private\n     */\n\n  }, {\n    key: \"_buildEncryptionInfo\",\n    value: function _buildEncryptionInfo(encryptionInfo) {\n      // Map the object into the appropriate XML structure. Buffers are encoded in base 64.\n      var encryptionInfoNode = {\n        name: \"encryption\",\n        attributes: {\n          xmlns: \"http://schemas.microsoft.com/office/2006/encryption\",\n          'xmlns:p': \"http://schemas.microsoft.com/office/2006/keyEncryptor/password\",\n          'xmlns:c': \"http://schemas.microsoft.com/office/2006/keyEncryptor/certificate\"\n        },\n        children: [{\n          name: \"keyData\",\n          attributes: {\n            saltSize: encryptionInfo.package.saltValue.length,\n            blockSize: encryptionInfo.package.blockSize,\n            keyBits: encryptionInfo.package.keyBits,\n            hashSize: encryptionInfo.package.hashSize,\n            cipherAlgorithm: encryptionInfo.package.cipherAlgorithm,\n            cipherChaining: encryptionInfo.package.cipherChaining,\n            hashAlgorithm: encryptionInfo.package.hashAlgorithm,\n            saltValue: encryptionInfo.package.saltValue.toString(\"base64\")\n          }\n        }, {\n          name: \"dataIntegrity\",\n          attributes: {\n            encryptedHmacKey: encryptionInfo.dataIntegrity.encryptedHmacKey.toString(\"base64\"),\n            encryptedHmacValue: encryptionInfo.dataIntegrity.encryptedHmacValue.toString(\"base64\")\n          }\n        }, {\n          name: \"keyEncryptors\",\n          children: [{\n            name: \"keyEncryptor\",\n            attributes: {\n              uri: \"http://schemas.microsoft.com/office/2006/keyEncryptor/password\"\n            },\n            children: [{\n              name: \"p:encryptedKey\",\n              attributes: {\n                spinCount: encryptionInfo.key.spinCount,\n                saltSize: encryptionInfo.key.saltValue.length,\n                blockSize: encryptionInfo.key.blockSize,\n                keyBits: encryptionInfo.key.keyBits,\n                hashSize: encryptionInfo.key.hashSize,\n                cipherAlgorithm: encryptionInfo.key.cipherAlgorithm,\n                cipherChaining: encryptionInfo.key.cipherChaining,\n                hashAlgorithm: encryptionInfo.key.hashAlgorithm,\n                saltValue: encryptionInfo.key.saltValue.toString(\"base64\"),\n                encryptedVerifierHashInput: encryptionInfo.key.encryptedVerifierHashInput.toString(\"base64\"),\n                encryptedVerifierHashValue: encryptionInfo.key.encryptedVerifierHashValue.toString(\"base64\"),\n                encryptedKeyValue: encryptionInfo.key.encryptedKeyValue.toString(\"base64\")\n              }\n            }]\n          }]\n        }]\n      }; // Convert to an XML string\n\n      var xmlBuilder = new XmlBuilder();\n      var encryptionInfoXml = xmlBuilder.build(encryptionInfoNode); // Convert to a buffer and prefix with the appropriate bytes\n\n      return Buffer.concat([ENCRYPTION_INFO_PREFIX, Buffer.from(encryptionInfoXml, \"utf8\")]);\n    }\n    /**\n     * Parse the encryption info from the XML/buffer\n     * @param {Buffer} buffer - The buffer\n     * @returns {Promise.<{}>} The parsed encryption info object\n     * @private\n     */\n\n  }, {\n    key: \"_parseEncryptionInfoAsync\",\n    value: function _parseEncryptionInfoAsync(buffer) {\n      // Pull off the prefix and convert to string\n      var xml = buffer.slice(ENCRYPTION_INFO_PREFIX.length).toString(\"utf8\"); // Parse the XML\n\n      var xmlParser = new XmlParser();\n      return xmlParser.parseAsync(xml).then(function (doc) {\n        // Pull out the relevant values for decryption and return\n        var keyDataNode = xmlq.findChild(doc, \"keyData\");\n        var keyEncryptorsNode = xmlq.findChild(doc, \"keyEncryptors\");\n        var keyEncryptorNode = xmlq.findChild(keyEncryptorsNode, \"keyEncryptor\");\n        var encryptedKeyNode = xmlq.findChild(keyEncryptorNode, \"p:encryptedKey\");\n        return {\n          package: {\n            cipherAlgorithm: keyDataNode.attributes.cipherAlgorithm,\n            cipherChaining: keyDataNode.attributes.cipherChaining,\n            saltValue: Buffer.from(keyDataNode.attributes.saltValue, \"base64\"),\n            hashAlgorithm: keyDataNode.attributes.hashAlgorithm,\n            blockSize: keyDataNode.attributes.blockSize\n          },\n          key: {\n            encryptedKeyValue: Buffer.from(encryptedKeyNode.attributes.encryptedKeyValue, \"base64\"),\n            cipherAlgorithm: encryptedKeyNode.attributes.cipherAlgorithm,\n            cipherChaining: encryptedKeyNode.attributes.cipherChaining,\n            saltValue: Buffer.from(encryptedKeyNode.attributes.saltValue, \"base64\"),\n            hashAlgorithm: encryptedKeyNode.attributes.hashAlgorithm,\n            spinCount: encryptedKeyNode.attributes.spinCount,\n            keyBits: encryptedKeyNode.attributes.keyBits\n          }\n        };\n      });\n    }\n    /**\n     * Calculate a hash of the concatenated buffers with the given algorithm.\n     * @param {string} algorithm - The hash algorithm.\n     * @param {Array.<Buffer>} buffers - The buffers to concat and hash\n     * @returns {Buffer} The hash\n     * @private\n     */\n\n  }, {\n    key: \"_hash\",\n    value: function _hash(algorithm) {\n      algorithm = algorithm.toLowerCase();\n      var hashes = crypto.getHashes();\n      if (hashes.indexOf(algorithm) < 0) throw new Error(\"Hash algorithm '\".concat(algorithm, \"' not supported!\"));\n      var hash = crypto.createHash(algorithm);\n\n      for (var _len = arguments.length, buffers = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        buffers[_key - 1] = arguments[_key];\n      }\n\n      hash.update(Buffer.concat(buffers));\n      return hash.digest();\n    }\n    /**\n     * Calculate an HMAC of the concatenated buffers with the given algorithm and key\n     * @param {string} algorithm - The algorithm.\n     * @param {string} key - The key\n     * @param {Array.<Buffer>} buffers - The buffer to concat and HMAC\n     * @returns {Buffer} The HMAC\n     * @private\n     */\n\n  }, {\n    key: \"_hmac\",\n    value: function _hmac(algorithm, key) {\n      algorithm = algorithm.toLowerCase();\n      var hashes = crypto.getHashes();\n      if (hashes.indexOf(algorithm) < 0) throw new Error(\"HMAC algorithm '\".concat(algorithm, \"' not supported!\"));\n      var hmac = crypto.createHmac(algorithm, key);\n\n      for (var _len2 = arguments.length, buffers = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        buffers[_key2 - 2] = arguments[_key2];\n      }\n\n      hmac.update(Buffer.concat(buffers));\n      return hmac.digest();\n    }\n    /**\n     * Encrypt/decrypt input\n     * @param {boolean} encrypt - True to encrypt, false to decrypt\n     * @param {string} cipherAlgorithm - The cipher algorithm\n     * @param {sring} cipherChaining - The cipher chaining mode\n     * @param {Buffer} key - The encryption key\n     * @param {Buffer} iv - The initialization vector\n     * @param {Buffer} input - The input\n     * @returns {Buffer} The output\n     * @private\n     */\n\n  }, {\n    key: \"_crypt\",\n    value: function _crypt(encrypt, cipherAlgorithm, cipherChaining, key, iv, input) {\n      var algorithm = \"\".concat(cipherAlgorithm.toLowerCase(), \"-\").concat(key.length * 8);\n      if (cipherChaining === 'ChainingModeCBC') algorithm += '-cbc';else throw new Error(\"Unknown cipher chaining: \".concat(cipherChaining));\n      var cipher = crypto[encrypt ? 'createCipheriv' : 'createDecipheriv'](algorithm, key, iv);\n      cipher.setAutoPadding(false);\n      var output = cipher.update(input);\n      output = Buffer.concat([output, cipher.final()]);\n      return output;\n    }\n    /**\n     * Encrypt/decrypt the package\n     * @param {boolean} encrypt - True to encrypt, false to decrypt\n     * @param {string} cipherAlgorithm - The cipher algorithm\n     * @param {string} cipherChaining - The cipher chaining mode\n     * @param {string} hashAlgorithm - The hash algorithm\n     * @param {number} blockSize - The IV block size\n     * @param {Buffer} saltValue - The salt\n     * @param {Buffer} key - The encryption key\n     * @param {Buffer} input - The package input\n     * @returns {Buffer} The output\n     * @private\n     */\n\n  }, {\n    key: \"_cryptPackage\",\n    value: function _cryptPackage(encrypt, cipherAlgorithm, cipherChaining, hashAlgorithm, blockSize, saltValue, key, input) {\n      // The first 8 bytes is supposed to be the length, but it seems like it is really the length - 4..\n      var outputChunks = [];\n      var offset = encrypt ? 0 : PACKAGE_OFFSET; // The package is encoded in chunks. Encrypt/decrypt each and concat.\n\n      var i = 0,\n          start = 0,\n          end = 0;\n\n      while (end < input.length) {\n        start = end;\n        end = start + PACKAGE_ENCRYPTION_CHUNK_SIZE;\n        if (end > input.length) end = input.length; // Grab the next chunk\n\n        var inputChunk = input.slice(start + offset, end + offset); // Pad the chunk if it is not an integer multiple of the block size\n\n        var remainder = inputChunk.length % blockSize;\n        if (remainder) inputChunk = Buffer.concat([inputChunk, Buffer.alloc(blockSize - remainder)]); // Create the initialization vector\n\n        var iv = this._createIV(hashAlgorithm, saltValue, blockSize, i); // Encrypt/decrypt the chunk and add it to the array\n\n\n        var outputChunk = this._crypt(encrypt, cipherAlgorithm, cipherChaining, key, iv, inputChunk);\n\n        outputChunks.push(outputChunk);\n        i++;\n      } // Concat all of the output chunks.\n\n\n      var output = Buffer.concat(outputChunks);\n\n      if (encrypt) {\n        // Put the length of the package in the first 8 bytes\n        output = Buffer.concat([this._createUInt32LEBuffer(input.length, PACKAGE_OFFSET), output]);\n      } else {\n        // Truncate the buffer to the size in the prefix\n        var length = input.readUInt32LE(0);\n        output = output.slice(0, length);\n      }\n\n      return output;\n    }\n    /**\n     * Create a buffer of an integer encoded as a uint32le\n     * @param {number} value - The integer to encode\n     * @param {number} [bufferSize=4] The output buffer size in bytes\n     * @returns {Buffer} The buffer\n     * @private\n     */\n\n  }, {\n    key: \"_createUInt32LEBuffer\",\n    value: function _createUInt32LEBuffer(value) {\n      var bufferSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;\n      var buffer = Buffer.alloc(bufferSize);\n      buffer.writeUInt32LE(value, 0);\n      return buffer;\n    }\n    /**\n     * Convert a password into an encryption key\n     * @param {string} password - The password\n     * @param {string} hashAlgorithm - The hash algoritm\n     * @param {Buffer} saltValue - The salt value\n     * @param {number} spinCount - The spin count\n     * @param {number} keyBits - The length of the key in bits\n     * @param {Buffer} blockKey - The block key\n     * @returns {Buffer} The encryption key\n     * @private\n     */\n\n  }, {\n    key: \"_convertPasswordToKey\",\n    value: function _convertPasswordToKey(password, hashAlgorithm, saltValue, spinCount, keyBits, blockKey) {\n      // Password must be in unicode buffer\n      var passwordBuffer = Buffer.from(password, 'utf16le'); // Generate the initial hash\n\n      var key = this._hash(hashAlgorithm, saltValue, passwordBuffer); // Now regenerate until spin count\n\n\n      for (var i = 0; i < spinCount; i++) {\n        var iterator = this._createUInt32LEBuffer(i);\n\n        key = this._hash(hashAlgorithm, iterator, key);\n      } // Now generate the final hash\n\n\n      key = this._hash(hashAlgorithm, key, blockKey); // Truncate or pad as needed to get to length of keyBits\n\n      var keyBytes = keyBits / 8;\n\n      if (key.length < keyBytes) {\n        var tmp = Buffer.alloc(keyBytes, 0x36);\n        key.copy(tmp);\n        key = tmp;\n      } else if (key.length > keyBytes) {\n        key = key.slice(0, keyBytes);\n      }\n\n      return key;\n    }\n    /**\n     * Create an initialization vector (IV)\n     * @param {string} hashAlgorithm - The hash algorithm\n     * @param {Buffer} saltValue - The salt value\n     * @param {number} blockSize - The size of the IV\n     * @param {Buffer|number} blockKey - The block key or an int to convert to a buffer\n     * @returns {Buffer} The IV\n     * @private\n     */\n\n  }, {\n    key: \"_createIV\",\n    value: function _createIV(hashAlgorithm, saltValue, blockSize, blockKey) {\n      // Create the block key from the current index\n      if (typeof blockKey === \"number\") blockKey = this._createUInt32LEBuffer(blockKey); // Create the initialization vector by hashing the salt with the block key.\n      // Truncate or pad as needed to meet the block size.\n\n      var iv = this._hash(hashAlgorithm, saltValue, blockKey);\n\n      if (iv.length < blockSize) {\n        var tmp = Buffer.alloc(blockSize, 0x36);\n        iv.copy(tmp);\n        iv = tmp;\n      } else if (iv.length > blockSize) {\n        iv = iv.slice(0, blockSize);\n      }\n\n      return iv;\n    }\n  }]);\n\n  return Encryptor;\n}();\n\nmodule.exports = Encryptor;","map":{"version":3,"sources":["C:/Users/tzika/Desktop/Polymerlink-Front/polymerlink-2/node_modules/xlsx-populate/lib/Encryptor.js"],"names":["_","require","cfb","crypto","externals","XmlParser","XmlBuilder","xmlq","ENCRYPTION_INFO_PREFIX","Buffer","from","PACKAGE_ENCRYPTION_CHUNK_SIZE","PACKAGE_OFFSET","BLOCK_KEYS","dataIntegrity","hmacKey","hmacValue","key","verifierHash","input","value","Encryptor","data","password","packageKey","randomBytes","encryptionInfo","package","cipherAlgorithm","cipherChaining","saltValue","hashAlgorithm","hashSize","blockSize","keyBits","length","spinCount","encryptedPackage","_cryptPackage","hmacKeyIV","_createIV","encryptedHmacKey","_crypt","_hmac","hmacValueIV","encryptedHmacValue","_convertPasswordToKey","encryptedKeyValue","verifierHashInput","verifierHashInputKey","encryptedVerifierHashInput","verifierHashValue","_hash","verifierHashValueKey","encryptedVerifierHashValue","encryptionInfoBuffer","_buildEncryptionInfo","output","utils","cfb_new","cfb_add","cfb_del","write","isBuffer","parsed","parse","find","FileIndex","name","content","encryptedPackageBuffer","Promise","resolve","then","_parseEncryptionInfoAsync","encryptionInfoNode","attributes","xmlns","children","saltSize","toString","uri","xmlBuilder","encryptionInfoXml","build","concat","buffer","xml","slice","xmlParser","parseAsync","doc","keyDataNode","findChild","keyEncryptorsNode","keyEncryptorNode","encryptedKeyNode","algorithm","toLowerCase","hashes","getHashes","indexOf","Error","hash","createHash","buffers","update","digest","hmac","createHmac","encrypt","iv","cipher","setAutoPadding","final","outputChunks","offset","i","start","end","inputChunk","remainder","alloc","outputChunk","push","_createUInt32LEBuffer","readUInt32LE","bufferSize","writeUInt32LE","blockKey","passwordBuffer","iterator","keyBytes","tmp","copy","module","exports"],"mappings":"AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAEA,IAAMA,CAAC,GAAGC,OAAO,CAAC,QAAD,CAAjB;;AACA,IAAMC,GAAG,GAAGD,OAAO,CAAC,KAAD,CAAnB;;AACA,IAAME,MAAM,GAAGF,OAAO,CAAC,QAAD,CAAtB;;AACA,IAAMG,SAAS,GAAGH,OAAO,CAAC,aAAD,CAAzB;;AACA,IAAMI,SAAS,GAAGJ,OAAO,CAAC,aAAD,CAAzB;;AACA,IAAMK,UAAU,GAAGL,OAAO,CAAC,cAAD,CAA1B;;AACA,IAAMM,IAAI,GAAGN,OAAO,CAAC,QAAD,CAApB;;AAEA,IAAMO,sBAAsB,GAAGC,MAAM,CAACC,IAAP,CAAY,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,EAAyB,IAAzB,EAA+B,IAA/B,EAAqC,IAArC,EAA2C,IAA3C,CAAZ,CAA/B,C,CAA8F;;AAC9F,IAAMC,6BAA6B,GAAG,IAAtC;AACA,IAAMC,cAAc,GAAG,CAAvB,C,CAA0B;AAE1B;;AACA,IAAMC,UAAU,GAAG;AACfC,EAAAA,aAAa,EAAE;AACXC,IAAAA,OAAO,EAAEN,MAAM,CAACC,IAAP,CAAY,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,EAAyB,IAAzB,EAA+B,IAA/B,EAAqC,IAArC,EAA2C,IAA3C,CAAZ,CADE;AAEXM,IAAAA,SAAS,EAAEP,MAAM,CAACC,IAAP,CAAY,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,EAAyB,IAAzB,EAA+B,IAA/B,EAAqC,IAArC,EAA2C,IAA3C,CAAZ;AAFA,GADA;AAKfO,EAAAA,GAAG,EAAER,MAAM,CAACC,IAAP,CAAY,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,EAAyB,IAAzB,EAA+B,IAA/B,EAAqC,IAArC,EAA2C,IAA3C,CAAZ,CALU;AAMfQ,EAAAA,YAAY,EAAE;AACVC,IAAAA,KAAK,EAAEV,MAAM,CAACC,IAAP,CAAY,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,EAAyB,IAAzB,EAA+B,IAA/B,EAAqC,IAArC,EAA2C,IAA3C,CAAZ,CADG;AAEVU,IAAAA,KAAK,EAAEX,MAAM,CAACC,IAAP,CAAY,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,EAAyB,IAAzB,EAA+B,IAA/B,EAAqC,IAArC,EAA2C,IAA3C,CAAZ;AAFG;AANC,CAAnB;AAYA;AACA;AACA;AACA;;IACMW,S;;;;;;;;AACF;AACJ;AACA;AACA;AACA;AACA;AACI,qBAAQC,IAAR,EAAcC,QAAd,EAAwB;AACpB;AACA;AACA,UAAMC,UAAU,GAAGrB,MAAM,CAACsB,WAAP,CAAmB,EAAnB,CAAnB,CAHoB,CAKpB;;AACA,UAAMC,cAAc,GAAG;AACnBC,QAAAA,OAAO,EAAE;AAAE;AACPC,UAAAA,eAAe,EAAE,KADZ;AACmB;AACxBC,UAAAA,cAAc,EAAE,iBAFX;AAE8B;AACnCC,UAAAA,SAAS,EAAE3B,MAAM,CAACsB,WAAP,CAAmB,EAAnB,CAHN;AAG8B;AACnCM,UAAAA,aAAa,EAAE,QAJV;AAIoB;AACzBC,UAAAA,QAAQ,EAAE,EALL;AAKS;AACdC,UAAAA,SAAS,EAAE,EANN;AAMU;AACfC,UAAAA,OAAO,EAAEV,UAAU,CAACW,MAAX,GAAoB,CAPxB,CAO0B;;AAP1B,SADU;AAUnBlB,QAAAA,GAAG,EAAE;AAAE;AACHW,UAAAA,eAAe,EAAE,KADhB;AACuB;AACxBC,UAAAA,cAAc,EAAE,iBAFf;AAEkC;AACnCC,UAAAA,SAAS,EAAE3B,MAAM,CAACsB,WAAP,CAAmB,EAAnB,CAHV;AAGkC;AACnCM,UAAAA,aAAa,EAAE,QAJd;AAIwB;AACzBC,UAAAA,QAAQ,EAAE,EALT;AAKa;AACdC,UAAAA,SAAS,EAAE,EANV;AAMc;AACfG,UAAAA,SAAS,EAAE,MAPV;AAOkB;AACnBF,UAAAA,OAAO,EAAE,GARR,CAQY;;AARZ;AAVc,OAAvB;AAsBA;AAEA;;AACA,UAAMG,gBAAgB,GAAG,KAAKC,aAAL,CACrB,IADqB,EAErBZ,cAAc,CAACC,OAAf,CAAuBC,eAFF,EAGrBF,cAAc,CAACC,OAAf,CAAuBE,cAHF,EAIrBH,cAAc,CAACC,OAAf,CAAuBI,aAJF,EAKrBL,cAAc,CAACC,OAAf,CAAuBM,SALF,EAMrBP,cAAc,CAACC,OAAf,CAAuBG,SANF,EAOrBN,UAPqB,EAQrBF,IARqB,CAAzB;AAWA;AAEA;AACA;;;AACA,UAAMP,OAAO,GAAGZ,MAAM,CAACsB,WAAP,CAAmB,EAAnB,CAAhB,CA9CoB,CAgDpB;;AACA,UAAMc,SAAS,GAAG,KAAKC,SAAL,CACdd,cAAc,CAACC,OAAf,CAAuBI,aADT,EAEdL,cAAc,CAACC,OAAf,CAAuBG,SAFT,EAGdJ,cAAc,CAACC,OAAf,CAAuBM,SAHT,EAIdpB,UAAU,CAACC,aAAX,CAAyBC,OAJX,CAAlB,CAjDoB,CAwDpB;;;AACA,UAAM0B,gBAAgB,GAAG,KAAKC,MAAL,CACrB,IADqB,EAErBhB,cAAc,CAACC,OAAf,CAAuBC,eAFF,EAGrBF,cAAc,CAACC,OAAf,CAAuBE,cAHF,EAIrBL,UAJqB,EAKrBe,SALqB,EAMrBxB,OANqB,CAAzB,CAzDoB,CAiEpB;;;AACA,UAAMC,SAAS,GAAG,KAAK2B,KAAL,CAAWjB,cAAc,CAACC,OAAf,CAAuBI,aAAlC,EAAiDhB,OAAjD,EAA0DsB,gBAA1D,CAAlB,CAlEoB,CAoEpB;;;AACA,UAAMO,WAAW,GAAG,KAAKJ,SAAL,CAChBd,cAAc,CAACC,OAAf,CAAuBI,aADP,EAEhBL,cAAc,CAACC,OAAf,CAAuBG,SAFP,EAGhBJ,cAAc,CAACC,OAAf,CAAuBM,SAHP,EAIhBpB,UAAU,CAACC,aAAX,CAAyBE,SAJT,CAApB,CArEoB,CA4EpB;;;AACA,UAAM6B,kBAAkB,GAAG,KAAKH,MAAL,CACvB,IADuB,EAEvBhB,cAAc,CAACC,OAAf,CAAuBC,eAFA,EAGvBF,cAAc,CAACC,OAAf,CAAuBE,cAHA,EAIvBL,UAJuB,EAKvBoB,WALuB,EAMvB5B,SANuB,CAA3B,CA7EoB,CAsFpB;;;AACAU,MAAAA,cAAc,CAACZ,aAAf,GAA+B;AAC3B2B,QAAAA,gBAAgB,EAAhBA,gBAD2B;AAE3BI,QAAAA,kBAAkB,EAAlBA;AAF2B,OAA/B;AAKA;AAEA;;AACA,UAAM5B,GAAG,GAAG,KAAK6B,qBAAL,CACRvB,QADQ,EAERG,cAAc,CAACT,GAAf,CAAmBc,aAFX,EAGRL,cAAc,CAACT,GAAf,CAAmBa,SAHX,EAIRJ,cAAc,CAACT,GAAf,CAAmBmB,SAJX,EAKRV,cAAc,CAACT,GAAf,CAAmBiB,OALX,EAMRrB,UAAU,CAACI,GANH,CAAZ,CA/FoB,CAwGpB;;;AACAS,MAAAA,cAAc,CAACT,GAAf,CAAmB8B,iBAAnB,GAAuC,KAAKL,MAAL,CACnC,IADmC,EAEnChB,cAAc,CAACT,GAAf,CAAmBW,eAFgB,EAGnCF,cAAc,CAACT,GAAf,CAAmBY,cAHgB,EAInCZ,GAJmC,EAKnCS,cAAc,CAACT,GAAf,CAAmBa,SALgB,EAMnCN,UANmC,CAAvC;AAQA;AAEA;;AACA,UAAMwB,iBAAiB,GAAG7C,MAAM,CAACsB,WAAP,CAAmB,EAAnB,CAA1B,CApHoB,CAsHpB;;AACA,UAAMwB,oBAAoB,GAAG,KAAKH,qBAAL,CACzBvB,QADyB,EAEzBG,cAAc,CAACT,GAAf,CAAmBc,aAFM,EAGzBL,cAAc,CAACT,GAAf,CAAmBa,SAHM,EAIzBJ,cAAc,CAACT,GAAf,CAAmBmB,SAJM,EAKzBV,cAAc,CAACT,GAAf,CAAmBiB,OALM,EAMzBrB,UAAU,CAACK,YAAX,CAAwBC,KANC,CAA7B,CAvHoB,CAgIpB;;;AACAO,MAAAA,cAAc,CAACT,GAAf,CAAmBiC,0BAAnB,GAAgD,KAAKR,MAAL,CAC5C,IAD4C,EAE5ChB,cAAc,CAACT,GAAf,CAAmBW,eAFyB,EAG5CF,cAAc,CAACT,GAAf,CAAmBY,cAHyB,EAI5CoB,oBAJ4C,EAK5CvB,cAAc,CAACT,GAAf,CAAmBa,SALyB,EAM5CkB,iBAN4C,CAAhD,CAjIoB,CA0IpB;;AACA,UAAMG,iBAAiB,GAAG,KAAKC,KAAL,CAAW1B,cAAc,CAACT,GAAf,CAAmBc,aAA9B,EAA6CiB,iBAA7C,CAA1B,CA3IoB,CA6IpB;;;AACA,UAAMK,oBAAoB,GAAG,KAAKP,qBAAL,CACzBvB,QADyB,EAEzBG,cAAc,CAACT,GAAf,CAAmBc,aAFM,EAGzBL,cAAc,CAACT,GAAf,CAAmBa,SAHM,EAIzBJ,cAAc,CAACT,GAAf,CAAmBmB,SAJM,EAKzBV,cAAc,CAACT,GAAf,CAAmBiB,OALM,EAMzBrB,UAAU,CAACK,YAAX,CAAwBE,KANC,CAA7B,CA9IoB,CAuJpB;;;AACAM,MAAAA,cAAc,CAACT,GAAf,CAAmBqC,0BAAnB,GAAgD,KAAKZ,MAAL,CAC5C,IAD4C,EAE5ChB,cAAc,CAACT,GAAf,CAAmBW,eAFyB,EAG5CF,cAAc,CAACT,GAAf,CAAmBY,cAHyB,EAI5CwB,oBAJ4C,EAK5C3B,cAAc,CAACT,GAAf,CAAmBa,SALyB,EAM5CqB,iBAN4C,CAAhD,CAxJoB,CAiKpB;;AACA,UAAMI,oBAAoB,GAAG,KAAKC,oBAAL,CAA0B9B,cAA1B,CAA7B,CAlKoB,CAoKpB;;;AACA,UAAI+B,MAAM,GAAGvD,GAAG,CAACwD,KAAJ,CAAUC,OAAV,EAAb,CArKoB,CAuKpB;;AACAzD,MAAAA,GAAG,CAACwD,KAAJ,CAAUE,OAAV,CAAkBH,MAAlB,EAA0B,gBAA1B,EAA4CF,oBAA5C;AACArD,MAAAA,GAAG,CAACwD,KAAJ,CAAUE,OAAV,CAAkBH,MAAlB,EAA0B,kBAA1B,EAA8CpB,gBAA9C,EAzKoB,CA2KpB;;AACAnC,MAAAA,GAAG,CAACwD,KAAJ,CAAUG,OAAV,CAAkBJ,MAAlB,EAA0B,aAA1B,EA5KoB,CA8KpB;;AACAA,MAAAA,MAAM,GAAGvD,GAAG,CAAC4D,KAAJ,CAAUL,MAAV,CAAT,CA/KoB,CAiLpB;;AACA,UAAI,CAAChD,MAAM,CAACsD,QAAP,CAAgBN,MAAhB,CAAL,EAA8BA,MAAM,GAAGhD,MAAM,CAACC,IAAP,CAAY+C,MAAZ,CAAT;AAE9B,aAAOA,MAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;;;WACI,sBAAanC,IAAb,EAAmBC,QAAnB,EAA6B;AAAA;;AACzB;AACA,UAAMyC,MAAM,GAAG9D,GAAG,CAAC+D,KAAJ,CAAU3C,IAAV,CAAf;;AACA,UAAIiC,oBAAoB,GAAGvD,CAAC,CAACkE,IAAF,CAAOF,MAAM,CAACG,SAAd,EAAyB;AAAEC,QAAAA,IAAI,EAAE;AAAR,OAAzB,EAAqDC,OAAhF;;AACA,UAAIC,sBAAsB,GAAGtE,CAAC,CAACkE,IAAF,CAAOF,MAAM,CAACG,SAAd,EAAyB;AAAEC,QAAAA,IAAI,EAAE;AAAR,OAAzB,EAAuDC,OAApF,CAJyB,CAMzB;;;AACA,UAAI,CAAC5D,MAAM,CAACsD,QAAP,CAAgBR,oBAAhB,CAAL,EAA4CA,oBAAoB,GAAG9C,MAAM,CAACC,IAAP,CAAY6C,oBAAZ,CAAvB;AAC5C,UAAI,CAAC9C,MAAM,CAACsD,QAAP,CAAgBO,sBAAhB,CAAL,EAA8CA,sBAAsB,GAAG7D,MAAM,CAACC,IAAP,CAAY4D,sBAAZ,CAAzB;AAE9C,aAAOlE,SAAS,CAACmE,OAAV,CAAkBC,OAAlB,GACFC,IADE,CACG;AAAA,eAAM,KAAI,CAACC,yBAAL,CAA+BnB,oBAA/B,CAAN;AAAA,OADH,EAC+D;AAD/D,OAEFkB,IAFE,CAEG,UAAA/C,cAAc,EAAI;AACpB;AACA,YAAMT,GAAG,GAAG,KAAI,CAAC6B,qBAAL,CACRvB,QADQ,EAERG,cAAc,CAACT,GAAf,CAAmBc,aAFX,EAGRL,cAAc,CAACT,GAAf,CAAmBa,SAHX,EAIRJ,cAAc,CAACT,GAAf,CAAmBmB,SAJX,EAKRV,cAAc,CAACT,GAAf,CAAmBiB,OALX,EAMRrB,UAAU,CAACI,GANH,CAAZ,CAFoB,CAWpB;;;AACA,YAAMO,UAAU,GAAG,KAAI,CAACkB,MAAL,CACf,KADe,EAEfhB,cAAc,CAACT,GAAf,CAAmBW,eAFJ,EAGfF,cAAc,CAACT,GAAf,CAAmBY,cAHJ,EAIfZ,GAJe,EAKfS,cAAc,CAACT,GAAf,CAAmBa,SALJ,EAMfJ,cAAc,CAACT,GAAf,CAAmB8B,iBANJ,CAAnB,CAZoB,CAqBpB;;;AACA,eAAO,KAAI,CAACT,aAAL,CACH,KADG,EAEHZ,cAAc,CAACC,OAAf,CAAuBC,eAFpB,EAGHF,cAAc,CAACC,OAAf,CAAuBE,cAHpB,EAIHH,cAAc,CAACC,OAAf,CAAuBI,aAJpB,EAKHL,cAAc,CAACC,OAAf,CAAuBM,SALpB,EAMHP,cAAc,CAACC,OAAf,CAAuBG,SANpB,EAOHN,UAPG,EAQH8C,sBARG,CAAP;AASH,OAjCE,CAAP;AAkCH;AAED;AACJ;AACA;AACA;AACA;AACA;;;;WACI,8BAAqB5C,cAArB,EAAqC;AACjC;AACA,UAAMiD,kBAAkB,GAAG;AACvBP,QAAAA,IAAI,EAAE,YADiB;AAEvBQ,QAAAA,UAAU,EAAE;AACRC,UAAAA,KAAK,EAAE,qDADC;AAER,qBAAW,gEAFH;AAGR,qBAAW;AAHH,SAFW;AAOvBC,QAAAA,QAAQ,EAAE,CACN;AACIV,UAAAA,IAAI,EAAE,SADV;AAEIQ,UAAAA,UAAU,EAAE;AACRG,YAAAA,QAAQ,EAAErD,cAAc,CAACC,OAAf,CAAuBG,SAAvB,CAAiCK,MADnC;AAERF,YAAAA,SAAS,EAAEP,cAAc,CAACC,OAAf,CAAuBM,SAF1B;AAGRC,YAAAA,OAAO,EAAER,cAAc,CAACC,OAAf,CAAuBO,OAHxB;AAIRF,YAAAA,QAAQ,EAAEN,cAAc,CAACC,OAAf,CAAuBK,QAJzB;AAKRJ,YAAAA,eAAe,EAAEF,cAAc,CAACC,OAAf,CAAuBC,eALhC;AAMRC,YAAAA,cAAc,EAAEH,cAAc,CAACC,OAAf,CAAuBE,cAN/B;AAORE,YAAAA,aAAa,EAAEL,cAAc,CAACC,OAAf,CAAuBI,aAP9B;AAQRD,YAAAA,SAAS,EAAEJ,cAAc,CAACC,OAAf,CAAuBG,SAAvB,CAAiCkD,QAAjC,CAA0C,QAA1C;AARH;AAFhB,SADM,EAcN;AACIZ,UAAAA,IAAI,EAAE,eADV;AAEIQ,UAAAA,UAAU,EAAE;AACRnC,YAAAA,gBAAgB,EAAEf,cAAc,CAACZ,aAAf,CAA6B2B,gBAA7B,CAA8CuC,QAA9C,CAAuD,QAAvD,CADV;AAERnC,YAAAA,kBAAkB,EAAEnB,cAAc,CAACZ,aAAf,CAA6B+B,kBAA7B,CAAgDmC,QAAhD,CAAyD,QAAzD;AAFZ;AAFhB,SAdM,EAqBN;AACIZ,UAAAA,IAAI,EAAE,eADV;AAEIU,UAAAA,QAAQ,EAAE,CACN;AACIV,YAAAA,IAAI,EAAE,cADV;AAEIQ,YAAAA,UAAU,EAAE;AACRK,cAAAA,GAAG,EAAE;AADG,aAFhB;AAKIH,YAAAA,QAAQ,EAAE,CACN;AACIV,cAAAA,IAAI,EAAE,gBADV;AAEIQ,cAAAA,UAAU,EAAE;AACRxC,gBAAAA,SAAS,EAAEV,cAAc,CAACT,GAAf,CAAmBmB,SADtB;AAER2C,gBAAAA,QAAQ,EAAErD,cAAc,CAACT,GAAf,CAAmBa,SAAnB,CAA6BK,MAF/B;AAGRF,gBAAAA,SAAS,EAAEP,cAAc,CAACT,GAAf,CAAmBgB,SAHtB;AAIRC,gBAAAA,OAAO,EAAER,cAAc,CAACT,GAAf,CAAmBiB,OAJpB;AAKRF,gBAAAA,QAAQ,EAAEN,cAAc,CAACT,GAAf,CAAmBe,QALrB;AAMRJ,gBAAAA,eAAe,EAAEF,cAAc,CAACT,GAAf,CAAmBW,eAN5B;AAORC,gBAAAA,cAAc,EAAEH,cAAc,CAACT,GAAf,CAAmBY,cAP3B;AAQRE,gBAAAA,aAAa,EAAEL,cAAc,CAACT,GAAf,CAAmBc,aAR1B;AASRD,gBAAAA,SAAS,EAAEJ,cAAc,CAACT,GAAf,CAAmBa,SAAnB,CAA6BkD,QAA7B,CAAsC,QAAtC,CATH;AAUR9B,gBAAAA,0BAA0B,EAAExB,cAAc,CAACT,GAAf,CAAmBiC,0BAAnB,CAA8C8B,QAA9C,CAAuD,QAAvD,CAVpB;AAWR1B,gBAAAA,0BAA0B,EAAE5B,cAAc,CAACT,GAAf,CAAmBqC,0BAAnB,CAA8C0B,QAA9C,CAAuD,QAAvD,CAXpB;AAYRjC,gBAAAA,iBAAiB,EAAErB,cAAc,CAACT,GAAf,CAAmB8B,iBAAnB,CAAqCiC,QAArC,CAA8C,QAA9C;AAZX;AAFhB,aADM;AALd,WADM;AAFd,SArBM;AAPa,OAA3B,CAFiC,CA+DjC;;AACA,UAAME,UAAU,GAAG,IAAI5E,UAAJ,EAAnB;AACA,UAAM6E,iBAAiB,GAAGD,UAAU,CAACE,KAAX,CAAiBT,kBAAjB,CAA1B,CAjEiC,CAmEjC;;AACA,aAAOlE,MAAM,CAAC4E,MAAP,CAAc,CAAC7E,sBAAD,EAAyBC,MAAM,CAACC,IAAP,CAAYyE,iBAAZ,EAA+B,MAA/B,CAAzB,CAAd,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;;;WACI,mCAA0BG,MAA1B,EAAkC;AAC9B;AACA,UAAMC,GAAG,GAAGD,MAAM,CAACE,KAAP,CAAahF,sBAAsB,CAAC2B,MAApC,EAA4C6C,QAA5C,CAAqD,MAArD,CAAZ,CAF8B,CAI9B;;AACA,UAAMS,SAAS,GAAG,IAAIpF,SAAJ,EAAlB;AACA,aAAOoF,SAAS,CAACC,UAAV,CAAqBH,GAArB,EACFd,IADE,CACG,UAAAkB,GAAG,EAAI;AACT;AACA,YAAMC,WAAW,GAAGrF,IAAI,CAACsF,SAAL,CAAeF,GAAf,EAAoB,SAApB,CAApB;AACA,YAAMG,iBAAiB,GAAGvF,IAAI,CAACsF,SAAL,CAAeF,GAAf,EAAoB,eAApB,CAA1B;AACA,YAAMI,gBAAgB,GAAGxF,IAAI,CAACsF,SAAL,CAAeC,iBAAf,EAAkC,cAAlC,CAAzB;AACA,YAAME,gBAAgB,GAAGzF,IAAI,CAACsF,SAAL,CAAeE,gBAAf,EAAiC,gBAAjC,CAAzB;AAEA,eAAO;AACHpE,UAAAA,OAAO,EAAE;AACLC,YAAAA,eAAe,EAAEgE,WAAW,CAAChB,UAAZ,CAAuBhD,eADnC;AAELC,YAAAA,cAAc,EAAE+D,WAAW,CAAChB,UAAZ,CAAuB/C,cAFlC;AAGLC,YAAAA,SAAS,EAAErB,MAAM,CAACC,IAAP,CAAYkF,WAAW,CAAChB,UAAZ,CAAuB9C,SAAnC,EAA8C,QAA9C,CAHN;AAILC,YAAAA,aAAa,EAAE6D,WAAW,CAAChB,UAAZ,CAAuB7C,aAJjC;AAKLE,YAAAA,SAAS,EAAE2D,WAAW,CAAChB,UAAZ,CAAuB3C;AAL7B,WADN;AAQHhB,UAAAA,GAAG,EAAE;AACD8B,YAAAA,iBAAiB,EAAEtC,MAAM,CAACC,IAAP,CAAYsF,gBAAgB,CAACpB,UAAjB,CAA4B7B,iBAAxC,EAA2D,QAA3D,CADlB;AAEDnB,YAAAA,eAAe,EAAEoE,gBAAgB,CAACpB,UAAjB,CAA4BhD,eAF5C;AAGDC,YAAAA,cAAc,EAAEmE,gBAAgB,CAACpB,UAAjB,CAA4B/C,cAH3C;AAIDC,YAAAA,SAAS,EAAErB,MAAM,CAACC,IAAP,CAAYsF,gBAAgB,CAACpB,UAAjB,CAA4B9C,SAAxC,EAAmD,QAAnD,CAJV;AAKDC,YAAAA,aAAa,EAAEiE,gBAAgB,CAACpB,UAAjB,CAA4B7C,aAL1C;AAMDK,YAAAA,SAAS,EAAE4D,gBAAgB,CAACpB,UAAjB,CAA4BxC,SANtC;AAODF,YAAAA,OAAO,EAAE8D,gBAAgB,CAACpB,UAAjB,CAA4B1C;AAPpC;AARF,SAAP;AAkBH,OA1BE,CAAP;AA2BH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;;;;WACI,eAAM+D,SAAN,EAA6B;AACzBA,MAAAA,SAAS,GAAGA,SAAS,CAACC,WAAV,EAAZ;AACA,UAAMC,MAAM,GAAGhG,MAAM,CAACiG,SAAP,EAAf;AACA,UAAID,MAAM,CAACE,OAAP,CAAeJ,SAAf,IAA4B,CAAhC,EAAmC,MAAM,IAAIK,KAAJ,2BAA6BL,SAA7B,sBAAN;AAEnC,UAAMM,IAAI,GAAGpG,MAAM,CAACqG,UAAP,CAAkBP,SAAlB,CAAb;;AALyB,wCAATQ,OAAS;AAATA,QAAAA,OAAS;AAAA;;AAMzBF,MAAAA,IAAI,CAACG,MAAL,CAAYjG,MAAM,CAAC4E,MAAP,CAAcoB,OAAd,CAAZ;AACA,aAAOF,IAAI,CAACI,MAAL,EAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACI,eAAMV,SAAN,EAAiBhF,GAAjB,EAAkC;AAC9BgF,MAAAA,SAAS,GAAGA,SAAS,CAACC,WAAV,EAAZ;AACA,UAAMC,MAAM,GAAGhG,MAAM,CAACiG,SAAP,EAAf;AACA,UAAID,MAAM,CAACE,OAAP,CAAeJ,SAAf,IAA4B,CAAhC,EAAmC,MAAM,IAAIK,KAAJ,2BAA6BL,SAA7B,sBAAN;AAEnC,UAAMW,IAAI,GAAGzG,MAAM,CAAC0G,UAAP,CAAkBZ,SAAlB,EAA6BhF,GAA7B,CAAb;;AAL8B,yCAATwF,OAAS;AAATA,QAAAA,OAAS;AAAA;;AAM9BG,MAAAA,IAAI,CAACF,MAAL,CAAYjG,MAAM,CAAC4E,MAAP,CAAcoB,OAAd,CAAZ;AACA,aAAOG,IAAI,CAACD,MAAL,EAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACI,gBAAOG,OAAP,EAAgBlF,eAAhB,EAAiCC,cAAjC,EAAiDZ,GAAjD,EAAsD8F,EAAtD,EAA0D5F,KAA1D,EAAiE;AAC7D,UAAI8E,SAAS,aAAMrE,eAAe,CAACsE,WAAhB,EAAN,cAAuCjF,GAAG,CAACkB,MAAJ,GAAa,CAApD,CAAb;AACA,UAAIN,cAAc,KAAK,iBAAvB,EAA0CoE,SAAS,IAAI,MAAb,CAA1C,KACK,MAAM,IAAIK,KAAJ,oCAAsCzE,cAAtC,EAAN;AAEL,UAAMmF,MAAM,GAAG7G,MAAM,CAAC2G,OAAO,GAAG,gBAAH,GAAsB,kBAA9B,CAAN,CAAwDb,SAAxD,EAAmEhF,GAAnE,EAAwE8F,EAAxE,CAAf;AACAC,MAAAA,MAAM,CAACC,cAAP,CAAsB,KAAtB;AACA,UAAIxD,MAAM,GAAGuD,MAAM,CAACN,MAAP,CAAcvF,KAAd,CAAb;AACAsC,MAAAA,MAAM,GAAGhD,MAAM,CAAC4E,MAAP,CAAc,CAAC5B,MAAD,EAASuD,MAAM,CAACE,KAAP,EAAT,CAAd,CAAT;AACA,aAAOzD,MAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACI,uBAAcqD,OAAd,EAAuBlF,eAAvB,EAAwCC,cAAxC,EAAwDE,aAAxD,EAAuEE,SAAvE,EAAkFH,SAAlF,EAA6Fb,GAA7F,EAAkGE,KAAlG,EAAyG;AACrG;AACA,UAAMgG,YAAY,GAAG,EAArB;AACA,UAAMC,MAAM,GAAGN,OAAO,GAAG,CAAH,GAAOlG,cAA7B,CAHqG,CAKrG;;AACA,UAAIyG,CAAC,GAAG,CAAR;AAAA,UAAWC,KAAK,GAAG,CAAnB;AAAA,UAAsBC,GAAG,GAAG,CAA5B;;AACA,aAAOA,GAAG,GAAGpG,KAAK,CAACgB,MAAnB,EAA2B;AACvBmF,QAAAA,KAAK,GAAGC,GAAR;AACAA,QAAAA,GAAG,GAAGD,KAAK,GAAG3G,6BAAd;AACA,YAAI4G,GAAG,GAAGpG,KAAK,CAACgB,MAAhB,EAAwBoF,GAAG,GAAGpG,KAAK,CAACgB,MAAZ,CAHD,CAKvB;;AACA,YAAIqF,UAAU,GAAGrG,KAAK,CAACqE,KAAN,CAAY8B,KAAK,GAAGF,MAApB,EAA4BG,GAAG,GAAGH,MAAlC,CAAjB,CANuB,CAQvB;;AACA,YAAMK,SAAS,GAAGD,UAAU,CAACrF,MAAX,GAAoBF,SAAtC;AACA,YAAIwF,SAAJ,EAAeD,UAAU,GAAG/G,MAAM,CAAC4E,MAAP,CAAc,CAACmC,UAAD,EAAa/G,MAAM,CAACiH,KAAP,CAAazF,SAAS,GAAGwF,SAAzB,CAAb,CAAd,CAAb,CAVQ,CAYvB;;AACA,YAAMV,EAAE,GAAG,KAAKvE,SAAL,CAAeT,aAAf,EAA8BD,SAA9B,EAAyCG,SAAzC,EAAoDoF,CAApD,CAAX,CAbuB,CAevB;;;AACA,YAAMM,WAAW,GAAG,KAAKjF,MAAL,CAAYoE,OAAZ,EAAqBlF,eAArB,EAAsCC,cAAtC,EAAsDZ,GAAtD,EAA2D8F,EAA3D,EAA+DS,UAA/D,CAApB;;AACAL,QAAAA,YAAY,CAACS,IAAb,CAAkBD,WAAlB;AAEAN,QAAAA,CAAC;AACJ,OA3BoG,CA6BrG;;;AACA,UAAI5D,MAAM,GAAGhD,MAAM,CAAC4E,MAAP,CAAc8B,YAAd,CAAb;;AAEA,UAAIL,OAAJ,EAAa;AACT;AACArD,QAAAA,MAAM,GAAGhD,MAAM,CAAC4E,MAAP,CAAc,CAAC,KAAKwC,qBAAL,CAA2B1G,KAAK,CAACgB,MAAjC,EAAyCvB,cAAzC,CAAD,EAA2D6C,MAA3D,CAAd,CAAT;AACH,OAHD,MAGO;AACH;AACA,YAAMtB,MAAM,GAAGhB,KAAK,CAAC2G,YAAN,CAAmB,CAAnB,CAAf;AACArE,QAAAA,MAAM,GAAGA,MAAM,CAAC+B,KAAP,CAAa,CAAb,EAAgBrD,MAAhB,CAAT;AACH;;AAED,aAAOsB,MAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;;;;WACI,+BAAsBrC,KAAtB,EAA6C;AAAA,UAAhB2G,UAAgB,uEAAH,CAAG;AACzC,UAAMzC,MAAM,GAAG7E,MAAM,CAACiH,KAAP,CAAaK,UAAb,CAAf;AACAzC,MAAAA,MAAM,CAAC0C,aAAP,CAAqB5G,KAArB,EAA4B,CAA5B;AACA,aAAOkE,MAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACI,+BAAsB/D,QAAtB,EAAgCQ,aAAhC,EAA+CD,SAA/C,EAA0DM,SAA1D,EAAqEF,OAArE,EAA8E+F,QAA9E,EAAwF;AACpF;AACA,UAAMC,cAAc,GAAGzH,MAAM,CAACC,IAAP,CAAYa,QAAZ,EAAsB,SAAtB,CAAvB,CAFoF,CAIpF;;AACA,UAAIN,GAAG,GAAG,KAAKmC,KAAL,CAAWrB,aAAX,EAA0BD,SAA1B,EAAqCoG,cAArC,CAAV,CALoF,CAOpF;;;AACA,WAAK,IAAIb,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGjF,SAApB,EAA+BiF,CAAC,EAAhC,EAAoC;AAChC,YAAMc,QAAQ,GAAG,KAAKN,qBAAL,CAA2BR,CAA3B,CAAjB;;AACApG,QAAAA,GAAG,GAAG,KAAKmC,KAAL,CAAWrB,aAAX,EAA0BoG,QAA1B,EAAoClH,GAApC,CAAN;AACH,OAXmF,CAapF;;;AACAA,MAAAA,GAAG,GAAG,KAAKmC,KAAL,CAAWrB,aAAX,EAA0Bd,GAA1B,EAA+BgH,QAA/B,CAAN,CAdoF,CAgBpF;;AACA,UAAMG,QAAQ,GAAGlG,OAAO,GAAG,CAA3B;;AACA,UAAIjB,GAAG,CAACkB,MAAJ,GAAaiG,QAAjB,EAA2B;AACvB,YAAMC,GAAG,GAAG5H,MAAM,CAACiH,KAAP,CAAaU,QAAb,EAAuB,IAAvB,CAAZ;AACAnH,QAAAA,GAAG,CAACqH,IAAJ,CAASD,GAAT;AACApH,QAAAA,GAAG,GAAGoH,GAAN;AACH,OAJD,MAIO,IAAIpH,GAAG,CAACkB,MAAJ,GAAaiG,QAAjB,EAA2B;AAC9BnH,QAAAA,GAAG,GAAGA,GAAG,CAACuE,KAAJ,CAAU,CAAV,EAAa4C,QAAb,CAAN;AACH;;AAED,aAAOnH,GAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACI,mBAAUc,aAAV,EAAyBD,SAAzB,EAAoCG,SAApC,EAA+CgG,QAA/C,EAAyD;AACrD;AACA,UAAI,OAAOA,QAAP,KAAoB,QAAxB,EAAkCA,QAAQ,GAAG,KAAKJ,qBAAL,CAA2BI,QAA3B,CAAX,CAFmB,CAIrD;AACA;;AACA,UAAIlB,EAAE,GAAG,KAAK3D,KAAL,CAAWrB,aAAX,EAA0BD,SAA1B,EAAqCmG,QAArC,CAAT;;AACA,UAAIlB,EAAE,CAAC5E,MAAH,GAAYF,SAAhB,EAA2B;AACvB,YAAMoG,GAAG,GAAG5H,MAAM,CAACiH,KAAP,CAAazF,SAAb,EAAwB,IAAxB,CAAZ;AACA8E,QAAAA,EAAE,CAACuB,IAAH,CAAQD,GAAR;AACAtB,QAAAA,EAAE,GAAGsB,GAAL;AACH,OAJD,MAIO,IAAItB,EAAE,CAAC5E,MAAH,GAAYF,SAAhB,EAA2B;AAC9B8E,QAAAA,EAAE,GAAGA,EAAE,CAACvB,KAAH,CAAS,CAAT,EAAYvD,SAAZ,CAAL;AACH;;AAED,aAAO8E,EAAP;AACH;;;;;;AAGLwB,MAAM,CAACC,OAAP,GAAiBnH,SAAjB","sourcesContent":["\"use strict\";\n\n/**\n * OOXML uses the CFB file format with Agile Encryption. The details of the encryption are here:\n * https://msdn.microsoft.com/en-us/library/dd950165(v=office.12).aspx\n *\n * Helpful guidance also take from this Github project:\n * https://github.com/nolze/ms-offcrypto-tool\n */\n\nconst _ = require(\"lodash\");\nconst cfb = require(\"cfb\");\nconst crypto = require(\"crypto\");\nconst externals = require(\"./externals\");\nconst XmlParser = require(\"./XmlParser\");\nconst XmlBuilder = require(\"./XmlBuilder\");\nconst xmlq = require(\"./xmlq\");\n\nconst ENCRYPTION_INFO_PREFIX = Buffer.from([0x04, 0x00, 0x04, 0x00, 0x40, 0x00, 0x00, 0x00]); // First 4 bytes are the version number, second 4 bytes are reserved.\nconst PACKAGE_ENCRYPTION_CHUNK_SIZE = 4096;\nconst PACKAGE_OFFSET = 8; // First 8 bytes are the size of the stream\n\n// Block keys used for encryption\nconst BLOCK_KEYS = {\n    dataIntegrity: {\n        hmacKey: Buffer.from([0x5f, 0xb2, 0xad, 0x01, 0x0c, 0xb9, 0xe1, 0xf6]),\n        hmacValue: Buffer.from([0xa0, 0x67, 0x7f, 0x02, 0xb2, 0x2c, 0x84, 0x33])\n    },\n    key: Buffer.from([0x14, 0x6e, 0x0b, 0xe7, 0xab, 0xac, 0xd0, 0xd6]),\n    verifierHash: {\n        input: Buffer.from([0xfe, 0xa7, 0xd2, 0x76, 0x3b, 0x4b, 0x9e, 0x79]),\n        value: Buffer.from([0xd7, 0xaa, 0x0f, 0x6d, 0x30, 0x61, 0x34, 0x4e])\n    }\n};\n\n/**\n * Encrypts/decrypts XLSXs.\n * @private\n */\nclass Encryptor {\n    /**\n     * Encrypt the data with the password.\n     * @param {Buffer} data - The data to encrypt\n     * @param {string} password - The password\n     * @returns {Buffer} The encrypted data\n     */\n    encrypt(data, password) {\n        // Generate a random key to use to encrypt the document. Excel uses 32 bytes. We'll use the password to encrypt this key.\n        // N.B. The number of bits needs to correspond to an algorithm available in crypto (e.g. aes-256-cbc).\n        const packageKey = crypto.randomBytes(32);\n\n        // Create the encryption info. We'll use this for all of the encryption operations and for building the encryption info XML entry\n        const encryptionInfo = {\n            package: { // Info on the encryption of the package.\n                cipherAlgorithm: 'AES', // Cipher algorithm to use. Excel uses AES.\n                cipherChaining: 'ChainingModeCBC', // Cipher chaining mode to use. Excel uses CBC.\n                saltValue: crypto.randomBytes(16), // Random value to use as encryption salt. Excel uses 16 bytes.\n                hashAlgorithm: 'SHA512', // Hash algorithm to use. Excel uses SHA512.\n                hashSize: 64, // The size of the hash in bytes. SHA512 results in 64-byte hashes\n                blockSize: 16, // The number of bytes used to encrypt one block of data. It MUST be at least 2, no greater than 4096, and a multiple of 2. Excel uses 16\n                keyBits: packageKey.length * 8 // The number of bits in the package key.\n            },\n            key: { // Info on the encryption of the package key.\n                cipherAlgorithm: 'AES', // Cipher algorithm to use. Excel uses AES.\n                cipherChaining: 'ChainingModeCBC', // Cipher chaining mode to use. Excel uses CBC.\n                saltValue: crypto.randomBytes(16), // Random value to use as encryption salt. Excel uses 16 bytes.\n                hashAlgorithm: 'SHA512', // Hash algorithm to use. Excel uses SHA512.\n                hashSize: 64, // The size of the hash in bytes. SHA512 results in 64-byte hashes\n                blockSize: 16, // The number of bytes used to encrypt one block of data. It MUST be at least 2, no greater than 4096, and a multiple of 2. Excel uses 16\n                spinCount: 100000, // The number of times to iterate on a hash of a password. It MUST NOT be greater than 10,000,000. Excel uses 100,000.\n                keyBits: 256 // The length of the key to generate from the password. Must be a multiple of 8. Excel uses 256.\n            }\n        };\n\n        /* Package Encryption */\n\n        // Encrypt package using the package key.\n        const encryptedPackage = this._cryptPackage(\n            true,\n            encryptionInfo.package.cipherAlgorithm,\n            encryptionInfo.package.cipherChaining,\n            encryptionInfo.package.hashAlgorithm,\n            encryptionInfo.package.blockSize,\n            encryptionInfo.package.saltValue,\n            packageKey,\n            data\n        );\n\n        /* Data Integrity */\n\n        // Create the data integrity fields used by clients for integrity checks.\n        // First generate a random array of bytes to use in HMAC. The docs say to use the same length as the key salt, but Excel seems to use 64.\n        const hmacKey = crypto.randomBytes(64);\n\n        // Then create an initialization vector using the package encryption info and the appropriate block key.\n        const hmacKeyIV = this._createIV(\n            encryptionInfo.package.hashAlgorithm,\n            encryptionInfo.package.saltValue,\n            encryptionInfo.package.blockSize,\n            BLOCK_KEYS.dataIntegrity.hmacKey\n        );\n\n        // Use the package key and the IV to encrypt the HMAC key\n        const encryptedHmacKey = this._crypt(\n            true,\n            encryptionInfo.package.cipherAlgorithm,\n            encryptionInfo.package.cipherChaining,\n            packageKey,\n            hmacKeyIV,\n            hmacKey);\n\n        // Now create the HMAC\n        const hmacValue = this._hmac(encryptionInfo.package.hashAlgorithm, hmacKey, encryptedPackage);\n\n        // Next generate an initialization vector for encrypting the resulting HMAC value.\n        const hmacValueIV = this._createIV(\n            encryptionInfo.package.hashAlgorithm,\n            encryptionInfo.package.saltValue,\n            encryptionInfo.package.blockSize,\n            BLOCK_KEYS.dataIntegrity.hmacValue\n        );\n\n        // Now encrypt the value\n        const encryptedHmacValue = this._crypt(\n            true,\n            encryptionInfo.package.cipherAlgorithm,\n            encryptionInfo.package.cipherChaining,\n            packageKey,\n            hmacValueIV,\n            hmacValue\n        );\n\n        // Put the encrypted key and value on the encryption info\n        encryptionInfo.dataIntegrity = {\n            encryptedHmacKey,\n            encryptedHmacValue\n        };\n\n        /* Key Encryption */\n\n        // Convert the password to an encryption key\n        const key = this._convertPasswordToKey(\n            password,\n            encryptionInfo.key.hashAlgorithm,\n            encryptionInfo.key.saltValue,\n            encryptionInfo.key.spinCount,\n            encryptionInfo.key.keyBits,\n            BLOCK_KEYS.key\n        );\n\n        // Encrypt the package key with the\n        encryptionInfo.key.encryptedKeyValue = this._crypt(\n            true,\n            encryptionInfo.key.cipherAlgorithm,\n            encryptionInfo.key.cipherChaining,\n            key,\n            encryptionInfo.key.saltValue,\n            packageKey);\n\n        /* Verifier hash */\n\n        // Create a random byte array for hashing\n        const verifierHashInput = crypto.randomBytes(16);\n\n        // Create an encryption key from the password for the input\n        const verifierHashInputKey = this._convertPasswordToKey(\n            password,\n            encryptionInfo.key.hashAlgorithm,\n            encryptionInfo.key.saltValue,\n            encryptionInfo.key.spinCount,\n            encryptionInfo.key.keyBits,\n            BLOCK_KEYS.verifierHash.input\n        );\n\n        // Use the key to encrypt the verifier input\n        encryptionInfo.key.encryptedVerifierHashInput = this._crypt(\n            true,\n            encryptionInfo.key.cipherAlgorithm,\n            encryptionInfo.key.cipherChaining,\n            verifierHashInputKey,\n            encryptionInfo.key.saltValue,\n            verifierHashInput\n        );\n\n        // Create a hash of the input\n        const verifierHashValue = this._hash(encryptionInfo.key.hashAlgorithm, verifierHashInput);\n\n        // Create an encryption key from the password for the hash\n        const verifierHashValueKey = this._convertPasswordToKey(\n            password,\n            encryptionInfo.key.hashAlgorithm,\n            encryptionInfo.key.saltValue,\n            encryptionInfo.key.spinCount,\n            encryptionInfo.key.keyBits,\n            BLOCK_KEYS.verifierHash.value\n        );\n\n        // Use the key to encrypt the hash value\n        encryptionInfo.key.encryptedVerifierHashValue = this._crypt(\n            true,\n            encryptionInfo.key.cipherAlgorithm,\n            encryptionInfo.key.cipherChaining,\n            verifierHashValueKey,\n            encryptionInfo.key.saltValue,\n            verifierHashValue\n        );\n\n        // Build the encryption info buffer\n        const encryptionInfoBuffer = this._buildEncryptionInfo(encryptionInfo);\n\n        // Create a new CFB\n        let output = cfb.utils.cfb_new();\n\n        // Add the encryption info and encrypted package\n        cfb.utils.cfb_add(output, \"EncryptionInfo\", encryptionInfoBuffer);\n        cfb.utils.cfb_add(output, \"EncryptedPackage\", encryptedPackage);\n\n        // Delete the SheetJS entry that is added at initialization\n        cfb.utils.cfb_del(output, \"\\u0001Sh33tJ5\");\n\n        // Write to a buffer and return\n        output = cfb.write(output);\n\n        // The cfb library writes to a Uint8array in the browser. Convert to a Buffer.\n        if (!Buffer.isBuffer(output)) output = Buffer.from(output);\n\n        return output;\n    }\n\n    /**\n     * Decrypt the data with the given password\n     * @param {Buffer} data - The data to decrypt\n     * @param {string} password - The password\n     * @returns {Promise.<Buffer>} The decrypted data\n     */\n    decryptAsync(data, password) {\n        // Parse the CFB input and pull out the encryption info and encrypted package entries.\n        const parsed = cfb.parse(data);\n        let encryptionInfoBuffer = _.find(parsed.FileIndex, { name: \"EncryptionInfo\" }).content;\n        let encryptedPackageBuffer = _.find(parsed.FileIndex, { name: \"EncryptedPackage\" }).content;\n\n        // In the browser the CFB content is an array. Convert to a Buffer.\n        if (!Buffer.isBuffer(encryptionInfoBuffer)) encryptionInfoBuffer = Buffer.from(encryptionInfoBuffer);\n        if (!Buffer.isBuffer(encryptedPackageBuffer)) encryptedPackageBuffer = Buffer.from(encryptedPackageBuffer);\n\n        return externals.Promise.resolve()\n            .then(() => this._parseEncryptionInfoAsync(encryptionInfoBuffer)) // Parse the encryption info XML into an object\n            .then(encryptionInfo => {\n                // Convert the password into an encryption key\n                const key = this._convertPasswordToKey(\n                    password,\n                    encryptionInfo.key.hashAlgorithm,\n                    encryptionInfo.key.saltValue,\n                    encryptionInfo.key.spinCount,\n                    encryptionInfo.key.keyBits,\n                    BLOCK_KEYS.key\n                );\n\n                // Use the key to decrypt the package key\n                const packageKey = this._crypt(\n                    false,\n                    encryptionInfo.key.cipherAlgorithm,\n                    encryptionInfo.key.cipherChaining,\n                    key,\n                    encryptionInfo.key.saltValue,\n                    encryptionInfo.key.encryptedKeyValue\n                );\n\n                // Use the package key to decrypt the package\n                return this._cryptPackage(\n                    false,\n                    encryptionInfo.package.cipherAlgorithm,\n                    encryptionInfo.package.cipherChaining,\n                    encryptionInfo.package.hashAlgorithm,\n                    encryptionInfo.package.blockSize,\n                    encryptionInfo.package.saltValue,\n                    packageKey,\n                    encryptedPackageBuffer);\n            });\n    }\n\n    /**\n     * Build the encryption info XML/buffer\n     * @param {{}} encryptionInfo - The encryption info object\n     * @returns {Buffer} The buffer\n     * @private\n     */\n    _buildEncryptionInfo(encryptionInfo) {\n        // Map the object into the appropriate XML structure. Buffers are encoded in base 64.\n        const encryptionInfoNode = {\n            name: \"encryption\",\n            attributes: {\n                xmlns: \"http://schemas.microsoft.com/office/2006/encryption\",\n                'xmlns:p': \"http://schemas.microsoft.com/office/2006/keyEncryptor/password\",\n                'xmlns:c': \"http://schemas.microsoft.com/office/2006/keyEncryptor/certificate\"\n            },\n            children: [\n                {\n                    name: \"keyData\",\n                    attributes: {\n                        saltSize: encryptionInfo.package.saltValue.length,\n                        blockSize: encryptionInfo.package.blockSize,\n                        keyBits: encryptionInfo.package.keyBits,\n                        hashSize: encryptionInfo.package.hashSize,\n                        cipherAlgorithm: encryptionInfo.package.cipherAlgorithm,\n                        cipherChaining: encryptionInfo.package.cipherChaining,\n                        hashAlgorithm: encryptionInfo.package.hashAlgorithm,\n                        saltValue: encryptionInfo.package.saltValue.toString(\"base64\")\n                    }\n                },\n                {\n                    name: \"dataIntegrity\",\n                    attributes: {\n                        encryptedHmacKey: encryptionInfo.dataIntegrity.encryptedHmacKey.toString(\"base64\"),\n                        encryptedHmacValue: encryptionInfo.dataIntegrity.encryptedHmacValue.toString(\"base64\")\n                    }\n                },\n                {\n                    name: \"keyEncryptors\",\n                    children: [\n                        {\n                            name: \"keyEncryptor\",\n                            attributes: {\n                                uri: \"http://schemas.microsoft.com/office/2006/keyEncryptor/password\"\n                            },\n                            children: [\n                                {\n                                    name: \"p:encryptedKey\",\n                                    attributes: {\n                                        spinCount: encryptionInfo.key.spinCount,\n                                        saltSize: encryptionInfo.key.saltValue.length,\n                                        blockSize: encryptionInfo.key.blockSize,\n                                        keyBits: encryptionInfo.key.keyBits,\n                                        hashSize: encryptionInfo.key.hashSize,\n                                        cipherAlgorithm: encryptionInfo.key.cipherAlgorithm,\n                                        cipherChaining: encryptionInfo.key.cipherChaining,\n                                        hashAlgorithm: encryptionInfo.key.hashAlgorithm,\n                                        saltValue: encryptionInfo.key.saltValue.toString(\"base64\"),\n                                        encryptedVerifierHashInput: encryptionInfo.key.encryptedVerifierHashInput.toString(\"base64\"),\n                                        encryptedVerifierHashValue: encryptionInfo.key.encryptedVerifierHashValue.toString(\"base64\"),\n                                        encryptedKeyValue: encryptionInfo.key.encryptedKeyValue.toString(\"base64\")\n                                    }\n                                }\n                            ]\n                        }\n                    ]\n                }\n            ]\n        };\n\n        // Convert to an XML string\n        const xmlBuilder = new XmlBuilder();\n        const encryptionInfoXml = xmlBuilder.build(encryptionInfoNode);\n\n        // Convert to a buffer and prefix with the appropriate bytes\n        return Buffer.concat([ENCRYPTION_INFO_PREFIX, Buffer.from(encryptionInfoXml, \"utf8\")]);\n    }\n\n    /**\n     * Parse the encryption info from the XML/buffer\n     * @param {Buffer} buffer - The buffer\n     * @returns {Promise.<{}>} The parsed encryption info object\n     * @private\n     */\n    _parseEncryptionInfoAsync(buffer) {\n        // Pull off the prefix and convert to string\n        const xml = buffer.slice(ENCRYPTION_INFO_PREFIX.length).toString(\"utf8\");\n\n        // Parse the XML\n        const xmlParser = new XmlParser();\n        return xmlParser.parseAsync(xml)\n            .then(doc => {\n                // Pull out the relevant values for decryption and return\n                const keyDataNode = xmlq.findChild(doc, \"keyData\");\n                const keyEncryptorsNode = xmlq.findChild(doc, \"keyEncryptors\");\n                const keyEncryptorNode = xmlq.findChild(keyEncryptorsNode, \"keyEncryptor\");\n                const encryptedKeyNode = xmlq.findChild(keyEncryptorNode, \"p:encryptedKey\");\n\n                return {\n                    package: {\n                        cipherAlgorithm: keyDataNode.attributes.cipherAlgorithm,\n                        cipherChaining: keyDataNode.attributes.cipherChaining,\n                        saltValue: Buffer.from(keyDataNode.attributes.saltValue, \"base64\"),\n                        hashAlgorithm: keyDataNode.attributes.hashAlgorithm,\n                        blockSize: keyDataNode.attributes.blockSize\n                    },\n                    key: {\n                        encryptedKeyValue: Buffer.from(encryptedKeyNode.attributes.encryptedKeyValue, \"base64\"),\n                        cipherAlgorithm: encryptedKeyNode.attributes.cipherAlgorithm,\n                        cipherChaining: encryptedKeyNode.attributes.cipherChaining,\n                        saltValue: Buffer.from(encryptedKeyNode.attributes.saltValue, \"base64\"),\n                        hashAlgorithm: encryptedKeyNode.attributes.hashAlgorithm,\n                        spinCount: encryptedKeyNode.attributes.spinCount,\n                        keyBits: encryptedKeyNode.attributes.keyBits\n                    }\n                };\n            });\n    }\n\n    /**\n     * Calculate a hash of the concatenated buffers with the given algorithm.\n     * @param {string} algorithm - The hash algorithm.\n     * @param {Array.<Buffer>} buffers - The buffers to concat and hash\n     * @returns {Buffer} The hash\n     * @private\n     */\n    _hash(algorithm, ...buffers) {\n        algorithm = algorithm.toLowerCase();\n        const hashes = crypto.getHashes();\n        if (hashes.indexOf(algorithm) < 0) throw new Error(`Hash algorithm '${algorithm}' not supported!`);\n\n        const hash = crypto.createHash(algorithm);\n        hash.update(Buffer.concat(buffers));\n        return hash.digest();\n    }\n\n    /**\n     * Calculate an HMAC of the concatenated buffers with the given algorithm and key\n     * @param {string} algorithm - The algorithm.\n     * @param {string} key - The key\n     * @param {Array.<Buffer>} buffers - The buffer to concat and HMAC\n     * @returns {Buffer} The HMAC\n     * @private\n     */\n    _hmac(algorithm, key, ...buffers) {\n        algorithm = algorithm.toLowerCase();\n        const hashes = crypto.getHashes();\n        if (hashes.indexOf(algorithm) < 0) throw new Error(`HMAC algorithm '${algorithm}' not supported!`);\n\n        const hmac = crypto.createHmac(algorithm, key);\n        hmac.update(Buffer.concat(buffers));\n        return hmac.digest();\n    }\n\n    /**\n     * Encrypt/decrypt input\n     * @param {boolean} encrypt - True to encrypt, false to decrypt\n     * @param {string} cipherAlgorithm - The cipher algorithm\n     * @param {sring} cipherChaining - The cipher chaining mode\n     * @param {Buffer} key - The encryption key\n     * @param {Buffer} iv - The initialization vector\n     * @param {Buffer} input - The input\n     * @returns {Buffer} The output\n     * @private\n     */\n    _crypt(encrypt, cipherAlgorithm, cipherChaining, key, iv, input) {\n        let algorithm = `${cipherAlgorithm.toLowerCase()}-${key.length * 8}`;\n        if (cipherChaining === 'ChainingModeCBC') algorithm += '-cbc';\n        else throw new Error(`Unknown cipher chaining: ${cipherChaining}`);\n\n        const cipher = crypto[encrypt ? 'createCipheriv' : 'createDecipheriv'](algorithm, key, iv);\n        cipher.setAutoPadding(false);\n        let output = cipher.update(input);\n        output = Buffer.concat([output, cipher.final()]);\n        return output;\n    }\n\n    /**\n     * Encrypt/decrypt the package\n     * @param {boolean} encrypt - True to encrypt, false to decrypt\n     * @param {string} cipherAlgorithm - The cipher algorithm\n     * @param {string} cipherChaining - The cipher chaining mode\n     * @param {string} hashAlgorithm - The hash algorithm\n     * @param {number} blockSize - The IV block size\n     * @param {Buffer} saltValue - The salt\n     * @param {Buffer} key - The encryption key\n     * @param {Buffer} input - The package input\n     * @returns {Buffer} The output\n     * @private\n     */\n    _cryptPackage(encrypt, cipherAlgorithm, cipherChaining, hashAlgorithm, blockSize, saltValue, key, input) {\n        // The first 8 bytes is supposed to be the length, but it seems like it is really the length - 4..\n        const outputChunks = [];\n        const offset = encrypt ? 0 : PACKAGE_OFFSET;\n\n        // The package is encoded in chunks. Encrypt/decrypt each and concat.\n        let i = 0, start = 0, end = 0;\n        while (end < input.length) {\n            start = end;\n            end = start + PACKAGE_ENCRYPTION_CHUNK_SIZE;\n            if (end > input.length) end = input.length;\n\n            // Grab the next chunk\n            let inputChunk = input.slice(start + offset, end + offset);\n\n            // Pad the chunk if it is not an integer multiple of the block size\n            const remainder = inputChunk.length % blockSize;\n            if (remainder) inputChunk = Buffer.concat([inputChunk, Buffer.alloc(blockSize - remainder)]);\n\n            // Create the initialization vector\n            const iv = this._createIV(hashAlgorithm, saltValue, blockSize, i);\n\n            // Encrypt/decrypt the chunk and add it to the array\n            const outputChunk = this._crypt(encrypt, cipherAlgorithm, cipherChaining, key, iv, inputChunk);\n            outputChunks.push(outputChunk);\n\n            i++;\n        }\n\n        // Concat all of the output chunks.\n        let output = Buffer.concat(outputChunks);\n\n        if (encrypt) {\n            // Put the length of the package in the first 8 bytes\n            output = Buffer.concat([this._createUInt32LEBuffer(input.length, PACKAGE_OFFSET), output]);\n        } else {\n            // Truncate the buffer to the size in the prefix\n            const length = input.readUInt32LE(0);\n            output = output.slice(0, length);\n        }\n\n        return output;\n    }\n\n    /**\n     * Create a buffer of an integer encoded as a uint32le\n     * @param {number} value - The integer to encode\n     * @param {number} [bufferSize=4] The output buffer size in bytes\n     * @returns {Buffer} The buffer\n     * @private\n     */\n    _createUInt32LEBuffer(value, bufferSize = 4) {\n        const buffer = Buffer.alloc(bufferSize);\n        buffer.writeUInt32LE(value, 0);\n        return buffer;\n    }\n\n    /**\n     * Convert a password into an encryption key\n     * @param {string} password - The password\n     * @param {string} hashAlgorithm - The hash algoritm\n     * @param {Buffer} saltValue - The salt value\n     * @param {number} spinCount - The spin count\n     * @param {number} keyBits - The length of the key in bits\n     * @param {Buffer} blockKey - The block key\n     * @returns {Buffer} The encryption key\n     * @private\n     */\n    _convertPasswordToKey(password, hashAlgorithm, saltValue, spinCount, keyBits, blockKey) {\n        // Password must be in unicode buffer\n        const passwordBuffer = Buffer.from(password, 'utf16le');\n\n        // Generate the initial hash\n        let key = this._hash(hashAlgorithm, saltValue, passwordBuffer);\n\n        // Now regenerate until spin count\n        for (let i = 0; i < spinCount; i++) {\n            const iterator = this._createUInt32LEBuffer(i);\n            key = this._hash(hashAlgorithm, iterator, key);\n        }\n\n        // Now generate the final hash\n        key = this._hash(hashAlgorithm, key, blockKey);\n\n        // Truncate or pad as needed to get to length of keyBits\n        const keyBytes = keyBits / 8;\n        if (key.length < keyBytes) {\n            const tmp = Buffer.alloc(keyBytes, 0x36);\n            key.copy(tmp);\n            key = tmp;\n        } else if (key.length > keyBytes) {\n            key = key.slice(0, keyBytes);\n        }\n\n        return key;\n    }\n\n    /**\n     * Create an initialization vector (IV)\n     * @param {string} hashAlgorithm - The hash algorithm\n     * @param {Buffer} saltValue - The salt value\n     * @param {number} blockSize - The size of the IV\n     * @param {Buffer|number} blockKey - The block key or an int to convert to a buffer\n     * @returns {Buffer} The IV\n     * @private\n     */\n    _createIV(hashAlgorithm, saltValue, blockSize, blockKey) {\n        // Create the block key from the current index\n        if (typeof blockKey === \"number\") blockKey = this._createUInt32LEBuffer(blockKey);\n\n        // Create the initialization vector by hashing the salt with the block key.\n        // Truncate or pad as needed to meet the block size.\n        let iv = this._hash(hashAlgorithm, saltValue, blockKey);\n        if (iv.length < blockSize) {\n            const tmp = Buffer.alloc(blockSize, 0x36);\n            iv.copy(tmp);\n            iv = tmp;\n        } else if (iv.length > blockSize) {\n            iv = iv.slice(0, blockSize);\n        }\n\n        return iv;\n    }\n}\n\nmodule.exports = Encryptor;\n"]},"metadata":{},"sourceType":"script"}