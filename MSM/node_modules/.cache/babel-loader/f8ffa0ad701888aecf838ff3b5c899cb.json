{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:/Users/tzika/Desktop/Polymerlink-Front/polymerlink-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/tzika/Desktop/Polymerlink-Front/polymerlink-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar ArgHandler = require(\"./ArgHandler\");\n\nvar addressConverter = require('./addressConverter'); // Default column width.\n\n\nvar defaultColumnWidth = 9.140625;\n/**\n * A column.\n */\n\nvar Column = /*#__PURE__*/function () {\n  // /**\n  //  * Creates a new Column.\n  //  * @param {Sheet} sheet - The parent sheet.\n  //  * @param {{}} node - The column node.\n  //  * @constructor\n  //  * @ignore\n  //  * @private\n  //  */\n  function Column(sheet, node) {\n    _classCallCheck(this, Column);\n\n    this._sheet = sheet;\n    this._node = node;\n  }\n  /* PUBLIC */\n\n  /**\n   * Get the address of the column.\n   * @param {{}} [opts] - Options\n   * @param {boolean} [opts.includeSheetName] - Include the sheet name in the address.\n   * @param {boolean} [opts.anchored] - Anchor the address.\n   * @returns {string} The address\n   */\n\n\n  _createClass(Column, [{\n    key: \"address\",\n    value: function address(opts) {\n      return addressConverter.toAddress({\n        type: 'column',\n        columnName: this.columnName(),\n        sheetName: opts && opts.includeSheetName && this.sheet().name(),\n        columnAnchored: opts && opts.anchored\n      });\n    }\n    /**\n     * Get a cell within the column.\n     * @param {number} rowNumber - The row number.\n     * @returns {Cell} The cell in the column with the given row number.\n     */\n\n  }, {\n    key: \"cell\",\n    value: function cell(rowNumber) {\n      return this.sheet().cell(rowNumber, this.columnNumber());\n    }\n    /**\n     * Get the name of the column.\n     * @returns {string} The column name.\n     */\n\n  }, {\n    key: \"columnName\",\n    value: function columnName() {\n      return addressConverter.columnNumberToName(this.columnNumber());\n    }\n    /**\n     * Get the number of the column.\n     * @returns {number} The column number.\n     */\n\n  }, {\n    key: \"columnNumber\",\n    value: function columnNumber() {\n      return this._node.attributes.min;\n    }\n    /**\n     * Gets a value indicating whether the column is hidden.\n     * @returns {boolean} A flag indicating whether the column is hidden.\n     */\n\n    /**\n    * Sets whether the column is hidden.\n    * @param {boolean} hidden - A flag indicating whether to hide the column.\n    * @returns {Column} The column.\n    */\n\n  }, {\n    key: \"hidden\",\n    value: function hidden() {\n      var _this = this;\n\n      return new ArgHandler(\"Column.hidden\").case(function () {\n        return _this._node.attributes.hidden === 1;\n      }).case('boolean', function (hidden) {\n        if (hidden) _this._node.attributes.hidden = 1;else delete _this._node.attributes.hidden;\n        return _this;\n      }).handle(arguments);\n    }\n    /**\n     * Get the parent sheet.\n     * @returns {Sheet} The parent sheet.\n     */\n\n  }, {\n    key: \"sheet\",\n    value: function sheet() {\n      return this._sheet;\n    }\n    /**\n     * Gets an individual style.\n     * @param {string} name - The name of the style.\n     * @returns {*} The style.\n     */\n\n    /**\n    * Gets multiple styles.\n    * @param {Array.<string>} names - The names of the style.\n    * @returns {object.<string, *>} Object whose keys are the style names and values are the styles.\n    */\n\n    /**\n    * Sets an individual style.\n    * @param {string} name - The name of the style.\n    * @param {*} value - The value to set.\n    * @returns {Cell} The cell.\n    */\n\n    /**\n    * Sets multiple styles.\n    * @param {object.<string, *>} styles - Object whose keys are the style names and values are the styles to set.\n    * @returns {Cell} The cell.\n    */\n\n    /**\n    * Sets to a specific style\n    * @param {Style} style - Style object given from stylesheet.createStyle\n    * @returns {Cell} The cell.\n    */\n\n  }, {\n    key: \"style\",\n    value: function style() {\n      var _this2 = this;\n\n      return new ArgHandler(\"Column.style\").case('string', function (name) {\n        // Get single value\n        _this2._createStyleIfNeeded();\n\n        return _this2._style.style(name);\n      }).case('array', function (names) {\n        // Get list of values\n        var values = {};\n        names.forEach(function (name) {\n          values[name] = _this2.style(name);\n        });\n        return values;\n      }).case(['string', '*'], function (name, value) {\n        // If a row node is already defined that intersects with this column and that row has a style set, we\n        // need to make sure that a cell node exists at the intersection so we can style it appropriately.\n        // Fetching the cell will force a new cell node to be created with a style matching the column. So we\n        // will fetch and style the cell at each row that intersects this column if it is already present or it\n        // has a style defined.\n        _this2.sheet().forEachExistingRow(function (row) {\n          if (row.hasStyle() || row.hasCell(_this2.columnNumber())) {\n            row.cell(_this2.columnNumber()).style(name, value);\n          }\n        }); // Set a single value for all cells to a single value\n\n\n        _this2._createStyleIfNeeded();\n\n        _this2._style.style(name, value);\n\n        return _this2;\n      }).case('object', function (nameValues) {\n        // Object of key value pairs to set\n        for (var name in nameValues) {\n          if (!nameValues.hasOwnProperty(name)) continue;\n          var value = nameValues[name];\n\n          _this2.style(name, value);\n        }\n\n        return _this2;\n      }).case('Style', function (style) {\n        // See Large Comment Above\n        _this2.sheet().forEachExistingRow(function (row) {\n          if (row.hasStyle() || row.hasCell(_this2.columnNumber())) {\n            row.cell(_this2.columnNumber()).style(style);\n          }\n        });\n\n        _this2._style = style;\n        _this2._node.attributes.style = style.id();\n        return _this2;\n      }).handle(arguments);\n    }\n    /**\n     * Gets the width.\n     * @returns {undefined|number} The width (or undefined).\n     */\n\n    /**\n    * Sets the width.\n    * @param {number} width - The width of the column.\n    * @returns {Column} The column.\n    */\n\n  }, {\n    key: \"width\",\n    value: function width(_width) {\n      var _this3 = this;\n\n      return new ArgHandler(\"Column.width\").case(function () {\n        return _this3._node.attributes.customWidth ? _this3._node.attributes.width : undefined;\n      }).case('number', function (width) {\n        _this3._node.attributes.width = width;\n        _this3._node.attributes.customWidth = 1;\n        return _this3;\n      }).case('nil', function () {\n        delete _this3._node.attributes.width;\n        delete _this3._node.attributes.customWidth;\n        return _this3;\n      }).handle(arguments);\n    }\n    /**\n     * Get the parent workbook.\n     * @returns {Workbook} The parent workbook.\n     */\n\n  }, {\n    key: \"workbook\",\n    value: function workbook() {\n      return this.sheet().workbook();\n    }\n    /**\n     * Append vertical page break after the column.\n     * @returns {Column} the column.\n     */\n\n  }, {\n    key: \"addPageBreak\",\n    value: function addPageBreak() {\n      this.sheet().verticalPageBreaks().add(this.columnNumber());\n      return this;\n    }\n    /* INTERNAL */\n\n    /**\n     * Convert the column to an XML object.\n     * @returns {{}} The XML form.\n     * @ignore\n     */\n\n  }, {\n    key: \"toXml\",\n    value: function toXml() {\n      return this._node;\n    }\n    /* PRIVATE */\n\n    /**\n     * Create a style for this column if it doesn't already exist.\n     * @returns {undefined}\n     * @private\n     */\n\n  }, {\n    key: \"_createStyleIfNeeded\",\n    value: function _createStyleIfNeeded() {\n      if (!this._style) {\n        var styleId = this._node.attributes.style;\n        this._style = this.workbook().styleSheet().createStyle(styleId);\n        this._node.attributes.style = this._style.id();\n        if (!this.width()) this.width(defaultColumnWidth);\n      }\n    }\n  }]);\n\n  return Column;\n}();\n\nmodule.exports = Column;","map":{"version":3,"sources":["C:/Users/tzika/Desktop/Polymerlink-Front/polymerlink-2/node_modules/xlsx-populate/lib/Column.js"],"names":["ArgHandler","require","addressConverter","defaultColumnWidth","Column","sheet","node","_sheet","_node","opts","toAddress","type","columnName","sheetName","includeSheetName","name","columnAnchored","anchored","rowNumber","cell","columnNumber","columnNumberToName","attributes","min","case","hidden","handle","arguments","_createStyleIfNeeded","_style","style","names","values","forEach","value","forEachExistingRow","row","hasStyle","hasCell","nameValues","hasOwnProperty","id","width","customWidth","undefined","workbook","verticalPageBreaks","add","styleId","styleSheet","createStyle","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst ArgHandler = require(\"./ArgHandler\");\nconst addressConverter = require('./addressConverter');\n\n// Default column width.\nconst defaultColumnWidth = 9.140625;\n\n/**\n * A column.\n */\nclass Column {\n    // /**\n    //  * Creates a new Column.\n    //  * @param {Sheet} sheet - The parent sheet.\n    //  * @param {{}} node - The column node.\n    //  * @constructor\n    //  * @ignore\n    //  * @private\n    //  */\n    constructor(sheet, node) {\n        this._sheet = sheet;\n        this._node = node;\n    }\n\n    /* PUBLIC */\n\n    /**\n     * Get the address of the column.\n     * @param {{}} [opts] - Options\n     * @param {boolean} [opts.includeSheetName] - Include the sheet name in the address.\n     * @param {boolean} [opts.anchored] - Anchor the address.\n     * @returns {string} The address\n     */\n    address(opts) {\n        return addressConverter.toAddress({\n            type: 'column',\n            columnName: this.columnName(),\n            sheetName: opts && opts.includeSheetName && this.sheet().name(),\n            columnAnchored: opts && opts.anchored\n        });\n    }\n\n    /**\n     * Get a cell within the column.\n     * @param {number} rowNumber - The row number.\n     * @returns {Cell} The cell in the column with the given row number.\n     */\n    cell(rowNumber) {\n        return this.sheet().cell(rowNumber, this.columnNumber());\n    }\n\n    /**\n     * Get the name of the column.\n     * @returns {string} The column name.\n     */\n    columnName() {\n        return addressConverter.columnNumberToName(this.columnNumber());\n    }\n\n    /**\n     * Get the number of the column.\n     * @returns {number} The column number.\n     */\n    columnNumber() {\n        return this._node.attributes.min;\n    }\n\n    /**\n     * Gets a value indicating whether the column is hidden.\n     * @returns {boolean} A flag indicating whether the column is hidden.\n     *//**\n     * Sets whether the column is hidden.\n     * @param {boolean} hidden - A flag indicating whether to hide the column.\n     * @returns {Column} The column.\n     */\n    hidden() {\n        return new ArgHandler(\"Column.hidden\")\n            .case(() => {\n                return this._node.attributes.hidden === 1;\n            })\n            .case('boolean', hidden => {\n                if (hidden) this._node.attributes.hidden = 1;\n                else delete this._node.attributes.hidden;\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Get the parent sheet.\n     * @returns {Sheet} The parent sheet.\n     */\n    sheet() {\n        return this._sheet;\n    }\n\n    /**\n     * Gets an individual style.\n     * @param {string} name - The name of the style.\n     * @returns {*} The style.\n     *//**\n     * Gets multiple styles.\n     * @param {Array.<string>} names - The names of the style.\n     * @returns {object.<string, *>} Object whose keys are the style names and values are the styles.\n     *//**\n     * Sets an individual style.\n     * @param {string} name - The name of the style.\n     * @param {*} value - The value to set.\n     * @returns {Cell} The cell.\n     *//**\n     * Sets multiple styles.\n     * @param {object.<string, *>} styles - Object whose keys are the style names and values are the styles to set.\n     * @returns {Cell} The cell.\n     *//**\n\t * Sets to a specific style\n\t * @param {Style} style - Style object given from stylesheet.createStyle\n\t * @returns {Cell} The cell.\n\t */\n    style() {\n        return new ArgHandler(\"Column.style\")\n            .case('string', name => {\n                // Get single value\n                this._createStyleIfNeeded();\n                return this._style.style(name);\n            })\n            .case('array', names => {\n                // Get list of values\n                const values = {};\n                names.forEach(name => {\n                    values[name] = this.style(name);\n                });\n\n                return values;\n            })\n            .case(['string', '*'], (name, value) => {\n                // If a row node is already defined that intersects with this column and that row has a style set, we\n                // need to make sure that a cell node exists at the intersection so we can style it appropriately.\n                // Fetching the cell will force a new cell node to be created with a style matching the column. So we\n                // will fetch and style the cell at each row that intersects this column if it is already present or it\n                // has a style defined.\n                this.sheet().forEachExistingRow(row => {\n                    if (row.hasStyle() || row.hasCell(this.columnNumber())) {\n                        row.cell(this.columnNumber()).style(name, value);\n                    }\n                });\n\n                // Set a single value for all cells to a single value\n                this._createStyleIfNeeded();\n                this._style.style(name, value);\n\n                return this;\n            })\n            .case('object', nameValues => {\n                // Object of key value pairs to set\n                for (const name in nameValues) {\n                    if (!nameValues.hasOwnProperty(name)) continue;\n                    const value = nameValues[name];\n                    this.style(name, value);\n                }\n\n                return this;\n            })\n            .case('Style', style => {\n                // See Large Comment Above\n                this.sheet().forEachExistingRow(row => {\n                    if (row.hasStyle() || row.hasCell(this.columnNumber())) {\n                        row.cell(this.columnNumber()).style(style);\n                    }\n                });\n\n                this._style = style;\n                this._node.attributes.style = style.id();\n\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Gets the width.\n     * @returns {undefined|number} The width (or undefined).\n     *//**\n     * Sets the width.\n     * @param {number} width - The width of the column.\n     * @returns {Column} The column.\n     */\n    width(width) {\n        return new ArgHandler(\"Column.width\")\n            .case(() => {\n                return this._node.attributes.customWidth ? this._node.attributes.width : undefined;\n            })\n            .case('number', width => {\n                this._node.attributes.width = width;\n                this._node.attributes.customWidth = 1;\n                return this;\n            })\n            .case('nil', () => {\n                delete this._node.attributes.width;\n                delete this._node.attributes.customWidth;\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Get the parent workbook.\n     * @returns {Workbook} The parent workbook.\n     */\n    workbook() {\n        return this.sheet().workbook();\n    }\n\n    /**\n     * Append vertical page break after the column.\n     * @returns {Column} the column.\n     */\n    addPageBreak() {\n        this.sheet().verticalPageBreaks().add(this.columnNumber());\n        return this;\n    }\n\n    /* INTERNAL */\n\n    /**\n     * Convert the column to an XML object.\n     * @returns {{}} The XML form.\n     * @ignore\n     */\n    toXml() {\n        return this._node;\n    }\n\n    /* PRIVATE */\n\n    /**\n     * Create a style for this column if it doesn't already exist.\n     * @returns {undefined}\n     * @private\n     */\n    _createStyleIfNeeded() {\n        if (!this._style) {\n            const styleId = this._node.attributes.style;\n            this._style = this.workbook().styleSheet().createStyle(styleId);\n            this._node.attributes.style = this._style.id();\n\n            if (!this.width()) this.width(defaultColumnWidth);\n        }\n    }\n}\n\nmodule.exports = Column;\n"]},"metadata":{},"sourceType":"script"}