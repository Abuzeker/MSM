{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:/Users/tzika/Desktop/Polymerlink-Front/polymerlink-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/tzika/Desktop/Polymerlink-Front/polymerlink-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _ = require(\"lodash\");\n\nvar XML_DECLARATION = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"yes\\\"?>\";\n/**\n * XML document builder.\n * @private\n */\n\nvar XmlBuilder = /*#__PURE__*/function () {\n  function XmlBuilder() {\n    _classCallCheck(this, XmlBuilder);\n  }\n\n  _createClass(XmlBuilder, [{\n    key: \"build\",\n    value:\n    /**\n     * Build an XML string from the JSON object.\n     * @param {{}} node - The node.\n     * @returns {string} The XML text.\n     */\n    function build(node) {\n      this._i = 0;\n\n      var xml = this._build(node, '');\n\n      if (xml === '') return;\n      return XML_DECLARATION + xml;\n    }\n    /**\n     * Build the XML string. (This is the internal recursive method.)\n     * @param {{}} node - The node.\n     * @param {string} xml - The initial XML doc string.\n     * @returns {string} The generated XML element.\n     * @private\n     */\n\n  }, {\n    key: \"_build\",\n    value: function _build(node, xml) {\n      var _this = this;\n\n      // For CPU performance, JS engines don't truly concatenate strings; they create a tree of pointers to\n      // the various concatenated strings. The downside of this is that it consumes a lot of memory, which\n      // will cause problems with large workbooks. So periodically, we grab a character from the xml, which\n      // causes the JS engine to flatten the tree into a single string. Do this too often and CPU takes a hit.\n      // Too frequently and memory takes a hit. Every 100k nodes seems to be a good balance.\n      if (this._i++ % 1000000 === 0) {\n        this._c = xml[0];\n      } // If the node has a toXml method, call it.\n\n\n      if (node && _.isFunction(node.toXml)) node = node.toXml();\n\n      if (_.isObject(node)) {\n        // If the node is an object, then it maps to an element. Check if it has a name.\n        if (!node.name) throw new Error(\"XML node does not have name: \".concat(JSON.stringify(node))); // Add the opening tag.\n\n        xml += \"<\".concat(node.name); // Add any node attributes\n\n        _.forOwn(node.attributes, function (value, name) {\n          xml += \" \".concat(name, \"=\\\"\").concat(_this._escapeString(value, true), \"\\\"\");\n        });\n\n        if (_.isEmpty(node.children)) {\n          // Self-close the tag if no children.\n          xml += \"/>\";\n        } else {\n          xml += \">\"; // Recursively add any children.\n\n          _.forEach(node.children, function (child) {\n            // Add the children to the XML.\n            xml = _this._build(child, xml);\n          }); // Close the tag.\n\n\n          xml += \"</\".concat(node.name, \">\");\n        }\n      } else if (!_.isNil(node)) {\n        // It not an object, this should be a text node. Just add it.\n        xml += this._escapeString(node);\n      } // Return the updated XML element.\n\n\n      return xml;\n    }\n    /**\n     * Escape a string for use in XML by replacing &, \", ', <, and >.\n     * @param {*} value - The value to escape.\n     * @param {boolean} [isAttribute] - A flag indicating if this is an attribute.\n     * @returns {string} The escaped string.\n     * @private\n     */\n\n  }, {\n    key: \"_escapeString\",\n    value: function _escapeString(value, isAttribute) {\n      if (_.isNil(value)) return value;\n      value = value.toString().replace(/&/g, \"&amp;\") // Escape '&' first as the other escapes add them.\n      .replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n\n      if (isAttribute) {\n        value = value.replace(/\"/g, \"&quot;\");\n      }\n\n      return value;\n    }\n  }]);\n\n  return XmlBuilder;\n}();\n\nmodule.exports = XmlBuilder;","map":{"version":3,"sources":["C:/Users/tzika/Desktop/Polymerlink-Front/polymerlink-2/node_modules/xlsx-populate/lib/XmlBuilder.js"],"names":["_","require","XML_DECLARATION","XmlBuilder","node","_i","xml","_build","_c","isFunction","toXml","isObject","name","Error","JSON","stringify","forOwn","attributes","value","_escapeString","isEmpty","children","forEach","child","isNil","isAttribute","toString","replace","module","exports"],"mappings":"AAAA;;;;;;AAEA,IAAMA,CAAC,GAAGC,OAAO,CAAC,QAAD,CAAjB;;AAEA,IAAMC,eAAe,kEAArB;AAEA;AACA;AACA;AACA;;IACMC,U;;;;;;;;AACF;AACJ;AACA;AACA;AACA;AACI,mBAAMC,IAAN,EAAY;AACR,WAAKC,EAAL,GAAU,CAAV;;AACA,UAAMC,GAAG,GAAG,KAAKC,MAAL,CAAYH,IAAZ,EAAkB,EAAlB,CAAZ;;AACA,UAAIE,GAAG,KAAK,EAAZ,EAAgB;AAChB,aAAOJ,eAAe,GAAGI,GAAzB;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;;;;WACI,gBAAOF,IAAP,EAAaE,GAAb,EAAkB;AAAA;;AACd;AACA;AACA;AACA;AACA;AACA,UAAI,KAAKD,EAAL,KAAY,OAAZ,KAAwB,CAA5B,EAA+B;AAC3B,aAAKG,EAAL,GAAUF,GAAG,CAAC,CAAD,CAAb;AACH,OARa,CAUd;;;AACA,UAAIF,IAAI,IAAIJ,CAAC,CAACS,UAAF,CAAaL,IAAI,CAACM,KAAlB,CAAZ,EAAsCN,IAAI,GAAGA,IAAI,CAACM,KAAL,EAAP;;AAEtC,UAAIV,CAAC,CAACW,QAAF,CAAWP,IAAX,CAAJ,EAAsB;AAClB;AACA,YAAI,CAACA,IAAI,CAACQ,IAAV,EAAgB,MAAM,IAAIC,KAAJ,wCAA0CC,IAAI,CAACC,SAAL,CAAeX,IAAf,CAA1C,EAAN,CAFE,CAIlB;;AACAE,QAAAA,GAAG,eAAQF,IAAI,CAACQ,IAAb,CAAH,CALkB,CAOlB;;AACAZ,QAAAA,CAAC,CAACgB,MAAF,CAASZ,IAAI,CAACa,UAAd,EAA0B,UAACC,KAAD,EAAQN,IAAR,EAAiB;AACvCN,UAAAA,GAAG,eAAQM,IAAR,gBAAiB,KAAI,CAACO,aAAL,CAAmBD,KAAnB,EAA0B,IAA1B,CAAjB,OAAH;AACH,SAFD;;AAIA,YAAIlB,CAAC,CAACoB,OAAF,CAAUhB,IAAI,CAACiB,QAAf,CAAJ,EAA8B;AAC1B;AACAf,UAAAA,GAAG,IAAI,IAAP;AACH,SAHD,MAGO;AACHA,UAAAA,GAAG,IAAI,GAAP,CADG,CAGH;;AACAN,UAAAA,CAAC,CAACsB,OAAF,CAAUlB,IAAI,CAACiB,QAAf,EAAyB,UAAAE,KAAK,EAAI;AAC9B;AACAjB,YAAAA,GAAG,GAAG,KAAI,CAACC,MAAL,CAAYgB,KAAZ,EAAmBjB,GAAnB,CAAN;AACH,WAHD,EAJG,CASH;;;AACAA,UAAAA,GAAG,gBAASF,IAAI,CAACQ,IAAd,MAAH;AACH;AACJ,OA3BD,MA2BO,IAAI,CAACZ,CAAC,CAACwB,KAAF,CAAQpB,IAAR,CAAL,EAAoB;AACvB;AACAE,QAAAA,GAAG,IAAI,KAAKa,aAAL,CAAmBf,IAAnB,CAAP;AACH,OA3Ca,CA6Cd;;;AACA,aAAOE,GAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;;;;WACI,uBAAcY,KAAd,EAAqBO,WAArB,EAAkC;AAC9B,UAAIzB,CAAC,CAACwB,KAAF,CAAQN,KAAR,CAAJ,EAAoB,OAAOA,KAAP;AACpBA,MAAAA,KAAK,GAAGA,KAAK,CAACQ,QAAN,GACHC,OADG,CACK,IADL,EACW,OADX,EACoB;AADpB,OAEHA,OAFG,CAEK,IAFL,EAEW,MAFX,EAGHA,OAHG,CAGK,IAHL,EAGW,MAHX,CAAR;;AAKA,UAAIF,WAAJ,EAAiB;AACbP,QAAAA,KAAK,GAAGA,KAAK,CAACS,OAAN,CAAc,IAAd,EAAoB,QAApB,CAAR;AACH;;AAED,aAAOT,KAAP;AACH;;;;;;AAGLU,MAAM,CAACC,OAAP,GAAiB1B,UAAjB","sourcesContent":["\"use strict\";\n\nconst _ = require(\"lodash\");\n\nconst XML_DECLARATION = `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>`;\n\n/**\n * XML document builder.\n * @private\n */\nclass XmlBuilder {\n    /**\n     * Build an XML string from the JSON object.\n     * @param {{}} node - The node.\n     * @returns {string} The XML text.\n     */\n    build(node) {\n        this._i = 0;\n        const xml = this._build(node, '');\n        if (xml === '') return;\n        return XML_DECLARATION + xml;\n    }\n\n    /**\n     * Build the XML string. (This is the internal recursive method.)\n     * @param {{}} node - The node.\n     * @param {string} xml - The initial XML doc string.\n     * @returns {string} The generated XML element.\n     * @private\n     */\n    _build(node, xml) {\n        // For CPU performance, JS engines don't truly concatenate strings; they create a tree of pointers to\n        // the various concatenated strings. The downside of this is that it consumes a lot of memory, which\n        // will cause problems with large workbooks. So periodically, we grab a character from the xml, which\n        // causes the JS engine to flatten the tree into a single string. Do this too often and CPU takes a hit.\n        // Too frequently and memory takes a hit. Every 100k nodes seems to be a good balance.\n        if (this._i++ % 1000000 === 0) {\n            this._c = xml[0];\n        }\n\n        // If the node has a toXml method, call it.\n        if (node && _.isFunction(node.toXml)) node = node.toXml();\n\n        if (_.isObject(node)) {\n            // If the node is an object, then it maps to an element. Check if it has a name.\n            if (!node.name) throw new Error(`XML node does not have name: ${JSON.stringify(node)}`);\n\n            // Add the opening tag.\n            xml += `<${node.name}`;\n\n            // Add any node attributes\n            _.forOwn(node.attributes, (value, name) => {\n                xml += ` ${name}=\"${this._escapeString(value, true)}\"`;\n            });\n\n            if (_.isEmpty(node.children)) {\n                // Self-close the tag if no children.\n                xml += \"/>\";\n            } else {\n                xml += \">\";\n                \n                // Recursively add any children.\n                _.forEach(node.children, child => {\n                    // Add the children to the XML.\n                    xml = this._build(child, xml);\n                });\n\n                // Close the tag.\n                xml += `</${node.name}>`;\n            }\n        } else if (!_.isNil(node)) {\n            // It not an object, this should be a text node. Just add it.\n            xml += this._escapeString(node);\n        }\n\n        // Return the updated XML element.\n        return xml;\n    }\n\n    /**\n     * Escape a string for use in XML by replacing &, \", ', <, and >.\n     * @param {*} value - The value to escape.\n     * @param {boolean} [isAttribute] - A flag indicating if this is an attribute.\n     * @returns {string} The escaped string.\n     * @private\n     */\n    _escapeString(value, isAttribute) {\n        if (_.isNil(value)) return value;\n        value = value.toString()\n            .replace(/&/g, \"&amp;\") // Escape '&' first as the other escapes add them.\n            .replace(/</g, \"&lt;\")\n            .replace(/>/g, \"&gt;\");\n\n        if (isAttribute) {\n            value = value.replace(/\"/g, \"&quot;\");\n        }\n\n        return value;\n    }\n}\n\nmodule.exports = XmlBuilder;\n"]},"metadata":{},"sourceType":"script"}