{"ast":null,"code":"\"use strict\";\n\nconst _ = require(\"lodash\");\n\nconst ArgHandler = require(\"./ArgHandler\");\n\nconst addressConverter = require(\"./addressConverter\");\n\nconst dateConverter = require(\"./dateConverter\");\n\nconst regexify = require(\"./regexify\");\n\nconst xmlq = require(\"./xmlq\");\n\nconst FormulaError = require(\"./FormulaError\");\n\nconst Style = require(\"./Style\");\n\nconst RichText = require(\"./RichText\");\n/**\n * A cell\n */\n\n\nclass Cell {\n  // /**\n  //  * Creates a new instance of cell.\n  //  * @param {Row} row - The parent row.\n  //  * @param {{}} node - The cell node.\n  //  */\n  constructor(row, node, styleId) {\n    this._row = row;\n\n    this._init(node, styleId);\n  }\n  /* PUBLIC */\n\n  /**\n   * Gets a value indicating whether the cell is the active cell in the sheet.\n   * @returns {boolean} True if active, false otherwise.\n   */\n\n  /**\n  * Make the cell the active cell in the sheet.\n  * @param {boolean} active - Must be set to `true`. Deactivating directly is not supported. To deactivate, you should activate a different cell instead.\n  * @returns {Cell} The cell.\n  */\n\n\n  active() {\n    return new ArgHandler('Cell.active').case(() => {\n      return this.sheet().activeCell() === this;\n    }).case('boolean', active => {\n      if (!active) throw new Error(\"Deactivating cell directly not supported. Activate a different cell instead.\");\n      this.sheet().activeCell(this);\n      return this;\n    }).handle(arguments);\n  }\n  /**\n   * Get the address of the column.\n   * @param {{}} [opts] - Options\n   * @param {boolean} [opts.includeSheetName] - Include the sheet name in the address.\n   * @param {boolean} [opts.rowAnchored] - Anchor the row.\n   * @param {boolean} [opts.columnAnchored] - Anchor the column.\n   * @param {boolean} [opts.anchored] - Anchor both the row and the column.\n   * @returns {string} The address\n   */\n\n\n  address(opts) {\n    return addressConverter.toAddress({\n      type: 'cell',\n      rowNumber: this.rowNumber(),\n      columnNumber: this.columnNumber(),\n      sheetName: opts && opts.includeSheetName && this.sheet().name(),\n      rowAnchored: opts && (opts.rowAnchored || opts.anchored),\n      columnAnchored: opts && (opts.columnAnchored || opts.anchored)\n    });\n  }\n  /**\n   * Gets the parent column of the cell.\n   * @returns {Column} The parent column.\n   */\n\n\n  column() {\n    return this.sheet().column(this.columnNumber());\n  }\n  /**\n   * Clears the contents from the cell.\n   * @returns {Cell} The cell.\n   */\n\n\n  clear() {\n    const hostSharedFormulaId = this._formulaRef && this._sharedFormulaId;\n    delete this._value;\n    delete this._formulaType;\n    delete this._formula;\n    delete this._sharedFormulaId;\n    delete this._formulaRef; // TODO in future version: Move shared formula to some other cell. This would require parsing the formula...\n\n    if (!_.isNil(hostSharedFormulaId)) this.sheet().clearCellsUsingSharedFormula(hostSharedFormulaId);\n    return this;\n  }\n  /**\n   * Gets the column name of the cell.\n   * @returns {string} The column name.\n   */\n\n\n  columnName() {\n    return addressConverter.columnNumberToName(this.columnNumber());\n  }\n  /**\n   * Gets the column number of the cell (1-based).\n   * @returns {number} The column number.\n   */\n\n\n  columnNumber() {\n    return this._columnNumber;\n  }\n  /**\n   * Find the given pattern in the cell and optionally replace it.\n   * @param {string|RegExp} pattern - The pattern to look for. Providing a string will result in a case-insensitive substring search. Use a RegExp for more sophisticated searches.\n   * @param {string|function} [replacement] - The text to replace or a String.replace callback function. If pattern is a string, all occurrences of the pattern in the cell will be replaced.\n   * @returns {boolean} A flag indicating if the pattern was found.\n   */\n\n\n  find(pattern, replacement) {\n    pattern = regexify(pattern);\n    const value = this.value();\n    if (typeof value !== 'string') return false;\n\n    if (_.isNil(replacement)) {\n      return pattern.test(value);\n    } else {\n      const replaced = value.replace(pattern, replacement);\n      if (replaced === value) return false;\n      this.value(replaced);\n      return true;\n    }\n  }\n  /**\n   * Gets the formula in the cell. Note that if a formula was set as part of a range, the getter will return 'SHARED'. This is a limitation that may be addressed in a future release.\n   * @returns {string} The formula in the cell.\n   */\n\n  /**\n  * Sets the formula in the cell.\n  * @param {string} formula - The formula to set.\n  * @returns {Cell} The cell.\n  */\n\n\n  formula() {\n    return new ArgHandler('Cell.formula').case(() => {\n      // TODO in future: Return translated formula.\n      if (this._formulaType === \"shared\" && !this._formulaRef) return \"SHARED\";\n      return this._formula;\n    }).case('nil', () => {\n      this.clear();\n      return this;\n    }).case('string', formula => {\n      this.clear();\n      this._formulaType = \"normal\";\n      this._formula = formula;\n      return this;\n    }).handle(arguments);\n  }\n  /**\n   * Gets the hyperlink attached to the cell.\n   * @returns {string|undefined} The hyperlink or undefined if not set.\n   */\n\n  /**\n  * Set or clear the hyperlink on the cell.\n  * @param {string|Cell|undefined} hyperlink - The hyperlink to set or undefined to clear.\n  * @returns {Cell} The cell.\n  */\n\n  /**\n  * Set the hyperlink options on the cell.\n  * @param {{}|Cell} opts - Options or Cell. If opts is a Cell then an internal hyperlink is added.\n  * @param {string|Cell} [opts.hyperlink] - The hyperlink to set, can be a Cell or an internal/external string.\n  * @param {string} [opts.tooltip] - Additional text to help the user understand more about the hyperlink.\n  * @param {string} [opts.email] - Email address, ignored if opts.hyperlink is set.\n  * @param {string} [opts.emailSubject] - Email subject, ignored if opts.hyperlink is set.\n  * @returns {Cell} The cell.\n  */\n\n\n  hyperlink() {\n    return new ArgHandler('Cell.hyperlink').case(() => {\n      return this.sheet().hyperlink(this.address());\n    }).case('string', hyperlink => {\n      this.sheet().hyperlink(this.address(), hyperlink);\n      return this;\n    }).case(['object'], opts => {\n      this.sheet().hyperlink(this.address(), opts);\n      return this;\n    }).handle(arguments);\n  }\n  /**\n   * Gets the data validation object attached to the cell.\n   * @returns {object|undefined} The data validation or undefined if not set.\n   */\n\n  /**\n  * Set or clear the data validation object of the cell.\n  * @param {object|undefined} dataValidation - Object or null to clear.\n  * @returns {Cell} The cell.\n  */\n\n\n  dataValidation() {\n    return new ArgHandler('Cell.dataValidation').case(() => {\n      return this.sheet().dataValidation(this.address());\n    }).case('boolean', obj => {\n      return this.sheet().dataValidation(this.address(), obj);\n    }).case('*', obj => {\n      this.sheet().dataValidation(this.address(), obj);\n      return this;\n    }).handle(arguments);\n  }\n  /**\n   * Callback used by tap.\n   * @callback Cell~tapCallback\n   * @param {Cell} cell - The cell\n   * @returns {undefined}\n   */\n\n  /**\n  * Invoke a callback on the cell and return the cell. Useful for method chaining.\n  * @param {Cell~tapCallback} callback - The callback function.\n  * @returns {Cell} The cell.\n  */\n\n\n  tap(callback) {\n    callback(this);\n    return this;\n  }\n  /**\n   * Callback used by thru.\n   * @callback Cell~thruCallback\n   * @param {Cell} cell - The cell\n   * @returns {*} The value to return from thru.\n   */\n\n  /**\n  * Invoke a callback on the cell and return the value provided by the callback. Useful for method chaining.\n  * @param {Cell~thruCallback} callback - The callback function.\n  * @returns {*} The return value of the callback.\n  */\n\n\n  thru(callback) {\n    return callback(this);\n  }\n  /**\n   * Create a range from this cell and another.\n   * @param {Cell|string} cell - The other cell or cell address to range to.\n   * @returns {Range} The range.\n   */\n\n\n  rangeTo(cell) {\n    return this.sheet().range(this, cell);\n  }\n  /**\n   * Returns a cell with a relative position given the offsets provided.\n   * @param {number} rowOffset - The row offset (0 for the current row).\n   * @param {number} columnOffset - The column offset (0 for the current column).\n   * @returns {Cell} The relative cell.\n   */\n\n\n  relativeCell(rowOffset, columnOffset) {\n    const row = rowOffset + this.rowNumber();\n    const column = columnOffset + this.columnNumber();\n    return this.sheet().cell(row, column);\n  }\n  /**\n   * Gets the parent row of the cell.\n   * @returns {Row} The parent row.\n   */\n\n\n  row() {\n    return this._row;\n  }\n  /**\n   * Gets the row number of the cell (1-based).\n   * @returns {number} The row number.\n   */\n\n\n  rowNumber() {\n    return this.row().rowNumber();\n  }\n  /**\n   * Gets the parent sheet.\n   * @returns {Sheet} The parent sheet.\n   */\n\n\n  sheet() {\n    return this.row().sheet();\n  }\n  /**\n   * Gets an individual style.\n   * @param {string} name - The name of the style.\n   * @returns {*} The style.\n   */\n\n  /**\n  * Gets multiple styles.\n  * @param {Array.<string>} names - The names of the style.\n  * @returns {object.<string, *>} Object whose keys are the style names and values are the styles.\n  */\n\n  /**\n  * Sets an individual style.\n  * @param {string} name - The name of the style.\n  * @param {*} value - The value to set.\n  * @returns {Cell} The cell.\n  */\n\n  /**\n  * Sets the styles in the range starting with the cell.\n  * @param {string} name - The name of the style.\n  * @param {Array.<Array.<*>>} - 2D array of values to set.\n  * @returns {Range} The range that was set.\n  */\n\n  /**\n  * Sets multiple styles.\n  * @param {object.<string, *>} styles - Object whose keys are the style names and values are the styles to set.\n  * @returns {Cell} The cell.\n  */\n\n  /**\n  * Sets to a specific style\n  * @param {Style} style - Style object given from stylesheet.createStyle\n  * @returns {Cell} The cell.\n  */\n\n\n  style() {\n    if (!this._style && !(arguments[0] instanceof Style)) {\n      this._style = this.workbook().styleSheet().createStyle(this._styleId);\n    }\n\n    return new ArgHandler(\"Cell.style\").case('string', name => {\n      // Get single value\n      return this._style.style(name);\n    }).case('array', names => {\n      // Get list of values\n      const values = {};\n      names.forEach(name => {\n        values[name] = this.style(name);\n      });\n      return values;\n    }).case([\"string\", \"array\"], (name, values) => {\n      const numRows = values.length;\n      const numCols = values[0].length;\n      const range = this.rangeTo(this.relativeCell(numRows - 1, numCols - 1));\n      return range.style(name, values);\n    }).case(['string', '*'], (name, value) => {\n      // Set a single value for all cells to a single value\n      this._style.style(name, value);\n\n      return this;\n    }).case('object', nameValues => {\n      // Object of key value pairs to set\n      for (const name in nameValues) {\n        if (!nameValues.hasOwnProperty(name)) continue;\n        const value = nameValues[name];\n        this.style(name, value);\n      }\n\n      return this;\n    }).case('Style', style => {\n      this._style = style;\n      this._styleId = style.id();\n      return this;\n    }).handle(arguments);\n  }\n  /**\n   * Gets the value of the cell.\n   * @returns {string|boolean|number|Date|RichText|undefined} The value of the cell.\n   */\n\n  /**\n  * Sets the value of the cell.\n  * @param {string|boolean|number|null|undefined|RichText} value - The value to set.\n  * @returns {Cell} The cell.\n  */\n\n  /**\n  * Sets the values in the range starting with the cell.\n  * @param {Array.<Array.<string|boolean|number|null|undefined>>} - 2D array of values to set.\n  * @returns {Range} The range that was set.\n  */\n\n\n  value() {\n    return new ArgHandler('Cell.value').case(() => {\n      if (this._value instanceof RichText) {\n        return this._value.getInstanceWithCellRef(this);\n      }\n\n      return this._value;\n    }).case(\"array\", values => {\n      const numRows = values.length;\n      const numCols = values[0].length;\n      const range = this.rangeTo(this.relativeCell(numRows - 1, numCols - 1));\n      return range.value(values);\n    }).case('*', value => {\n      this.clear();\n\n      if (value instanceof RichText) {\n        this._value = value.copy(this);\n      } else {\n        this._value = value;\n      }\n\n      return this;\n    }).handle(arguments);\n  }\n  /**\n   * Gets the parent workbook.\n   * @returns {Workbook} The parent workbook.\n   */\n\n\n  workbook() {\n    return this.row().workbook();\n  }\n  /**\n   * Append horizontal page break after the cell.\n   * @returns {Cell} the cell.\n   */\n\n\n  addHorizontalPageBreak() {\n    this.row().addPageBreak();\n    return this;\n  }\n  /* INTERNAL */\n\n  /**\n   * Gets the formula if a shared formula ref cell.\n   * @returns {string|undefined} The formula.\n   * @ignore\n   */\n\n\n  getSharedRefFormula() {\n    return this._formulaType === \"shared\" ? this._formulaRef && this._formula : undefined;\n  }\n  /**\n   * Check if this cell uses a given shared a formula ID.\n   * @param {number} id - The shared formula ID.\n   * @returns {boolean} A flag indicating if shared.\n   * @ignore\n   */\n\n\n  sharesFormula(id) {\n    return this._formulaType === \"shared\" && this._sharedFormulaId === id;\n  }\n  /**\n   * Set a shared formula on the cell.\n   * @param {number} id - The shared formula index.\n   * @param {string} [formula] - The formula (if the reference cell).\n   * @param {string} [sharedRef] - The address of the shared range (if the reference cell).\n   * @returns {undefined}\n   * @ignore\n   */\n\n\n  setSharedFormula(id, formula, sharedRef) {\n    this.clear();\n    this._formulaType = \"shared\";\n    this._sharedFormulaId = id;\n    this._formula = formula;\n    this._formulaRef = sharedRef;\n  }\n  /**\n   * Convert the cell to an XML object.\n   * @returns {{}} The XML form.\n   * @ignore\n   */\n\n\n  toXml() {\n    // Create a node.\n    const node = {\n      name: 'c',\n      attributes: this._remainingAttributes || {},\n      // Start with any remaining attributes we don't current handle.\n      children: []\n    }; // Set the address.\n\n    node.attributes.r = this.address();\n\n    if (!_.isNil(this._formulaType)) {\n      // Add the formula.\n      const fNode = {\n        name: 'f',\n        attributes: this._remainingFormulaAttributes || {}\n      };\n      if (this._formulaType !== \"normal\") fNode.attributes.t = this._formulaType;\n      if (!_.isNil(this._formulaRef)) fNode.attributes.ref = this._formulaRef;\n      if (!_.isNil(this._sharedFormulaId)) fNode.attributes.si = this._sharedFormulaId;\n      if (!_.isNil(this._formula)) fNode.children = [this._formula];\n      node.children.push(fNode);\n    } else if (!_.isNil(this._value)) {\n      // Add the value. Don't emit value if a formula is set as Excel will show this stale value.\n      let type, text;\n\n      if (typeof this._value === \"string\") {\n        type = \"s\";\n        text = this.workbook().sharedStrings().getIndexForString(this._value);\n      } else if (typeof this._value === \"boolean\") {\n        type = \"b\";\n        text = this._value ? 1 : 0;\n      } else if (typeof this._value === \"number\") {\n        text = this._value;\n      } else if (this._value instanceof Date) {\n        text = dateConverter.dateToNumber(this._value);\n      } else if (this._value instanceof RichText || typeof this._value === \"object\" && this._value.constructor.name === \"RichText\") {\n        // Hack to make Jasmine test work\n        type = \"s\";\n        text = this.workbook().sharedStrings().getIndexForString(this._value.toXml());\n      }\n\n      if (type) node.attributes.t = type;\n      const vNode = {\n        name: 'v',\n        children: [text]\n      };\n      node.children.push(vNode);\n    } // If the style is set, set the style ID.\n\n\n    if (!_.isNil(this._style)) {\n      node.attributes.s = this._style.id();\n    } else if (!_.isNil(this._styleId)) {\n      node.attributes.s = this._styleId;\n    } // Add any remaining children that we don't currently handle.\n\n\n    if (this._remainingChildren) {\n      node.children = node.children.concat(this._remainingChildren);\n    }\n\n    return node;\n  }\n  /* PRIVATE */\n\n  /**\n   * Initialize the cell node.\n   * @param {{}|number} nodeOrColumnNumber - The existing node or the column number of a new cell.\n   * @param {number} [styleId] - The style ID for the new cell.\n   * @returns {undefined}\n   * @private\n   */\n\n\n  _init(nodeOrColumnNumber, styleId) {\n    if (_.isObject(nodeOrColumnNumber)) {\n      // Parse the existing node.\n      this._parseNode(nodeOrColumnNumber);\n    } else {\n      // This is a new cell.\n      this._columnNumber = nodeOrColumnNumber;\n      if (!_.isNil(styleId)) this._styleId = styleId;\n    }\n  }\n  /**\n   * Parse the existing node.\n   * @param {{}} node - The existing node.\n   * @returns {undefined}\n   * @private\n   */\n\n\n  _parseNode(node) {\n    // Parse the column numbr out of the address.\n    const ref = addressConverter.fromAddress(node.attributes.r);\n    this._columnNumber = ref.columnNumber; // Store the style ID if present.\n\n    if (!_.isNil(node.attributes.s)) this._styleId = node.attributes.s; // Parse the formula if present..\n\n    const fNode = xmlq.findChild(node, 'f');\n\n    if (fNode) {\n      this._formulaType = fNode.attributes.t || \"normal\";\n      this._formulaRef = fNode.attributes.ref;\n      this._formula = fNode.children[0];\n      this._sharedFormulaId = fNode.attributes.si;\n\n      if (!_.isNil(this._sharedFormulaId)) {\n        // Update the sheet's max shared formula ID so we can set future IDs an index beyond this.\n        this.sheet().updateMaxSharedFormulaId(this._sharedFormulaId);\n      } // Delete the known attributes.\n\n\n      delete fNode.attributes.t;\n      delete fNode.attributes.ref;\n      delete fNode.attributes.si; // If any unknown attributes are still present, store them for later output.\n\n      if (!_.isEmpty(fNode.attributes)) this._remainingFormulaAttributes = fNode.attributes;\n    } // Parse the value.\n\n\n    const type = node.attributes.t;\n\n    if (type === \"s\") {\n      // String value.\n      const vNode = xmlq.findChild(node, 'v');\n\n      if (vNode) {\n        const sharedIndex = vNode.children[0];\n        this._value = this.workbook().sharedStrings().getStringByIndex(sharedIndex); // rich text\n\n        if (_.isArray(this._value)) {\n          this._value = new RichText(this._value);\n        }\n      } else {\n        this._value = '';\n      }\n    } else if (type === \"str\") {\n      // Simple string value.\n      const vNode = xmlq.findChild(node, 'v');\n      this._value = vNode && vNode.children[0];\n    } else if (type === \"inlineStr\") {\n      // Inline string value: can be simple text or rich text.\n      const isNode = xmlq.findChild(node, 'is');\n\n      if (isNode.children[0].name === \"t\") {\n        const tNode = isNode.children[0];\n        this._value = tNode.children[0];\n      } else {\n        this._value = isNode.children;\n      }\n    } else if (type === \"b\") {\n      // Boolean value.\n      this._value = xmlq.findChild(node, 'v').children[0] === 1;\n    } else if (type === \"e\") {\n      // Error value.\n      const error = xmlq.findChild(node, 'v').children[0];\n      this._value = FormulaError.getError(error);\n    } else {\n      // Number value.\n      const vNode = xmlq.findChild(node, 'v');\n      this._value = vNode && Number(vNode.children[0]);\n    } // Delete known attributes.\n\n\n    delete node.attributes.r;\n    delete node.attributes.s;\n    delete node.attributes.t; // If any unknown attributes are still present, store them for later output.\n\n    if (!_.isEmpty(node.attributes)) this._remainingAttributes = node.attributes; // Delete known children.\n\n    xmlq.removeChild(node, 'f');\n    xmlq.removeChild(node, 'v');\n    xmlq.removeChild(node, 'is'); // If any unknown children are still present, store them for later output.\n\n    if (!_.isEmpty(node.children)) this._remainingChildren = node.children;\n  }\n\n}\n\nmodule.exports = Cell;\n/*\n<c r=\"A6\" s=\"1\" t=\"s\">\n    <v>2</v>\n</c>\n*/","map":{"version":3,"sources":["C:/Users/tzika/Desktop/MSM-Front/MSM/node_modules/xlsx-populate/lib/Cell.js"],"names":["_","require","ArgHandler","addressConverter","dateConverter","regexify","xmlq","FormulaError","Style","RichText","Cell","constructor","row","node","styleId","_row","_init","active","case","sheet","activeCell","Error","handle","arguments","address","opts","toAddress","type","rowNumber","columnNumber","sheetName","includeSheetName","name","rowAnchored","anchored","columnAnchored","column","clear","hostSharedFormulaId","_formulaRef","_sharedFormulaId","_value","_formulaType","_formula","isNil","clearCellsUsingSharedFormula","columnName","columnNumberToName","_columnNumber","find","pattern","replacement","value","test","replaced","replace","formula","hyperlink","dataValidation","obj","tap","callback","thru","rangeTo","cell","range","relativeCell","rowOffset","columnOffset","style","_style","workbook","styleSheet","createStyle","_styleId","names","values","forEach","numRows","length","numCols","nameValues","hasOwnProperty","id","getInstanceWithCellRef","copy","addHorizontalPageBreak","addPageBreak","getSharedRefFormula","undefined","sharesFormula","setSharedFormula","sharedRef","toXml","attributes","_remainingAttributes","children","r","fNode","_remainingFormulaAttributes","t","ref","si","push","text","sharedStrings","getIndexForString","Date","dateToNumber","vNode","s","_remainingChildren","concat","nodeOrColumnNumber","isObject","_parseNode","fromAddress","findChild","updateMaxSharedFormulaId","isEmpty","sharedIndex","getStringByIndex","isArray","isNode","tNode","error","getError","Number","removeChild","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst _ = require(\"lodash\");\nconst ArgHandler = require(\"./ArgHandler\");\nconst addressConverter = require(\"./addressConverter\");\nconst dateConverter = require(\"./dateConverter\");\nconst regexify = require(\"./regexify\");\nconst xmlq = require(\"./xmlq\");\nconst FormulaError = require(\"./FormulaError\");\nconst Style = require(\"./Style\");\nconst RichText = require(\"./RichText\");\n\n/**\n * A cell\n */\nclass Cell {\n    // /**\n    //  * Creates a new instance of cell.\n    //  * @param {Row} row - The parent row.\n    //  * @param {{}} node - The cell node.\n    //  */\n    constructor(row, node, styleId) {\n        this._row = row;\n        this._init(node, styleId);\n    }\n\n    /* PUBLIC */\n\n    /**\n     * Gets a value indicating whether the cell is the active cell in the sheet.\n     * @returns {boolean} True if active, false otherwise.\n     *//**\n     * Make the cell the active cell in the sheet.\n     * @param {boolean} active - Must be set to `true`. Deactivating directly is not supported. To deactivate, you should activate a different cell instead.\n     * @returns {Cell} The cell.\n     */\n    active() {\n        return new ArgHandler('Cell.active')\n            .case(() => {\n                return this.sheet().activeCell() === this;\n            })\n            .case('boolean', active => {\n                if (!active) throw new Error(\"Deactivating cell directly not supported. Activate a different cell instead.\");\n                this.sheet().activeCell(this);\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Get the address of the column.\n     * @param {{}} [opts] - Options\n     * @param {boolean} [opts.includeSheetName] - Include the sheet name in the address.\n     * @param {boolean} [opts.rowAnchored] - Anchor the row.\n     * @param {boolean} [opts.columnAnchored] - Anchor the column.\n     * @param {boolean} [opts.anchored] - Anchor both the row and the column.\n     * @returns {string} The address\n     */\n    address(opts) {\n        return addressConverter.toAddress({\n            type: 'cell',\n            rowNumber: this.rowNumber(),\n            columnNumber: this.columnNumber(),\n            sheetName: opts && opts.includeSheetName && this.sheet().name(),\n            rowAnchored: opts && (opts.rowAnchored || opts.anchored),\n            columnAnchored: opts && (opts.columnAnchored || opts.anchored)\n        });\n    }\n\n    /**\n     * Gets the parent column of the cell.\n     * @returns {Column} The parent column.\n     */\n    column() {\n        return this.sheet().column(this.columnNumber());\n    }\n\n    /**\n     * Clears the contents from the cell.\n     * @returns {Cell} The cell.\n     */\n    clear() {\n        const hostSharedFormulaId = this._formulaRef && this._sharedFormulaId;\n\n        delete this._value;\n        delete this._formulaType;\n        delete this._formula;\n        delete this._sharedFormulaId;\n        delete this._formulaRef;\n\n        // TODO in future version: Move shared formula to some other cell. This would require parsing the formula...\n        if (!_.isNil(hostSharedFormulaId)) this.sheet().clearCellsUsingSharedFormula(hostSharedFormulaId);\n\n        return this;\n    }\n\n    /**\n     * Gets the column name of the cell.\n     * @returns {string} The column name.\n     */\n    columnName() {\n        return addressConverter.columnNumberToName(this.columnNumber());\n    }\n\n    /**\n     * Gets the column number of the cell (1-based).\n     * @returns {number} The column number.\n     */\n    columnNumber() {\n        return this._columnNumber;\n    }\n\n    /**\n     * Find the given pattern in the cell and optionally replace it.\n     * @param {string|RegExp} pattern - The pattern to look for. Providing a string will result in a case-insensitive substring search. Use a RegExp for more sophisticated searches.\n     * @param {string|function} [replacement] - The text to replace or a String.replace callback function. If pattern is a string, all occurrences of the pattern in the cell will be replaced.\n     * @returns {boolean} A flag indicating if the pattern was found.\n     */\n    find(pattern, replacement) {\n        pattern = regexify(pattern);\n\n        const value = this.value();\n        if (typeof value !== 'string') return false;\n\n        if (_.isNil(replacement)) {\n            return pattern.test(value);\n        } else {\n            const replaced = value.replace(pattern, replacement);\n            if (replaced === value) return false;\n            this.value(replaced);\n            return true;\n        }\n    }\n\n    /**\n     * Gets the formula in the cell. Note that if a formula was set as part of a range, the getter will return 'SHARED'. This is a limitation that may be addressed in a future release.\n     * @returns {string} The formula in the cell.\n     *//**\n     * Sets the formula in the cell.\n     * @param {string} formula - The formula to set.\n     * @returns {Cell} The cell.\n     */\n    formula() {\n        return new ArgHandler('Cell.formula')\n            .case(() => {\n                // TODO in future: Return translated formula.\n                if (this._formulaType === \"shared\" && !this._formulaRef) return \"SHARED\";\n                return this._formula;\n            })\n            .case('nil', () => {\n                this.clear();\n                return this;\n            })\n            .case('string', formula => {\n                this.clear();\n                this._formulaType = \"normal\";\n                this._formula = formula;\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Gets the hyperlink attached to the cell.\n     * @returns {string|undefined} The hyperlink or undefined if not set.\n     *//**\n     * Set or clear the hyperlink on the cell.\n     * @param {string|Cell|undefined} hyperlink - The hyperlink to set or undefined to clear.\n     * @returns {Cell} The cell.\n     *//**\n     * Set the hyperlink options on the cell.\n     * @param {{}|Cell} opts - Options or Cell. If opts is a Cell then an internal hyperlink is added.\n     * @param {string|Cell} [opts.hyperlink] - The hyperlink to set, can be a Cell or an internal/external string.\n     * @param {string} [opts.tooltip] - Additional text to help the user understand more about the hyperlink.\n     * @param {string} [opts.email] - Email address, ignored if opts.hyperlink is set.\n     * @param {string} [opts.emailSubject] - Email subject, ignored if opts.hyperlink is set.\n     * @returns {Cell} The cell.\n     */\n    hyperlink() {\n        return new ArgHandler('Cell.hyperlink')\n            .case(() => {\n                return this.sheet().hyperlink(this.address());\n            })\n            .case('string', hyperlink => {\n                this.sheet().hyperlink(this.address(), hyperlink);\n                return this;\n            })\n            .case(['object'], opts => {\n                this.sheet().hyperlink(this.address(), opts);\n                return this;\n            })\n            .handle(arguments);\n    }\n\n\n    /**\n     * Gets the data validation object attached to the cell.\n     * @returns {object|undefined} The data validation or undefined if not set.\n     *//**\n     * Set or clear the data validation object of the cell.\n     * @param {object|undefined} dataValidation - Object or null to clear.\n     * @returns {Cell} The cell.\n     */\n    dataValidation() {\n        return new ArgHandler('Cell.dataValidation')\n            .case(() => {\n                return this.sheet().dataValidation(this.address());\n            })\n            .case('boolean', obj => {\n                return this.sheet().dataValidation(this.address(), obj);\n            })\n            .case('*', obj => {\n                this.sheet().dataValidation(this.address(), obj);\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Callback used by tap.\n     * @callback Cell~tapCallback\n     * @param {Cell} cell - The cell\n     * @returns {undefined}\n     *//**\n     * Invoke a callback on the cell and return the cell. Useful for method chaining.\n     * @param {Cell~tapCallback} callback - The callback function.\n     * @returns {Cell} The cell.\n     */\n    tap(callback) {\n        callback(this);\n        return this;\n    }\n\n    /**\n     * Callback used by thru.\n     * @callback Cell~thruCallback\n     * @param {Cell} cell - The cell\n     * @returns {*} The value to return from thru.\n     *//**\n     * Invoke a callback on the cell and return the value provided by the callback. Useful for method chaining.\n     * @param {Cell~thruCallback} callback - The callback function.\n     * @returns {*} The return value of the callback.\n     */\n    thru(callback) {\n        return callback(this);\n    }\n\n    /**\n     * Create a range from this cell and another.\n     * @param {Cell|string} cell - The other cell or cell address to range to.\n     * @returns {Range} The range.\n     */\n    rangeTo(cell) {\n        return this.sheet().range(this, cell);\n    }\n\n    /**\n     * Returns a cell with a relative position given the offsets provided.\n     * @param {number} rowOffset - The row offset (0 for the current row).\n     * @param {number} columnOffset - The column offset (0 for the current column).\n     * @returns {Cell} The relative cell.\n     */\n    relativeCell(rowOffset, columnOffset) {\n        const row = rowOffset + this.rowNumber();\n        const column = columnOffset + this.columnNumber();\n        return this.sheet().cell(row, column);\n    }\n\n    /**\n     * Gets the parent row of the cell.\n     * @returns {Row} The parent row.\n     */\n    row() {\n        return this._row;\n    }\n\n    /**\n     * Gets the row number of the cell (1-based).\n     * @returns {number} The row number.\n     */\n    rowNumber() {\n        return this.row().rowNumber();\n    }\n\n    /**\n     * Gets the parent sheet.\n     * @returns {Sheet} The parent sheet.\n     */\n    sheet() {\n        return this.row().sheet();\n    }\n\n    /**\n     * Gets an individual style.\n     * @param {string} name - The name of the style.\n     * @returns {*} The style.\n     *//**\n     * Gets multiple styles.\n     * @param {Array.<string>} names - The names of the style.\n     * @returns {object.<string, *>} Object whose keys are the style names and values are the styles.\n     *//**\n     * Sets an individual style.\n     * @param {string} name - The name of the style.\n     * @param {*} value - The value to set.\n     * @returns {Cell} The cell.\n     *//**\n     * Sets the styles in the range starting with the cell.\n     * @param {string} name - The name of the style.\n     * @param {Array.<Array.<*>>} - 2D array of values to set.\n     * @returns {Range} The range that was set.\n     *//**\n     * Sets multiple styles.\n     * @param {object.<string, *>} styles - Object whose keys are the style names and values are the styles to set.\n     * @returns {Cell} The cell.\n     *//**\n     * Sets to a specific style\n     * @param {Style} style - Style object given from stylesheet.createStyle\n     * @returns {Cell} The cell.\n     */\n    style() {\n        if (!this._style && !(arguments[0] instanceof Style)) {\n            this._style = this.workbook().styleSheet().createStyle(this._styleId);\n        }\n\n        return new ArgHandler(\"Cell.style\")\n            .case('string', name => {\n                // Get single value\n                return this._style.style(name);\n            })\n            .case('array', names => {\n                // Get list of values\n                const values = {};\n                names.forEach(name => {\n                    values[name] = this.style(name);\n                });\n\n                return values;\n            })\n            .case([\"string\", \"array\"], (name, values) => {\n                const numRows = values.length;\n                const numCols = values[0].length;\n                const range = this.rangeTo(this.relativeCell(numRows - 1, numCols - 1));\n                return range.style(name, values);\n            })\n            .case(['string', '*'], (name, value) => {\n                // Set a single value for all cells to a single value\n                this._style.style(name, value);\n                return this;\n            })\n            .case('object', nameValues => {\n                // Object of key value pairs to set\n                for (const name in nameValues) {\n                    if (!nameValues.hasOwnProperty(name)) continue;\n                    const value = nameValues[name];\n                    this.style(name, value);\n                }\n\n                return this;\n            })\n            .case('Style', style => {\n                this._style = style;\n                this._styleId = style.id();\n\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Gets the value of the cell.\n     * @returns {string|boolean|number|Date|RichText|undefined} The value of the cell.\n     *//**\n     * Sets the value of the cell.\n     * @param {string|boolean|number|null|undefined|RichText} value - The value to set.\n     * @returns {Cell} The cell.\n     *//**\n     * Sets the values in the range starting with the cell.\n     * @param {Array.<Array.<string|boolean|number|null|undefined>>} - 2D array of values to set.\n     * @returns {Range} The range that was set.\n     */\n    value() {\n        return new ArgHandler('Cell.value')\n            .case(() => {\n                if (this._value instanceof RichText) {\n                    return this._value.getInstanceWithCellRef(this);\n                }\n                return this._value;\n            })\n            .case(\"array\", values => {\n                const numRows = values.length;\n                const numCols = values[0].length;\n                const range = this.rangeTo(this.relativeCell(numRows - 1, numCols - 1));\n                return range.value(values);\n            })\n            .case('*', value => {\n                this.clear();\n                if (value instanceof RichText) {\n                    this._value = value.copy(this);\n                } else {\n                    this._value = value;\n                }\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Gets the parent workbook.\n     * @returns {Workbook} The parent workbook.\n     */\n    workbook() {\n        return this.row().workbook();\n    }\n\n    /**\n     * Append horizontal page break after the cell.\n     * @returns {Cell} the cell.\n     */\n    addHorizontalPageBreak() {\n        this.row().addPageBreak();\n        return this;\n    }\n\n    /* INTERNAL */\n\n    /**\n     * Gets the formula if a shared formula ref cell.\n     * @returns {string|undefined} The formula.\n     * @ignore\n     */\n    getSharedRefFormula() {\n        return this._formulaType === \"shared\" ? this._formulaRef && this._formula : undefined;\n    }\n\n    /**\n     * Check if this cell uses a given shared a formula ID.\n     * @param {number} id - The shared formula ID.\n     * @returns {boolean} A flag indicating if shared.\n     * @ignore\n     */\n    sharesFormula(id) {\n        return this._formulaType === \"shared\" && this._sharedFormulaId === id;\n    }\n\n    /**\n     * Set a shared formula on the cell.\n     * @param {number} id - The shared formula index.\n     * @param {string} [formula] - The formula (if the reference cell).\n     * @param {string} [sharedRef] - The address of the shared range (if the reference cell).\n     * @returns {undefined}\n     * @ignore\n     */\n    setSharedFormula(id, formula, sharedRef) {\n        this.clear();\n\n        this._formulaType = \"shared\";\n        this._sharedFormulaId = id;\n        this._formula = formula;\n        this._formulaRef = sharedRef;\n    }\n\n    /**\n     * Convert the cell to an XML object.\n     * @returns {{}} The XML form.\n     * @ignore\n     */\n    toXml() {\n        // Create a node.\n        const node = {\n            name: 'c',\n            attributes: this._remainingAttributes || {}, // Start with any remaining attributes we don't current handle.\n            children: []\n        };\n\n        // Set the address.\n        node.attributes.r = this.address();\n\n        if (!_.isNil(this._formulaType)) {\n            // Add the formula.\n            const fNode = {\n                name: 'f',\n                attributes: this._remainingFormulaAttributes || {}\n            };\n\n            if (this._formulaType !== \"normal\") fNode.attributes.t = this._formulaType;\n            if (!_.isNil(this._formulaRef)) fNode.attributes.ref = this._formulaRef;\n            if (!_.isNil(this._sharedFormulaId)) fNode.attributes.si = this._sharedFormulaId;\n            if (!_.isNil(this._formula)) fNode.children = [this._formula];\n\n            node.children.push(fNode);\n        } else if (!_.isNil(this._value)) {\n            // Add the value. Don't emit value if a formula is set as Excel will show this stale value.\n            let type, text;\n            if (typeof this._value === \"string\") {\n                type = \"s\";\n                text = this.workbook().sharedStrings().getIndexForString(this._value);\n            } else if (typeof this._value === \"boolean\") {\n                type = \"b\";\n                text = this._value ? 1 : 0;\n            } else if (typeof this._value === \"number\") {\n                text = this._value;\n            } else if (this._value instanceof Date) {\n                text = dateConverter.dateToNumber(this._value);\n            } else if (this._value instanceof RichText || typeof this._value === \"object\" && this._value.constructor.name === \"RichText\") { // Hack to make Jasmine test work\n                type = \"s\";\n                text = this.workbook().sharedStrings().getIndexForString(this._value.toXml());\n            }\n\n            if (type) node.attributes.t = type;\n            const vNode = { name: 'v', children: [text] };\n            node.children.push(vNode);\n        }\n\n        // If the style is set, set the style ID.\n        if (!_.isNil(this._style)) {\n            node.attributes.s = this._style.id();\n        } else if (!_.isNil(this._styleId)) {\n            node.attributes.s = this._styleId;\n        }\n\n        // Add any remaining children that we don't currently handle.\n        if (this._remainingChildren) {\n            node.children = node.children.concat(this._remainingChildren);\n        }\n\n        return node;\n    }\n\n    /* PRIVATE */\n\n    /**\n     * Initialize the cell node.\n     * @param {{}|number} nodeOrColumnNumber - The existing node or the column number of a new cell.\n     * @param {number} [styleId] - The style ID for the new cell.\n     * @returns {undefined}\n     * @private\n     */\n    _init(nodeOrColumnNumber, styleId) {\n        if (_.isObject(nodeOrColumnNumber)) {\n            // Parse the existing node.\n            this._parseNode(nodeOrColumnNumber);\n        } else {\n            // This is a new cell.\n            this._columnNumber = nodeOrColumnNumber;\n            if (!_.isNil(styleId)) this._styleId = styleId;\n        }\n    }\n\n    /**\n     * Parse the existing node.\n     * @param {{}} node - The existing node.\n     * @returns {undefined}\n     * @private\n     */\n    _parseNode(node) {\n        // Parse the column numbr out of the address.\n        const ref = addressConverter.fromAddress(node.attributes.r);\n        this._columnNumber = ref.columnNumber;\n\n        // Store the style ID if present.\n        if (!_.isNil(node.attributes.s)) this._styleId = node.attributes.s;\n\n        // Parse the formula if present..\n        const fNode = xmlq.findChild(node, 'f');\n        if (fNode) {\n            this._formulaType = fNode.attributes.t || \"normal\";\n            this._formulaRef = fNode.attributes.ref;\n            this._formula = fNode.children[0];\n\n            this._sharedFormulaId = fNode.attributes.si;\n            if (!_.isNil(this._sharedFormulaId)) {\n                // Update the sheet's max shared formula ID so we can set future IDs an index beyond this.\n                this.sheet().updateMaxSharedFormulaId(this._sharedFormulaId);\n            }\n\n            // Delete the known attributes.\n            delete fNode.attributes.t;\n            delete fNode.attributes.ref;\n            delete fNode.attributes.si;\n\n            // If any unknown attributes are still present, store them for later output.\n            if (!_.isEmpty(fNode.attributes)) this._remainingFormulaAttributes = fNode.attributes;\n        }\n\n        // Parse the value.\n        const type = node.attributes.t;\n        if (type === \"s\") {\n            // String value.\n            const vNode = xmlq.findChild(node, 'v');\n            if (vNode) {\n                const sharedIndex = vNode.children[0];\n                this._value = this.workbook().sharedStrings().getStringByIndex(sharedIndex);\n\n                // rich text\n                if (_.isArray(this._value)) {\n                    this._value = new RichText(this._value);\n                }\n            } else {\n                this._value = '';\n            }\n        } else if (type === \"str\") {\n            // Simple string value.\n            const vNode = xmlq.findChild(node, 'v');\n            this._value = vNode && vNode.children[0];\n        } else if (type === \"inlineStr\") {\n            // Inline string value: can be simple text or rich text.\n            const isNode = xmlq.findChild(node, 'is');\n            if (isNode.children[0].name === \"t\") {\n                const tNode = isNode.children[0];\n                this._value = tNode.children[0];\n            } else {\n                this._value = isNode.children;\n            }\n        } else if (type === \"b\") {\n            // Boolean value.\n            this._value = xmlq.findChild(node, 'v').children[0] === 1;\n        } else if (type === \"e\") {\n            // Error value.\n            const error = xmlq.findChild(node, 'v').children[0];\n            this._value = FormulaError.getError(error);\n        } else {\n            // Number value.\n            const vNode = xmlq.findChild(node, 'v');\n            this._value = vNode && Number(vNode.children[0]);\n        }\n\n        // Delete known attributes.\n        delete node.attributes.r;\n        delete node.attributes.s;\n        delete node.attributes.t;\n\n        // If any unknown attributes are still present, store them for later output.\n        if (!_.isEmpty(node.attributes)) this._remainingAttributes = node.attributes;\n\n        // Delete known children.\n        xmlq.removeChild(node, 'f');\n        xmlq.removeChild(node, 'v');\n        xmlq.removeChild(node, 'is');\n\n        // If any unknown children are still present, store them for later output.\n        if (!_.isEmpty(node.children)) this._remainingChildren = node.children;\n    }\n}\n\nmodule.exports = Cell;\n\n/*\n<c r=\"A6\" s=\"1\" t=\"s\">\n    <v>2</v>\n</c>\n*/\n\n"]},"metadata":{},"sourceType":"script"}