{"ast":null,"code":"\"use strict\";\n\nconst _ = require(\"lodash\");\n\nconst fs = require(\"fs\");\n\nconst JSZip = require('jszip');\n\nconst externals = require(\"./externals\");\n\nconst regexify = require(\"./regexify\");\n\nconst blank = require(\"./blank\")();\n\nconst xmlq = require(\"./xmlq\");\n\nconst Sheet = require(\"./Sheet\");\n\nconst ContentTypes = require(\"./ContentTypes\");\n\nconst AppProperties = require(\"./AppProperties\");\n\nconst CoreProperties = require(\"./CoreProperties\");\n\nconst Relationships = require(\"./Relationships\");\n\nconst SharedStrings = require(\"./SharedStrings\");\n\nconst StyleSheet = require(\"./StyleSheet\");\n\nconst Encryptor = require(\"./Encryptor\");\n\nconst XmlParser = require(\"./XmlParser\");\n\nconst XmlBuilder = require(\"./XmlBuilder\");\n\nconst ArgHandler = require(\"./ArgHandler\");\n\nconst addressConverter = require(\"./addressConverter\"); // Options for adding files to zip. Do not create folders and use a fixed time at epoch.\n// The default JSZip behavior uses current time, which causes idential workbooks to be different each time.\n\n\nconst zipFileOpts = {\n  date: new Date(0),\n  createFolders: false\n}; // Initialize the parser and builder.\n\nconst xmlParser = new XmlParser();\nconst xmlBuilder = new XmlBuilder(); // Initialize the encryptor if present (can be excluded in browser build).\n\nconst encryptor = typeof Encryptor === \"function\" && new Encryptor(); // Characters not allowed in sheet names.\n\nconst badSheetNameChars = ['\\\\', '/', '*', '[', ']', ':', '?']; // Excel limits sheet names to 31 chars.\n\nconst maxSheetNameLength = 31; // Order of the nodes as defined by the spec.\n\nconst nodeOrder = [\"fileVersion\", \"fileSharing\", \"workbookPr\", \"workbookProtection\", \"bookViews\", \"sheets\", \"functionGroups\", \"externalReferences\", \"definedNames\", \"calcPr\", \"oleSize\", \"customWorkbookViews\", \"pivotCaches\", \"smartTagPr\", \"smartTagTypes\", \"webPublishing\", \"fileRecoveryPr\", \"webPublishObjects\", \"extLst\"];\n/**\n * A workbook.\n */\n\nclass Workbook {\n  /**\n   * Create a new blank workbook.\n   * @returns {Promise.<Workbook>} The workbook.\n   * @ignore\n   */\n  static fromBlankAsync() {\n    return Workbook.fromDataAsync(blank);\n  }\n  /**\n   * Loads a workbook from a data object. (Supports any supported [JSZip data types]{@link https://stuk.github.io/jszip/documentation/api_jszip/load_async.html}.)\n   * @param {string|Array.<number>|ArrayBuffer|Uint8Array|Buffer|Blob|Promise.<*>} data - The data to load.\n   * @param {{}} [opts] - Options\n   * @returns {Promise.<Workbook>} The workbook.\n   * @ignore\n   */\n\n\n  static fromDataAsync(data, opts) {\n    return new Workbook()._initAsync(data, opts);\n  }\n  /**\n   * Loads a workbook from file.\n   * @param {string} path - The path to the workbook.\n   * @param {{}} [opts] - Options\n   * @returns {Promise.<Workbook>} The workbook.\n   * @ignore\n   */\n\n\n  static fromFileAsync(path, opts) {\n    if (process.browser) throw new Error(\"Workbook.fromFileAsync is not supported in the browser\");\n    return new externals.Promise((resolve, reject) => {\n      fs.readFile(path, (err, data) => {\n        if (err) return reject(err);\n        resolve(data);\n      });\n    }).then(data => Workbook.fromDataAsync(data, opts));\n  }\n  /**\n   * Get the active sheet in the workbook.\n   * @returns {Sheet} The active sheet.\n   */\n\n  /**\n  * Set the active sheet in the workbook.\n  * @param {Sheet|string|number} sheet - The sheet or name of sheet or index of sheet to activate. The sheet must not be hidden.\n  * @returns {Workbook} The workbook.\n  */\n\n\n  activeSheet() {\n    return new ArgHandler('Workbook.activeSheet').case(() => {\n      return this._activeSheet;\n    }).case('*', sheet => {\n      // Get the sheet from name/index if needed.\n      if (!(sheet instanceof Sheet)) sheet = this.sheet(sheet); // Check if the sheet is hidden.\n\n      if (sheet.hidden()) throw new Error(\"You may not activate a hidden sheet.\"); // Deselect all sheets except the active one (mirroring ying Excel behavior).\n\n      _.forEach(this._sheets, current => {\n        current.tabSelected(current === sheet);\n      });\n\n      this._activeSheet = sheet;\n      return this;\n    }).handle(arguments);\n  }\n  /**\n   * Add a new sheet to the workbook.\n   * @param {string} name - The name of the sheet. Must be unique, less than 31 characters, and may not contain the following characters: \\ / * [ ] : ?\n   * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.\n   * @returns {Sheet} The new sheet.\n   */\n\n\n  addSheet(name, indexOrBeforeSheet) {\n    return this._addSheet(name, indexOrBeforeSheet);\n  }\n  /**\n   * Gets a defined name scoped to the workbook.\n   * @param {string} name - The defined name.\n   * @returns {undefined|string|Cell|Range|Row|Column} What the defined name refers to or undefined if not found. Will return the string formula if not a Row, Column, Cell, or Range.\n   */\n\n  /**\n  * Set a defined name scoped to the workbook.\n  * @param {string} name - The defined name.\n  * @param {string|Cell|Range|Row|Column} refersTo - What the name refers to.\n  * @returns {Workbook} The workbook.\n  */\n\n\n  definedName() {\n    return new ArgHandler(\"Workbook.definedName\").case('string', name => {\n      return this.scopedDefinedName(undefined, name);\n    }).case(['string', '*'], (name, refersTo) => {\n      this.scopedDefinedName(undefined, name, refersTo);\n      return this;\n    }).handle(arguments);\n  }\n  /**\n   * Delete a sheet from the workbook.\n   * @param {Sheet|string|number} sheet - The sheet or name of sheet or index of sheet to move.\n   * @returns {Workbook} The workbook.\n   */\n\n\n  deleteSheet(sheet) {\n    // Get the sheet to move.\n    if (!(sheet instanceof Sheet)) {\n      sheet = this.sheet(sheet);\n      if (!sheet) throw new Error(\"Invalid move sheet reference.\");\n    } // Make sure we are not deleting the only visible sheet.\n\n\n    const visibleSheets = _.filter(this._sheets, sheet => !sheet.hidden());\n\n    if (visibleSheets.length === 1 && visibleSheets[0] === sheet) {\n      throw new Error(\"This sheet may not be deleted as a workbook must contain at least one visible sheet.\");\n    } // Remove the sheet.\n\n\n    let index = this._sheets.indexOf(sheet);\n\n    this._sheets.splice(index, 1); // Set the new active sheet.\n\n\n    if (sheet === this.activeSheet()) {\n      if (index >= this._sheets.length) index--;\n      this.activeSheet(index);\n    }\n\n    return this;\n  }\n  /**\n   * Find the given pattern in the workbook and optionally replace it.\n   * @param {string|RegExp} pattern - The pattern to look for. Providing a string will result in a case-insensitive substring search. Use a RegExp for more sophisticated searches.\n   * @param {string|function} [replacement] - The text to replace or a String.replace callback function. If pattern is a string, all occurrences of the pattern in each cell will be replaced.\n   * @returns {boolean} A flag indicating if the pattern was found.\n   */\n\n\n  find(pattern, replacement) {\n    pattern = regexify(pattern);\n    let matches = [];\n\n    this._sheets.forEach(sheet => {\n      matches = matches.concat(sheet.find(pattern, replacement));\n    });\n\n    return matches;\n  }\n  /**\n   * Move a sheet to a new position.\n   * @param {Sheet|string|number} sheet - The sheet or name of sheet or index of sheet to move.\n   * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.\n   * @returns {Workbook} The workbook.\n   */\n\n\n  moveSheet(sheet, indexOrBeforeSheet) {\n    // Get the sheet to move.\n    if (!(sheet instanceof Sheet)) {\n      sheet = this.sheet(sheet);\n      if (!sheet) throw new Error(\"Invalid move sheet reference.\");\n    } // Get the to/from indexes.\n\n\n    const from = this._sheets.indexOf(sheet);\n\n    let to;\n\n    if (_.isNil(indexOrBeforeSheet)) {\n      to = this._sheets.length - 1;\n    } else if (_.isInteger(indexOrBeforeSheet)) {\n      to = indexOrBeforeSheet;\n    } else {\n      if (!(indexOrBeforeSheet instanceof Sheet)) {\n        indexOrBeforeSheet = this.sheet(indexOrBeforeSheet);\n        if (!indexOrBeforeSheet) throw new Error(\"Invalid before sheet reference.\");\n      }\n\n      to = this._sheets.indexOf(indexOrBeforeSheet);\n    } // Insert the sheet at the appropriate place.\n\n\n    this._sheets.splice(to, 0, this._sheets.splice(from, 1)[0]);\n\n    return this;\n  }\n  /**\n   * Generates the workbook output.\n   * @param {string} [type] - The type of the data to return: base64, binarystring, uint8array, arraybuffer, blob, nodebuffer. Defaults to 'nodebuffer' in Node.js and 'blob' in browsers.\n   * @returns {Promise<string|Uint8Array|ArrayBuffer|Blob|Buffer>} The data.\n   */\n\n  /**\n  * Generates the workbook output.\n  * @param {{}} [opts] Options\n  * @param {string} [opts.type] - The type of the data to return: base64, binarystring, uint8array, arraybuffer, blob, nodebuffer. Defaults to 'nodebuffer' in Node.js and 'blob' in browsers.\n  * @param {string} [opts.password] - The password to use to encrypt the workbook.\n  * @returns {Promise<string|Uint8Array|ArrayBuffer|Blob|Buffer>} The data.\n  */\n\n\n  outputAsync(opts) {\n    opts = opts || {};\n    if (typeof opts === 'string') opts = {\n      type: opts\n    };\n\n    this._setSheetRefs();\n\n    let definedNamesNode = xmlq.findChild(this._node, \"definedNames\");\n\n    this._sheets.forEach((sheet, i) => {\n      if (!sheet._autoFilter) return;\n\n      if (!definedNamesNode) {\n        definedNamesNode = {\n          name: \"definedNames\",\n          attributes: {},\n          children: []\n        };\n        xmlq.insertInOrder(this._node, definedNamesNode, nodeOrder);\n      }\n\n      xmlq.appendChild(definedNamesNode, {\n        name: \"definedName\",\n        attributes: {\n          name: \"_xlnm._FilterDatabase\",\n          localSheetId: i,\n          hidden: \"1\"\n        },\n        children: [sheet._autoFilter.address({\n          includeSheetName: true,\n          anchored: true\n        })]\n      });\n    });\n\n    this._sheetsNode.children = [];\n\n    this._sheets.forEach((sheet, i) => {\n      const sheetPath = `xl/worksheets/sheet${i + 1}.xml`;\n      const sheetRelsPath = `xl/worksheets/_rels/sheet${i + 1}.xml.rels`;\n      const sheetXmls = sheet.toXmls();\n\n      const relationship = this._relationships.findById(sheetXmls.id.attributes['r:id']);\n\n      relationship.attributes.Target = `worksheets/sheet${i + 1}.xml`;\n\n      this._sheetsNode.children.push(sheetXmls.id);\n\n      this._zip.file(sheetPath, xmlBuilder.build(sheetXmls.sheet), zipFileOpts);\n\n      const relationshipsXml = xmlBuilder.build(sheetXmls.relationships);\n\n      if (relationshipsXml) {\n        this._zip.file(sheetRelsPath, relationshipsXml, zipFileOpts);\n      } else {\n        this._zip.remove(sheetRelsPath);\n      }\n    }); // Set the app security to true if a password is set, false if not.\n    // this._appProperties.isSecure(!!opts.password);\n    // Convert the various components to XML strings and add them to the zip.\n\n\n    this._zip.file(\"[Content_Types].xml\", xmlBuilder.build(this._contentTypes), zipFileOpts);\n\n    this._zip.file(\"docProps/app.xml\", xmlBuilder.build(this._appProperties), zipFileOpts);\n\n    this._zip.file(\"docProps/core.xml\", xmlBuilder.build(this._coreProperties), zipFileOpts);\n\n    this._zip.file(\"xl/_rels/workbook.xml.rels\", xmlBuilder.build(this._relationships), zipFileOpts);\n\n    this._zip.file(\"xl/sharedStrings.xml\", xmlBuilder.build(this._sharedStrings), zipFileOpts);\n\n    this._zip.file(\"xl/styles.xml\", xmlBuilder.build(this._styleSheet), zipFileOpts);\n\n    this._zip.file(\"xl/workbook.xml\", xmlBuilder.build(this._node), zipFileOpts); // Generate the zip.\n\n\n    return this._zip.generateAsync({\n      type: \"nodebuffer\",\n      compression: \"DEFLATE\"\n    }).then(output => {\n      // If a password is set, encrypt the workbook.\n      if (opts.password) output = encryptor.encrypt(output, opts.password); // Convert and return\n\n      return this._convertBufferToOutput(output, opts.type);\n    });\n  }\n  /**\n   * Gets the sheet with the provided name or index (0-based).\n   * @param {string|number} sheetNameOrIndex - The sheet name or index.\n   * @returns {Sheet|undefined} The sheet or undefined if not found.\n   */\n\n\n  sheet(sheetNameOrIndex) {\n    if (_.isInteger(sheetNameOrIndex)) return this._sheets[sheetNameOrIndex];\n    return _.find(this._sheets, sheet => sheet.name() === sheetNameOrIndex);\n  }\n  /**\n   * Get an array of all the sheets in the workbook.\n   * @returns {Array.<Sheet>} The sheets.\n   */\n\n\n  sheets() {\n    return this._sheets.slice();\n  }\n  /**\n   * Gets an individual property.\n   * @param {string} name - The name of the property.\n   * @returns {*} The property.\n   */\n\n  /**\n  * Gets multiple properties.\n  * @param {Array.<string>} names - The names of the properties.\n  * @returns {object.<string, *>} Object whose keys are the property names and values are the properties.\n  */\n\n  /**\n  * Sets an individual property.\n  * @param {string} name - The name of the property.\n  * @param {*} value - The value to set.\n  * @returns {Workbook} The workbook.\n  */\n\n  /**\n  * Sets multiple properties.\n  * @param {object.<string, *>} properties - Object whose keys are the property names and values are the values to set.\n  * @returns {Workbook} The workbook.\n  */\n\n\n  property() {\n    return new ArgHandler(\"Workbook.property\").case('string', name => {\n      // Get single value\n      return this._coreProperties.get(name);\n    }).case('array', names => {\n      // Get list of values\n      const values = {};\n      names.forEach(name => {\n        values[name] = this._coreProperties.get(name);\n      });\n      return values;\n    }).case(['string', '*'], (name, value) => {\n      // Set a single value for all cells to a single value\n      this._coreProperties.set(name, value);\n\n      return this;\n    }).case('object', nameValues => {\n      // Object of key value pairs to set\n      for (const name in nameValues) {\n        if (!nameValues.hasOwnProperty(name)) continue;\n        const value = nameValues[name];\n\n        this._coreProperties.set(name, value);\n      }\n\n      return this;\n    }).handle(arguments);\n  }\n  /**\n   * Get access to core properties object\n   * @returns {CoreProperties} The core properties.\n   */\n\n\n  properties() {\n    return this._coreProperties;\n  }\n  /**\n   * Write the workbook to file. (Not supported in browsers.)\n   * @param {string} path - The path of the file to write.\n   * @param {{}} [opts] - Options\n   * @param {string} [opts.password] - The password to encrypt the workbook.\n   * @returns {Promise.<undefined>} A promise.\n   */\n\n\n  toFileAsync(path, opts) {\n    if (process.browser) throw new Error(\"Workbook.toFileAsync is not supported in the browser.\");\n    return this.outputAsync(opts).then(data => new externals.Promise((resolve, reject) => {\n      fs.writeFile(path, data, err => {\n        if (err) return reject(err);\n        resolve();\n      });\n    }));\n  }\n  /**\n   * Gets a scoped defined name.\n   * @param {Sheet} sheetScope - The sheet the name is scoped to. Use undefined for workbook scope.\n   * @param {string} name - The defined name.\n   * @returns {undefined|Cell|Range|Row|Column} What the defined name refers to.\n   * @ignore\n   */\n\n  /**\n  * Sets a scoped defined name.\n  * @param {Sheet} sheetScope - The sheet the name is scoped to. Use undefined for workbook scope.\n  * @param {string} name - The defined name.\n  * @param {undefined|Cell|Range|Row|Column} refersTo - What the defined name refers to.\n  * @returns {Workbook} The workbook.\n  * @ignore\n  */\n\n\n  scopedDefinedName(sheetScope, name, refersTo) {\n    let definedNamesNode = xmlq.findChild(this._node, \"definedNames\");\n\n    let definedNameNode = definedNamesNode && _.find(definedNamesNode.children, node => node.attributes.name === name && node.localSheet === sheetScope);\n\n    return new ArgHandler('Workbook.scopedDefinedName').case(['*', 'string'], () => {\n      // Get the address from the definedNames node.\n      const refersTo = definedNameNode && definedNameNode.children[0];\n      if (!refersTo) return undefined; // Try to parse the address.\n\n      const ref = addressConverter.fromAddress(refersTo);\n      if (!ref) return refersTo; // Load the appropriate selection type.\n\n      const sheet = this.sheet(ref.sheetName);\n      if (ref.type === 'cell') return sheet.cell(ref.rowNumber, ref.columnNumber);\n      if (ref.type === 'range') return sheet.range(ref.startRowNumber, ref.startColumnNumber, ref.endRowNumber, ref.endColumnNumber);\n      if (ref.type === 'row') return sheet.row(ref.rowNumber);\n      if (ref.type === 'column') return sheet.column(ref.columnNumber);\n      return refersTo;\n    }).case(['*', 'string', 'nil'], () => {\n      if (definedNameNode) xmlq.removeChild(definedNamesNode, definedNameNode);\n      if (definedNamesNode && !definedNamesNode.children.length) xmlq.removeChild(this._node, definedNamesNode);\n      return this;\n    }).case(['*', 'string', '*'], () => {\n      if (typeof refersTo !== 'string') {\n        refersTo = refersTo.address({\n          includeSheetName: true,\n          anchored: true\n        });\n      }\n\n      if (!definedNamesNode) {\n        definedNamesNode = {\n          name: \"definedNames\",\n          attributes: {},\n          children: []\n        };\n        xmlq.insertInOrder(this._node, definedNamesNode, nodeOrder);\n      }\n\n      if (!definedNameNode) {\n        definedNameNode = {\n          name: \"definedName\",\n          attributes: {\n            name\n          },\n          children: [refersTo]\n        };\n        if (sheetScope) definedNameNode.localSheet = sheetScope;\n        xmlq.appendChild(definedNamesNode, definedNameNode);\n      }\n\n      definedNameNode.children = [refersTo];\n      return this;\n    }).handle(arguments);\n  }\n  /**\n   * Get the shared strings table.\n   * @returns {SharedStrings} The shared strings table.\n   * @ignore\n   */\n\n\n  sharedStrings() {\n    return this._sharedStrings;\n  }\n  /**\n   * Get the style sheet.\n   * @returns {StyleSheet} The style sheet.\n   * @ignore\n   */\n\n\n  styleSheet() {\n    return this._styleSheet;\n  }\n  /**\n   * Add a new sheet to the workbook.\n   * \n   * **WARN:** this function has limits:  if you clone a sheet with some images or other things link outside the Sheet object, these things in the cloned sheet will be locked when you open in MS Excel app.\n   * @param {Sheet} from - The sheet to be cloned.\n   * @param {string} name - The name of the new sheet. Must be unique, less than 31 characters, and may not contain the following characters: \\ / * [ ] : ?\n   * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.\n   * @returns {Sheet} The new sheet.\n   */\n\n\n  cloneSheet(from, name, indexOrBeforeSheet) {\n    if (!from || !(from instanceof Sheet)) throw new Error(\"Invalid clone from.\");\n    return this._addSheet(name, indexOrBeforeSheet, () => {\n      const cloneXml = node => {\n        // If the node has a toXml method, call it.\n        if (node && _.isFunction(node.toXml)) node = node.toXml();\n\n        if (typeof node === 'object') {\n          if (node.name) {\n            const result = {\n              name: node.name,\n              attributes: {},\n              children: []\n            };\n\n            _.forOwn(node.attributes, (value, name) => {\n              result.attributes[name] = value;\n            });\n\n            let chld;\n\n            if (node.children) {\n              node.children.forEach(child => {\n                chld = cloneXml(child);\n\n                if (child !== null) {\n                  result.children.push(chld);\n                }\n              });\n            }\n\n            return result;\n          }\n        } else if (node !== null) {\n          return node;\n        }\n\n        return null;\n      }; // clone SheetNode & relationshipNode from source\n\n\n      const fromXml = from.toXmls();\n      const sheetNode = cloneXml(fromXml.sheet);\n      const relationshipNode = cloneXml(fromXml.relationships);\n      return {\n        sheetNode,\n        relationshipNode\n      };\n    });\n  }\n  /**\n   * Add a new sheet to the workbook.\n   * @param {string} name - The name of the sheet. Must be unique, less than 31 characters, and may not contain the following characters: \\ / * [ ] : ?\n   * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.\n   * @param {callback} [getTemplateNodes] optional callback function for template nodes\n   * @returns {Sheet} The new sheet.\n   * @private\n   */\n\n\n  _addSheet(name, indexOrBeforeSheet, getTemplateNodes) {\n    // Validate the sheet name.\n    if (!name || typeof name !== \"string\") throw new Error(\"Invalid sheet name.\");\n    if (_.some(badSheetNameChars, char => name.indexOf(char) >= 0)) throw new Error(`Sheet name may not contain any of the following characters: ${badSheetNameChars.join(\" \")}`);\n    if (name.length > maxSheetNameLength) throw new Error(`Sheet name may not be greater than ${maxSheetNameLength} characters.`);\n    if (this.sheet(name)) throw new Error(`Sheet with name \"${name}\" already exists.`); // Get the destination index of new sheet.\n\n    let index;\n\n    if (_.isNil(indexOrBeforeSheet)) {\n      index = this._sheets.length;\n    } else if (_.isInteger(indexOrBeforeSheet)) {\n      index = indexOrBeforeSheet;\n    } else {\n      if (!(indexOrBeforeSheet instanceof Sheet)) {\n        indexOrBeforeSheet = this.sheet(indexOrBeforeSheet);\n        if (!indexOrBeforeSheet) throw new Error(\"Invalid before sheet reference.\");\n      }\n\n      index = this._sheets.indexOf(indexOrBeforeSheet);\n    } // Add a new relationship for the new sheet and create the new sheet ID node.\n\n\n    const relationship = this._relationships.add(\"worksheet\"); // Leave target blank as it will be filled later.\n\n\n    const sheetIdNode = {\n      name: \"sheet\",\n      attributes: {\n        name,\n        sheetId: ++this._maxSheetId,\n        'r:id': relationship.attributes.Id\n      },\n      children: []\n    }; // Create the new sheet.\n\n    let sheet;\n\n    if (getTemplateNodes) {\n      const {\n        sheetNode,\n        relationshipNode\n      } = getTemplateNodes();\n      sheet = new Sheet(this, sheetIdNode, sheetNode, relationshipNode);\n    } else {\n      sheet = new Sheet(this, sheetIdNode);\n    } // Insert the sheet at the appropriate index.\n\n\n    this._sheets.splice(index, 0, sheet);\n\n    return sheet;\n  }\n  /**\n   * Initialize the workbook. (This is separated from the constructor to ease testing.)\n   * @param {string|ArrayBuffer|Uint8Array|Buffer|Blob} data - The data to load.\n   * @param {{}} [opts] - Options\n   * @param {boolean} [opts.base64=false] - No used unless input is a string. True if the input string is base64 encoded, false for binary.\n   * @returns {Promise.<Workbook>} The workbook.\n   * @private\n   */\n\n\n  _initAsync(data, opts) {\n    opts = opts || {};\n    this._maxSheetId = 0;\n    this._sheets = [];\n    return externals.Promise.resolve().then(() => {\n      // Make sure the input is a Buffer\n      return this._convertInputToBufferAsync(data, opts.base64).then(buffer => {\n        data = buffer;\n      });\n    }).then(() => {\n      if (!opts.password) return;\n      return encryptor.decryptAsync(data, opts.password).then(decrypted => {\n        data = decrypted;\n      });\n    }).then(() => JSZip.loadAsync(data)).then(zip => {\n      this._zip = zip;\n      return this._parseNodesAsync([\"[Content_Types].xml\", \"docProps/app.xml\", \"docProps/core.xml\", \"xl/_rels/workbook.xml.rels\", \"xl/sharedStrings.xml\", \"xl/styles.xml\", \"xl/workbook.xml\"]);\n    }).then(nodes => {\n      const contentTypesNode = nodes[0];\n      const appPropertiesNode = nodes[1];\n      const corePropertiesNode = nodes[2];\n      const relationshipsNode = nodes[3];\n      const sharedStringsNode = nodes[4];\n      const styleSheetNode = nodes[5];\n      const workbookNode = nodes[6]; // Load the various components.\n\n      this._contentTypes = new ContentTypes(contentTypesNode);\n      this._appProperties = new AppProperties(appPropertiesNode);\n      this._coreProperties = new CoreProperties(corePropertiesNode);\n      this._relationships = new Relationships(relationshipsNode);\n      this._sharedStrings = new SharedStrings(sharedStringsNode);\n      this._styleSheet = new StyleSheet(styleSheetNode);\n      this._node = workbookNode; // Add the shared strings relationship if it doesn't exist.\n\n      if (!this._relationships.findByType(\"sharedStrings\")) {\n        this._relationships.add(\"sharedStrings\", \"sharedStrings.xml\");\n      } // Add the shared string content type if it doesn't exist.\n\n\n      if (!this._contentTypes.findByPartName(\"/xl/sharedStrings.xml\")) {\n        this._contentTypes.add(\"/xl/sharedStrings.xml\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml\");\n      } // Kill the calc chain. It's not required and the workbook will corrupt unless we keep it up to date.\n\n\n      this._zip.remove(\"xl/calcChain.xml\"); // Load each sheet.\n\n\n      this._sheetsNode = xmlq.findChild(this._node, \"sheets\");\n      return externals.Promise.all(_.map(this._sheetsNode.children, (sheetIdNode, i) => {\n        if (sheetIdNode.attributes.sheetId > this._maxSheetId) this._maxSheetId = sheetIdNode.attributes.sheetId;\n        return this._parseNodesAsync([`xl/worksheets/sheet${i + 1}.xml`, `xl/worksheets/_rels/sheet${i + 1}.xml.rels`]).then(nodes => {\n          const sheetNode = nodes[0];\n          const sheetRelationshipsNode = nodes[1]; // Insert at position i as the promises will resolve at different times.\n\n          this._sheets[i] = new Sheet(this, sheetIdNode, sheetNode, sheetRelationshipsNode);\n        });\n      }));\n    }).then(() => this._parseSheetRefs()).then(() => this);\n  }\n  /**\n   * Parse files out of zip into XML node objects.\n   * @param {Array.<string>} names - The file names to parse.\n   * @returns {Promise.<Array.<{}>>} An array of the parsed objects.\n   * @private\n   */\n\n\n  _parseNodesAsync(names) {\n    return externals.Promise.all(_.map(names, name => this._zip.file(name))).then(files => externals.Promise.all(_.map(files, file => file && file.async(\"string\")))).then(texts => externals.Promise.all(_.map(texts, text => text && xmlParser.parseAsync(text))));\n  }\n  /**\n   * Parse the sheet references out so we can reorder freely.\n   * @returns {undefined}\n   * @private\n   */\n\n\n  _parseSheetRefs() {\n    // Parse the active sheet.\n    const bookViewsNode = xmlq.findChild(this._node, \"bookViews\");\n    const workbookViewNode = bookViewsNode && xmlq.findChild(bookViewsNode, \"workbookView\");\n    const activeTabId = workbookViewNode && workbookViewNode.attributes.activeTab || 0;\n    this._activeSheet = this._sheets[activeTabId]; // Set the location sheet on the defined name nodes. The defined name should point to the index of the sheet\n    // but reordering sheets messes this up. So store it on the node and we'll update the index on XML build.\n\n    const definedNamesNode = xmlq.findChild(this._node, \"definedNames\");\n\n    if (definedNamesNode) {\n      _.forEach(definedNamesNode.children, definedNameNode => {\n        if (definedNameNode.attributes.hasOwnProperty(\"localSheetId\")) {\n          definedNameNode.localSheet = this._sheets[definedNameNode.attributes.localSheetId];\n        }\n      });\n    }\n  }\n  /**\n   * Set the proper sheet references in the XML.\n   * @returns {undefined}\n   * @private\n   */\n\n\n  _setSheetRefs() {\n    // Set the active sheet.\n    let bookViewsNode = xmlq.findChild(this._node, \"bookViews\");\n\n    if (!bookViewsNode) {\n      bookViewsNode = {\n        name: 'bookViews',\n        attributes: {},\n        children: []\n      };\n      xmlq.insertInOrder(this._node, bookViewsNode, nodeOrder);\n    }\n\n    let workbookViewNode = xmlq.findChild(bookViewsNode, \"workbookView\");\n\n    if (!workbookViewNode) {\n      workbookViewNode = {\n        name: 'workbookView',\n        attributes: {},\n        children: []\n      };\n      xmlq.appendChild(bookViewsNode, workbookViewNode);\n    }\n\n    workbookViewNode.attributes.activeTab = this._sheets.indexOf(this._activeSheet); // Set the defined names local sheet indexes.\n\n    const definedNamesNode = xmlq.findChild(this._node, \"definedNames\");\n\n    if (definedNamesNode) {\n      _.forEach(definedNamesNode.children, definedNameNode => {\n        if (definedNameNode.localSheet) {\n          definedNameNode.attributes.localSheetId = this._sheets.indexOf(definedNameNode.localSheet);\n        }\n      });\n    }\n  }\n  /**\n   * Convert buffer to desired output format\n   * @param {Buffer} buffer - The buffer\n   * @param {string} type - The type to convert to: buffer/nodebuffer, blob, base64, binarystring, uint8array, arraybuffer\n   * @returns {Buffer|Blob|string|Uint8Array|ArrayBuffer} The output\n   * @private\n   */\n\n\n  _convertBufferToOutput(buffer, type) {\n    if (!type) type = process.browser ? \"blob\" : \"nodebuffer\";\n    if (type === \"buffer\" || type === \"nodebuffer\") return buffer;\n    if (process.browser && type === \"blob\") return new Blob([buffer], {\n      type: Workbook.MIME_TYPE\n    });\n    if (type === \"base64\") return buffer.toString(\"base64\");\n    if (type === \"binarystring\") return buffer.toString(\"utf8\");\n    if (type === \"uint8array\") return new Uint8Array(buffer);\n    if (type === \"arraybuffer\") return new Uint8Array(buffer).buffer;\n    throw new Error(`Output type '${type}' not supported.`);\n  }\n  /**\n   * Convert input to buffer\n   * @param {Buffer|Blob|string|Uint8Array|ArrayBuffer} input - The input\n   * @param {boolean} [base64=false] - Only applies if input is a string. If true, the string is base64 encoded, false for binary\n   * @returns {Promise.<Buffer>} The buffer.\n   * @private\n   */\n\n\n  _convertInputToBufferAsync(input, base64) {\n    return externals.Promise.resolve().then(() => {\n      if (Buffer.isBuffer(input)) return input;\n\n      if (process.browser && input instanceof Blob) {\n        return new externals.Promise(resolve => {\n          const fileReader = new FileReader();\n\n          fileReader.onload = event => {\n            resolve(Buffer.from(event.target.result));\n          };\n\n          fileReader.readAsArrayBuffer(input);\n        });\n      }\n\n      if (typeof input === \"string\" && base64) return Buffer.from(input, \"base64\");\n      if (typeof input === \"string\" && !base64) return Buffer.from(input, \"utf8\");\n      if (input instanceof Uint8Array || input instanceof ArrayBuffer) return Buffer.from(input);\n      throw new Error(`Input type unknown.`);\n    });\n  }\n\n}\n/**\n * The XLSX mime type.\n * @type {string}\n * @ignore\n */\n\n\nWorkbook.MIME_TYPE = \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\";\nmodule.exports = Workbook;\n/*\nxl/workbook.xml\n\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<workbook xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" mc:Ignorable=\"x15\" xmlns:x15=\"http://schemas.microsoft.com/office/spreadsheetml/2010/11/main\">\n\t<fileVersion appName=\"xl\" lastEdited=\"7\" lowestEdited=\"7\" rupBuild=\"16925\"/>\n\t<workbookPr defaultThemeVersion=\"164011\"/>\n\t<mc:AlternateContent xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\">\n\t\t<mc:Choice Requires=\"x15\">\n\t\t\t<x15ac:absPath url=\"\\path\\to\\file\" xmlns:x15ac=\"http://schemas.microsoft.com/office/spreadsheetml/2010/11/ac\"/>\n\t\t</mc:Choice>\n\t</mc:AlternateContent>\n\t<bookViews>\n\t\t<workbookView xWindow=\"3720\" yWindow=\"0\" windowWidth=\"27870\" windowHeight=\"12795\"/>\n\t</bookViews>\n\t<sheets>\n\t\t<sheet name=\"Sheet1\" sheetId=\"1\" r:id=\"rId1\"/>\n\t</sheets>\n\t<calcPr calcId=\"171027\"/>\n\t<extLst>\n\t\t<ext uri=\"{140A7094-0E35-4892-8432-C4D2E57EDEB5}\" xmlns:x15=\"http://schemas.microsoft.com/office/spreadsheetml/2010/11/main\">\n\t\t\t<x15:workbookPr chartTrackingRefBase=\"1\"/>\n\t\t</ext>\n\t</extLst>\n</workbook>\n// */","map":{"version":3,"sources":["C:/Users/tzika/Desktop/MSM Backup/MSM-Front/MSM/node_modules/xlsx-populate/lib/Workbook.js"],"names":["_","require","fs","JSZip","externals","regexify","blank","xmlq","Sheet","ContentTypes","AppProperties","CoreProperties","Relationships","SharedStrings","StyleSheet","Encryptor","XmlParser","XmlBuilder","ArgHandler","addressConverter","zipFileOpts","date","Date","createFolders","xmlParser","xmlBuilder","encryptor","badSheetNameChars","maxSheetNameLength","nodeOrder","Workbook","fromBlankAsync","fromDataAsync","data","opts","_initAsync","fromFileAsync","path","process","browser","Error","Promise","resolve","reject","readFile","err","then","activeSheet","case","_activeSheet","sheet","hidden","forEach","_sheets","current","tabSelected","handle","arguments","addSheet","name","indexOrBeforeSheet","_addSheet","definedName","scopedDefinedName","undefined","refersTo","deleteSheet","visibleSheets","filter","length","index","indexOf","splice","find","pattern","replacement","matches","concat","moveSheet","from","to","isNil","isInteger","outputAsync","type","_setSheetRefs","definedNamesNode","findChild","_node","i","_autoFilter","attributes","children","insertInOrder","appendChild","localSheetId","address","includeSheetName","anchored","_sheetsNode","sheetPath","sheetRelsPath","sheetXmls","toXmls","relationship","_relationships","findById","id","Target","push","_zip","file","build","relationshipsXml","relationships","remove","_contentTypes","_appProperties","_coreProperties","_sharedStrings","_styleSheet","generateAsync","compression","output","password","encrypt","_convertBufferToOutput","sheetNameOrIndex","sheets","slice","property","get","names","values","value","set","nameValues","hasOwnProperty","properties","toFileAsync","writeFile","sheetScope","definedNameNode","node","localSheet","ref","fromAddress","sheetName","cell","rowNumber","columnNumber","range","startRowNumber","startColumnNumber","endRowNumber","endColumnNumber","row","column","removeChild","sharedStrings","styleSheet","cloneSheet","cloneXml","isFunction","toXml","result","forOwn","chld","child","fromXml","sheetNode","relationshipNode","getTemplateNodes","some","char","join","add","sheetIdNode","sheetId","_maxSheetId","Id","_convertInputToBufferAsync","base64","buffer","decryptAsync","decrypted","loadAsync","zip","_parseNodesAsync","nodes","contentTypesNode","appPropertiesNode","corePropertiesNode","relationshipsNode","sharedStringsNode","styleSheetNode","workbookNode","findByType","findByPartName","all","map","sheetRelationshipsNode","_parseSheetRefs","files","async","texts","text","parseAsync","bookViewsNode","workbookViewNode","activeTabId","activeTab","Blob","MIME_TYPE","toString","Uint8Array","input","Buffer","isBuffer","fileReader","FileReader","onload","event","target","readAsArrayBuffer","ArrayBuffer","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst _ = require(\"lodash\");\nconst fs = require(\"fs\");\nconst JSZip = require('jszip');\n\nconst externals = require(\"./externals\");\nconst regexify = require(\"./regexify\");\nconst blank = require(\"./blank\")();\nconst xmlq = require(\"./xmlq\");\nconst Sheet = require(\"./Sheet\");\nconst ContentTypes = require(\"./ContentTypes\");\nconst AppProperties = require(\"./AppProperties\");\nconst CoreProperties = require(\"./CoreProperties\");\nconst Relationships = require(\"./Relationships\");\nconst SharedStrings = require(\"./SharedStrings\");\nconst StyleSheet = require(\"./StyleSheet\");\nconst Encryptor = require(\"./Encryptor\");\nconst XmlParser = require(\"./XmlParser\");\nconst XmlBuilder = require(\"./XmlBuilder\");\nconst ArgHandler = require(\"./ArgHandler\");\nconst addressConverter = require(\"./addressConverter\");\n\n// Options for adding files to zip. Do not create folders and use a fixed time at epoch.\n// The default JSZip behavior uses current time, which causes idential workbooks to be different each time.\nconst zipFileOpts = {\n    date: new Date(0),\n    createFolders: false\n};\n\n// Initialize the parser and builder.\nconst xmlParser = new XmlParser();\nconst xmlBuilder = new XmlBuilder();\n\n// Initialize the encryptor if present (can be excluded in browser build).\nconst encryptor = typeof Encryptor === \"function\" && new Encryptor();\n\n// Characters not allowed in sheet names.\nconst badSheetNameChars = ['\\\\', '/', '*', '[', ']', ':', '?'];\n\n// Excel limits sheet names to 31 chars.\nconst maxSheetNameLength = 31;\n\n// Order of the nodes as defined by the spec.\nconst nodeOrder = [\n    \"fileVersion\", \"fileSharing\", \"workbookPr\", \"workbookProtection\", \"bookViews\", \"sheets\", \"functionGroups\",\n    \"externalReferences\", \"definedNames\", \"calcPr\", \"oleSize\", \"customWorkbookViews\", \"pivotCaches\", \"smartTagPr\",\n    \"smartTagTypes\", \"webPublishing\", \"fileRecoveryPr\", \"webPublishObjects\", \"extLst\"\n];\n\n/**\n * A workbook.\n */\nclass Workbook {\n    /**\n     * Create a new blank workbook.\n     * @returns {Promise.<Workbook>} The workbook.\n     * @ignore\n     */\n    static fromBlankAsync() {\n        return Workbook.fromDataAsync(blank);\n    }\n\n    /**\n     * Loads a workbook from a data object. (Supports any supported [JSZip data types]{@link https://stuk.github.io/jszip/documentation/api_jszip/load_async.html}.)\n     * @param {string|Array.<number>|ArrayBuffer|Uint8Array|Buffer|Blob|Promise.<*>} data - The data to load.\n     * @param {{}} [opts] - Options\n     * @returns {Promise.<Workbook>} The workbook.\n     * @ignore\n     */\n    static fromDataAsync(data, opts) {\n        return new Workbook()._initAsync(data, opts);\n    }\n\n    /**\n     * Loads a workbook from file.\n     * @param {string} path - The path to the workbook.\n     * @param {{}} [opts] - Options\n     * @returns {Promise.<Workbook>} The workbook.\n     * @ignore\n     */\n    static fromFileAsync(path, opts) {\n        if (process.browser) throw new Error(\"Workbook.fromFileAsync is not supported in the browser\");\n        return new externals.Promise((resolve, reject) => {\n            fs.readFile(path, (err, data) => {\n                if (err) return reject(err);\n                resolve(data);\n            });\n        }).then(data => Workbook.fromDataAsync(data, opts));\n    }\n\n    /**\n     * Get the active sheet in the workbook.\n     * @returns {Sheet} The active sheet.\n     *//**\n     * Set the active sheet in the workbook.\n     * @param {Sheet|string|number} sheet - The sheet or name of sheet or index of sheet to activate. The sheet must not be hidden.\n     * @returns {Workbook} The workbook.\n     */\n    activeSheet() {\n        return new ArgHandler('Workbook.activeSheet')\n            .case(() => {\n                return this._activeSheet;\n            })\n            .case('*', sheet => {\n                // Get the sheet from name/index if needed.\n                if (!(sheet instanceof Sheet)) sheet = this.sheet(sheet);\n\n                // Check if the sheet is hidden.\n                if (sheet.hidden()) throw new Error(\"You may not activate a hidden sheet.\");\n\n                // Deselect all sheets except the active one (mirroring ying Excel behavior).\n                _.forEach(this._sheets, current => {\n                    current.tabSelected(current === sheet);\n                });\n\n                this._activeSheet = sheet;\n\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Add a new sheet to the workbook.\n     * @param {string} name - The name of the sheet. Must be unique, less than 31 characters, and may not contain the following characters: \\ / * [ ] : ?\n     * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.\n     * @returns {Sheet} The new sheet.\n     */\n    addSheet(name, indexOrBeforeSheet) {\n        return this._addSheet(name, indexOrBeforeSheet);\n    }\n    \n    /**\n     * Gets a defined name scoped to the workbook.\n     * @param {string} name - The defined name.\n     * @returns {undefined|string|Cell|Range|Row|Column} What the defined name refers to or undefined if not found. Will return the string formula if not a Row, Column, Cell, or Range.\n     *//**\n     * Set a defined name scoped to the workbook.\n     * @param {string} name - The defined name.\n     * @param {string|Cell|Range|Row|Column} refersTo - What the name refers to.\n     * @returns {Workbook} The workbook.\n     */\n    definedName() {\n        return new ArgHandler(\"Workbook.definedName\")\n            .case('string', name => {\n                return this.scopedDefinedName(undefined, name);\n            })\n            .case(['string', '*'], (name, refersTo) => {\n                this.scopedDefinedName(undefined, name, refersTo);\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Delete a sheet from the workbook.\n     * @param {Sheet|string|number} sheet - The sheet or name of sheet or index of sheet to move.\n     * @returns {Workbook} The workbook.\n     */\n    deleteSheet(sheet) {\n        // Get the sheet to move.\n        if (!(sheet instanceof Sheet)) {\n            sheet = this.sheet(sheet);\n            if (!sheet) throw new Error(\"Invalid move sheet reference.\");\n        }\n\n        // Make sure we are not deleting the only visible sheet.\n        const visibleSheets = _.filter(this._sheets, sheet => !sheet.hidden());\n        if (visibleSheets.length === 1 && visibleSheets[0] === sheet) {\n            throw new Error(\"This sheet may not be deleted as a workbook must contain at least one visible sheet.\");\n        }\n\n        // Remove the sheet.\n        let index = this._sheets.indexOf(sheet);\n        this._sheets.splice(index, 1);\n\n        // Set the new active sheet.\n        if (sheet === this.activeSheet()) {\n            if (index >= this._sheets.length) index--;\n            this.activeSheet(index);\n        }\n\n        return this;\n    }\n\n    /**\n     * Find the given pattern in the workbook and optionally replace it.\n     * @param {string|RegExp} pattern - The pattern to look for. Providing a string will result in a case-insensitive substring search. Use a RegExp for more sophisticated searches.\n     * @param {string|function} [replacement] - The text to replace or a String.replace callback function. If pattern is a string, all occurrences of the pattern in each cell will be replaced.\n     * @returns {boolean} A flag indicating if the pattern was found.\n     */\n    find(pattern, replacement) {\n        pattern = regexify(pattern);\n\n        let matches = [];\n        this._sheets.forEach(sheet => {\n            matches = matches.concat(sheet.find(pattern, replacement));\n        });\n\n        return matches;\n    }\n\n    /**\n     * Move a sheet to a new position.\n     * @param {Sheet|string|number} sheet - The sheet or name of sheet or index of sheet to move.\n     * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.\n     * @returns {Workbook} The workbook.\n     */\n    moveSheet(sheet, indexOrBeforeSheet) {\n        // Get the sheet to move.\n        if (!(sheet instanceof Sheet)) {\n            sheet = this.sheet(sheet);\n            if (!sheet) throw new Error(\"Invalid move sheet reference.\");\n        }\n\n        // Get the to/from indexes.\n        const from = this._sheets.indexOf(sheet);\n        let to;\n        if (_.isNil(indexOrBeforeSheet)) {\n            to = this._sheets.length - 1;\n        } else if (_.isInteger(indexOrBeforeSheet)) {\n            to = indexOrBeforeSheet;\n        } else {\n            if (!(indexOrBeforeSheet instanceof Sheet)) {\n                indexOrBeforeSheet = this.sheet(indexOrBeforeSheet);\n                if (!indexOrBeforeSheet) throw new Error(\"Invalid before sheet reference.\");\n            }\n\n            to = this._sheets.indexOf(indexOrBeforeSheet);\n        }\n\n        // Insert the sheet at the appropriate place.\n        this._sheets.splice(to, 0, this._sheets.splice(from, 1)[0]);\n\n        return this;\n    }\n\n    /**\n     * Generates the workbook output.\n     * @param {string} [type] - The type of the data to return: base64, binarystring, uint8array, arraybuffer, blob, nodebuffer. Defaults to 'nodebuffer' in Node.js and 'blob' in browsers.\n     * @returns {Promise<string|Uint8Array|ArrayBuffer|Blob|Buffer>} The data.\n     *//**\n     * Generates the workbook output.\n     * @param {{}} [opts] Options\n     * @param {string} [opts.type] - The type of the data to return: base64, binarystring, uint8array, arraybuffer, blob, nodebuffer. Defaults to 'nodebuffer' in Node.js and 'blob' in browsers.\n     * @param {string} [opts.password] - The password to use to encrypt the workbook.\n     * @returns {Promise<string|Uint8Array|ArrayBuffer|Blob|Buffer>} The data.\n     */\n    outputAsync(opts) {\n        opts = opts || {};\n        if (typeof opts === 'string') opts = { type: opts };\n\n        this._setSheetRefs();\n\n        let definedNamesNode = xmlq.findChild(this._node, \"definedNames\");\n\n        this._sheets.forEach((sheet, i) => {\n            if (!sheet._autoFilter) return;\n\n            if (!definedNamesNode) {\n                definedNamesNode = {\n                    name: \"definedNames\",\n                    attributes: {},\n                    children: []\n                };\n\n                xmlq.insertInOrder(this._node, definedNamesNode, nodeOrder);\n            }\n\n            xmlq.appendChild(definedNamesNode, {\n                name: \"definedName\",\n                attributes: {\n                    name: \"_xlnm._FilterDatabase\",\n                    localSheetId: i,\n                    hidden: \"1\"\n                },\n                children: [sheet._autoFilter.address({ includeSheetName: true, anchored: true })]\n            });\n        });\n\n        this._sheetsNode.children = [];\n        this._sheets.forEach((sheet, i) => {\n            const sheetPath = `xl/worksheets/sheet${i + 1}.xml`;\n            const sheetRelsPath = `xl/worksheets/_rels/sheet${i + 1}.xml.rels`;\n            const sheetXmls = sheet.toXmls();\n            const relationship = this._relationships.findById(sheetXmls.id.attributes['r:id']);\n            relationship.attributes.Target = `worksheets/sheet${i + 1}.xml`;\n            this._sheetsNode.children.push(sheetXmls.id);\n            this._zip.file(sheetPath, xmlBuilder.build(sheetXmls.sheet), zipFileOpts);\n\n            const relationshipsXml = xmlBuilder.build(sheetXmls.relationships);\n            if (relationshipsXml) {\n                this._zip.file(sheetRelsPath, relationshipsXml, zipFileOpts);\n            } else {\n                this._zip.remove(sheetRelsPath);\n            }\n        });\n\n        // Set the app security to true if a password is set, false if not.\n        // this._appProperties.isSecure(!!opts.password);\n\n        // Convert the various components to XML strings and add them to the zip.\n        this._zip.file(\"[Content_Types].xml\", xmlBuilder.build(this._contentTypes), zipFileOpts);\n        this._zip.file(\"docProps/app.xml\", xmlBuilder.build(this._appProperties), zipFileOpts);\n        this._zip.file(\"docProps/core.xml\", xmlBuilder.build(this._coreProperties), zipFileOpts);\n        this._zip.file(\"xl/_rels/workbook.xml.rels\", xmlBuilder.build(this._relationships), zipFileOpts);\n        this._zip.file(\"xl/sharedStrings.xml\", xmlBuilder.build(this._sharedStrings), zipFileOpts);\n        this._zip.file(\"xl/styles.xml\", xmlBuilder.build(this._styleSheet), zipFileOpts);\n        this._zip.file(\"xl/workbook.xml\", xmlBuilder.build(this._node), zipFileOpts);\n\n        // Generate the zip.\n        return this._zip.generateAsync({\n            type: \"nodebuffer\",\n            compression: \"DEFLATE\"\n        }).then(output => {\n            // If a password is set, encrypt the workbook.\n            if (opts.password) output = encryptor.encrypt(output, opts.password);\n\n            // Convert and return\n            return this._convertBufferToOutput(output, opts.type);\n        });\n    }\n\n    /**\n     * Gets the sheet with the provided name or index (0-based).\n     * @param {string|number} sheetNameOrIndex - The sheet name or index.\n     * @returns {Sheet|undefined} The sheet or undefined if not found.\n     */\n    sheet(sheetNameOrIndex) {\n        if (_.isInteger(sheetNameOrIndex)) return this._sheets[sheetNameOrIndex];\n        return _.find(this._sheets, sheet => sheet.name() === sheetNameOrIndex);\n    }\n\n    /**\n     * Get an array of all the sheets in the workbook.\n     * @returns {Array.<Sheet>} The sheets.\n     */\n    sheets() {\n        return this._sheets.slice();\n    }\n\n    /**\n     * Gets an individual property.\n     * @param {string} name - The name of the property.\n     * @returns {*} The property.\n     *//**\n     * Gets multiple properties.\n     * @param {Array.<string>} names - The names of the properties.\n     * @returns {object.<string, *>} Object whose keys are the property names and values are the properties.\n     *//**\n     * Sets an individual property.\n     * @param {string} name - The name of the property.\n     * @param {*} value - The value to set.\n     * @returns {Workbook} The workbook.\n     *//**\n     * Sets multiple properties.\n     * @param {object.<string, *>} properties - Object whose keys are the property names and values are the values to set.\n     * @returns {Workbook} The workbook.\n     */\n    property() {\n        return new ArgHandler(\"Workbook.property\")\n            .case('string', name => {\n                // Get single value\n                return this._coreProperties.get(name);\n            })\n            .case('array', names => {\n                // Get list of values\n                const values = {};\n                names.forEach(name => {\n                    values[name] = this._coreProperties.get(name);\n                });\n\n                return values;\n            })\n            .case(['string', '*'], (name, value) => {\n                // Set a single value for all cells to a single value\n                this._coreProperties.set(name, value);\n                return this;\n            })\n            .case('object', nameValues => {\n                // Object of key value pairs to set\n                for (const name in nameValues) {\n                    if (!nameValues.hasOwnProperty(name)) continue;\n                    const value = nameValues[name];\n                    this._coreProperties.set(name, value);\n                }\n\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Get access to core properties object\n     * @returns {CoreProperties} The core properties.\n     */\n    properties() {\n        return this._coreProperties;\n    }\n\n    /**\n     * Write the workbook to file. (Not supported in browsers.)\n     * @param {string} path - The path of the file to write.\n     * @param {{}} [opts] - Options\n     * @param {string} [opts.password] - The password to encrypt the workbook.\n     * @returns {Promise.<undefined>} A promise.\n     */\n    toFileAsync(path, opts) {\n        if (process.browser) throw new Error(\"Workbook.toFileAsync is not supported in the browser.\");\n        return this.outputAsync(opts)\n            .then(data => new externals.Promise((resolve, reject) => {\n                fs.writeFile(path, data, err => {\n                    if (err) return reject(err);\n                    resolve();\n                });\n            }));\n    }\n\n    /**\n     * Gets a scoped defined name.\n     * @param {Sheet} sheetScope - The sheet the name is scoped to. Use undefined for workbook scope.\n     * @param {string} name - The defined name.\n     * @returns {undefined|Cell|Range|Row|Column} What the defined name refers to.\n     * @ignore\n     *//**\n     * Sets a scoped defined name.\n     * @param {Sheet} sheetScope - The sheet the name is scoped to. Use undefined for workbook scope.\n     * @param {string} name - The defined name.\n     * @param {undefined|Cell|Range|Row|Column} refersTo - What the defined name refers to.\n     * @returns {Workbook} The workbook.\n     * @ignore\n     */\n    scopedDefinedName(sheetScope, name, refersTo) {\n        let definedNamesNode = xmlq.findChild(this._node, \"definedNames\");\n        let definedNameNode = definedNamesNode && _.find(definedNamesNode.children, node => node.attributes.name === name && node.localSheet === sheetScope);\n\n        return new ArgHandler('Workbook.scopedDefinedName')\n            .case(['*', 'string'], () => {\n                // Get the address from the definedNames node.\n                const refersTo = definedNameNode && definedNameNode.children[0];\n                if (!refersTo) return undefined;\n\n                // Try to parse the address.\n                const ref = addressConverter.fromAddress(refersTo);\n                if (!ref) return refersTo;\n\n                // Load the appropriate selection type.\n                const sheet = this.sheet(ref.sheetName);\n                if (ref.type === 'cell') return sheet.cell(ref.rowNumber, ref.columnNumber);\n                if (ref.type === 'range') return sheet.range(ref.startRowNumber, ref.startColumnNumber, ref.endRowNumber, ref.endColumnNumber);\n                if (ref.type === 'row') return sheet.row(ref.rowNumber);\n                if (ref.type === 'column') return sheet.column(ref.columnNumber);\n                return refersTo;\n            })\n            .case(['*', 'string', 'nil'], () => {\n                if (definedNameNode) xmlq.removeChild(definedNamesNode, definedNameNode);\n                if (definedNamesNode && !definedNamesNode.children.length) xmlq.removeChild(this._node, definedNamesNode);\n                return this;\n            })\n            .case(['*', 'string', '*'], () => {\n                if (typeof refersTo !== 'string') {\n                    refersTo = refersTo.address({\n                        includeSheetName: true,\n                        anchored: true\n                    });\n                }\n\n                if (!definedNamesNode) {\n                    definedNamesNode = {\n                        name: \"definedNames\",\n                        attributes: {},\n                        children: []\n                    };\n\n                    xmlq.insertInOrder(this._node, definedNamesNode, nodeOrder);\n                }\n\n                if (!definedNameNode) {\n                    definedNameNode = {\n                        name: \"definedName\",\n                        attributes: { name },\n                        children: [refersTo]\n                    };\n\n                    if (sheetScope) definedNameNode.localSheet = sheetScope;\n\n                    xmlq.appendChild(definedNamesNode, definedNameNode);\n                }\n\n                definedNameNode.children = [refersTo];\n\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Get the shared strings table.\n     * @returns {SharedStrings} The shared strings table.\n     * @ignore\n     */\n    sharedStrings() {\n        return this._sharedStrings;\n    }\n\n    /**\n     * Get the style sheet.\n     * @returns {StyleSheet} The style sheet.\n     * @ignore\n     */\n    styleSheet() {\n        return this._styleSheet;\n    }\n\n    /**\n     * Add a new sheet to the workbook.\n     * \n     * **WARN:** this function has limits:  if you clone a sheet with some images or other things link outside the Sheet object, these things in the cloned sheet will be locked when you open in MS Excel app.\n     * @param {Sheet} from - The sheet to be cloned.\n     * @param {string} name - The name of the new sheet. Must be unique, less than 31 characters, and may not contain the following characters: \\ / * [ ] : ?\n     * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.\n     * @returns {Sheet} The new sheet.\n     */\n    cloneSheet(from, name, indexOrBeforeSheet) {\n        if (!from || !(from instanceof Sheet)) throw new Error(\"Invalid clone from.\");\n\n        return this._addSheet(name, indexOrBeforeSheet, () => {\n            const cloneXml = node => {\n                // If the node has a toXml method, call it.\n                if (node && _.isFunction(node.toXml)) node = node.toXml();\n        \n                if (typeof node === 'object') {\n                    if (node.name) {\n                        const result = {\n                            name: node.name,\n                            attributes: {},\n                            children: []\n                        };\n                        \n                        _.forOwn(node.attributes, (value, name) => {\n                            result.attributes[name] = value;\n                        }); \n                    \n                        let chld;\n                        if (node.children) { \n                            node.children.forEach(child => {\n                                chld = cloneXml(child);\n                                if (child !== null) {\n                                    result.children.push(chld);\n                                }\n                            });\n                        }\n                        return result;\n                    }\n                } else if (node !== null) {\n                    return node;\n                } \n                return null;\n            };\n\n            // clone SheetNode & relationshipNode from source\n            const fromXml = from.toXmls();\n            const sheetNode = cloneXml(fromXml.sheet);\n            const relationshipNode = cloneXml(fromXml.relationships);\n            return { sheetNode, relationshipNode };\n        });\n    }\n\n    /**\n     * Add a new sheet to the workbook.\n     * @param {string} name - The name of the sheet. Must be unique, less than 31 characters, and may not contain the following characters: \\ / * [ ] : ?\n     * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.\n     * @param {callback} [getTemplateNodes] optional callback function for template nodes\n     * @returns {Sheet} The new sheet.\n     * @private\n     */\n    _addSheet(name, indexOrBeforeSheet, getTemplateNodes) {\n        // Validate the sheet name.\n        if (!name || typeof name !== \"string\") throw new Error(\"Invalid sheet name.\");\n        if (_.some(badSheetNameChars, char => name.indexOf(char) >= 0)) throw new Error(`Sheet name may not contain any of the following characters: ${badSheetNameChars.join(\" \")}`);\n        if (name.length > maxSheetNameLength) throw new Error(`Sheet name may not be greater than ${maxSheetNameLength} characters.`);\n        if (this.sheet(name)) throw new Error(`Sheet with name \"${name}\" already exists.`);\n\n        // Get the destination index of new sheet.\n        let index;\n        if (_.isNil(indexOrBeforeSheet)) {\n            index = this._sheets.length;\n        } else if (_.isInteger(indexOrBeforeSheet)) {\n            index = indexOrBeforeSheet;\n        } else {\n            if (!(indexOrBeforeSheet instanceof Sheet)) {\n                indexOrBeforeSheet = this.sheet(indexOrBeforeSheet);\n                if (!indexOrBeforeSheet) throw new Error(\"Invalid before sheet reference.\");\n            }\n\n            index = this._sheets.indexOf(indexOrBeforeSheet);\n        }\n\n        // Add a new relationship for the new sheet and create the new sheet ID node.\n        const relationship = this._relationships.add(\"worksheet\"); // Leave target blank as it will be filled later.\n        const sheetIdNode = {\n            name: \"sheet\",\n            attributes: {\n                name,\n                sheetId: ++this._maxSheetId,\n                'r:id': relationship.attributes.Id\n            },\n            children: []\n        };\n\n        // Create the new sheet.\n        let sheet;\n        if (getTemplateNodes) {\n            const { sheetNode, relationshipNode } = getTemplateNodes();\n            sheet = new Sheet(this, sheetIdNode, sheetNode, relationshipNode);\n        } else {\n            sheet = new Sheet(this, sheetIdNode);\n        }\n\n        // Insert the sheet at the appropriate index.\n        this._sheets.splice(index, 0, sheet);\n\n        return sheet;\n    }\n\n    /**\n     * Initialize the workbook. (This is separated from the constructor to ease testing.)\n     * @param {string|ArrayBuffer|Uint8Array|Buffer|Blob} data - The data to load.\n     * @param {{}} [opts] - Options\n     * @param {boolean} [opts.base64=false] - No used unless input is a string. True if the input string is base64 encoded, false for binary.\n     * @returns {Promise.<Workbook>} The workbook.\n     * @private\n     */\n    _initAsync(data, opts) {\n        opts = opts || {};\n\n        this._maxSheetId = 0;\n        this._sheets = [];\n\n        return externals.Promise.resolve()\n            .then(() => {\n                // Make sure the input is a Buffer\n                return this._convertInputToBufferAsync(data, opts.base64)\n                    .then(buffer => {\n                        data = buffer;\n                    });\n            })\n            .then(() => {\n                if (!opts.password) return;\n                return encryptor.decryptAsync(data, opts.password)\n                    .then(decrypted => {\n                        data = decrypted;\n                    });\n            })\n            .then(() => JSZip.loadAsync(data))\n            .then(zip => {\n                this._zip = zip;\n                return this._parseNodesAsync([\n                    \"[Content_Types].xml\",\n                    \"docProps/app.xml\",\n                    \"docProps/core.xml\",\n                    \"xl/_rels/workbook.xml.rels\",\n                    \"xl/sharedStrings.xml\",\n                    \"xl/styles.xml\",\n                    \"xl/workbook.xml\"\n                ]);\n            })\n            .then(nodes => {\n                const contentTypesNode = nodes[0];\n                const appPropertiesNode = nodes[1];\n                const corePropertiesNode = nodes[2];\n                const relationshipsNode = nodes[3];\n                const sharedStringsNode = nodes[4];\n                const styleSheetNode = nodes[5];\n                const workbookNode = nodes[6];\n\n                // Load the various components.\n                this._contentTypes = new ContentTypes(contentTypesNode);\n                this._appProperties = new AppProperties(appPropertiesNode);\n                this._coreProperties = new CoreProperties(corePropertiesNode);\n                this._relationships = new Relationships(relationshipsNode);\n                this._sharedStrings = new SharedStrings(sharedStringsNode);\n                this._styleSheet = new StyleSheet(styleSheetNode);\n                this._node = workbookNode;\n\n                // Add the shared strings relationship if it doesn't exist.\n                if (!this._relationships.findByType(\"sharedStrings\")) {\n                    this._relationships.add(\"sharedStrings\", \"sharedStrings.xml\");\n                }\n\n                // Add the shared string content type if it doesn't exist.\n                if (!this._contentTypes.findByPartName(\"/xl/sharedStrings.xml\")) {\n                    this._contentTypes.add(\"/xl/sharedStrings.xml\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml\");\n                }\n\n                // Kill the calc chain. It's not required and the workbook will corrupt unless we keep it up to date.\n                this._zip.remove(\"xl/calcChain.xml\");\n\n                // Load each sheet.\n                this._sheetsNode = xmlq.findChild(this._node, \"sheets\");\n                return externals.Promise.all(_.map(this._sheetsNode.children, (sheetIdNode, i) => {\n                    if (sheetIdNode.attributes.sheetId > this._maxSheetId) this._maxSheetId = sheetIdNode.attributes.sheetId;\n\n                    return this._parseNodesAsync([`xl/worksheets/sheet${i + 1}.xml`, `xl/worksheets/_rels/sheet${i + 1}.xml.rels`])\n                        .then(nodes => {\n                            const sheetNode = nodes[0];\n                            const sheetRelationshipsNode = nodes[1];\n\n                            // Insert at position i as the promises will resolve at different times.\n                            this._sheets[i] = new Sheet(this, sheetIdNode, sheetNode, sheetRelationshipsNode);\n                        });\n                }));\n            })\n            .then(() => this._parseSheetRefs())\n            .then(() => this);\n    }\n\n    /**\n     * Parse files out of zip into XML node objects.\n     * @param {Array.<string>} names - The file names to parse.\n     * @returns {Promise.<Array.<{}>>} An array of the parsed objects.\n     * @private\n     */\n    _parseNodesAsync(names) {\n        return externals.Promise.all(_.map(names, name => this._zip.file(name)))\n            .then(files => externals.Promise.all(_.map(files, file => file && file.async(\"string\"))))\n            .then(texts => externals.Promise.all(_.map(texts, text => text && xmlParser.parseAsync(text))));\n    }\n\n    /**\n     * Parse the sheet references out so we can reorder freely.\n     * @returns {undefined}\n     * @private\n     */\n    _parseSheetRefs() {\n        // Parse the active sheet.\n        const bookViewsNode = xmlq.findChild(this._node, \"bookViews\");\n        const workbookViewNode = bookViewsNode && xmlq.findChild(bookViewsNode, \"workbookView\");\n        const activeTabId = workbookViewNode && workbookViewNode.attributes.activeTab || 0;\n        this._activeSheet = this._sheets[activeTabId];\n\n        // Set the location sheet on the defined name nodes. The defined name should point to the index of the sheet\n        // but reordering sheets messes this up. So store it on the node and we'll update the index on XML build.\n        const definedNamesNode = xmlq.findChild(this._node, \"definedNames\");\n        if (definedNamesNode) {\n            _.forEach(definedNamesNode.children, definedNameNode => {\n                if (definedNameNode.attributes.hasOwnProperty(\"localSheetId\")) {\n                    definedNameNode.localSheet = this._sheets[definedNameNode.attributes.localSheetId];\n                }\n            });\n        }\n    }\n\n    /**\n     * Set the proper sheet references in the XML.\n     * @returns {undefined}\n     * @private\n     */\n    _setSheetRefs() {\n        // Set the active sheet.\n        let bookViewsNode = xmlq.findChild(this._node, \"bookViews\");\n        if (!bookViewsNode) {\n            bookViewsNode = { name: 'bookViews', attributes: {}, children: [] };\n            xmlq.insertInOrder(this._node, bookViewsNode, nodeOrder);\n        }\n\n        let workbookViewNode = xmlq.findChild(bookViewsNode, \"workbookView\");\n        if (!workbookViewNode) {\n            workbookViewNode = { name: 'workbookView', attributes: {}, children: [] };\n            xmlq.appendChild(bookViewsNode, workbookViewNode);\n        }\n\n        workbookViewNode.attributes.activeTab = this._sheets.indexOf(this._activeSheet);\n\n        // Set the defined names local sheet indexes.\n        const definedNamesNode = xmlq.findChild(this._node, \"definedNames\");\n        if (definedNamesNode) {\n            _.forEach(definedNamesNode.children, definedNameNode => {\n                if (definedNameNode.localSheet) {\n                    definedNameNode.attributes.localSheetId = this._sheets.indexOf(definedNameNode.localSheet);\n                }\n            });\n        }\n    }\n\n    /**\n     * Convert buffer to desired output format\n     * @param {Buffer} buffer - The buffer\n     * @param {string} type - The type to convert to: buffer/nodebuffer, blob, base64, binarystring, uint8array, arraybuffer\n     * @returns {Buffer|Blob|string|Uint8Array|ArrayBuffer} The output\n     * @private\n     */\n    _convertBufferToOutput(buffer, type) {\n        if (!type) type = process.browser ? \"blob\" : \"nodebuffer\";\n\n        if (type === \"buffer\" || type === \"nodebuffer\") return buffer;\n        if (process.browser && type === \"blob\") return new Blob([buffer], { type: Workbook.MIME_TYPE });\n        if (type === \"base64\") return buffer.toString(\"base64\");\n        if (type === \"binarystring\") return buffer.toString(\"utf8\");\n        if (type === \"uint8array\") return new Uint8Array(buffer);\n        if (type === \"arraybuffer\") return new Uint8Array(buffer).buffer;\n\n        throw new Error(`Output type '${type}' not supported.`);\n    }\n\n    /**\n     * Convert input to buffer\n     * @param {Buffer|Blob|string|Uint8Array|ArrayBuffer} input - The input\n     * @param {boolean} [base64=false] - Only applies if input is a string. If true, the string is base64 encoded, false for binary\n     * @returns {Promise.<Buffer>} The buffer.\n     * @private\n     */\n    _convertInputToBufferAsync(input, base64) {\n        return externals.Promise.resolve()\n            .then(() => {\n                if (Buffer.isBuffer(input)) return input;\n\n                if (process.browser && input instanceof Blob) {\n                    return new externals.Promise(resolve => {\n                        const fileReader = new FileReader();\n                        fileReader.onload = event => {\n                            resolve(Buffer.from(event.target.result));\n                        };\n                        fileReader.readAsArrayBuffer(input);\n                    });\n                }\n\n                if (typeof input === \"string\" && base64) return Buffer.from(input, \"base64\");\n                if (typeof input === \"string\" && !base64) return Buffer.from(input, \"utf8\");\n                if (input instanceof Uint8Array || input instanceof ArrayBuffer) return Buffer.from(input);\n\n                throw new Error(`Input type unknown.`);\n            });\n    }\n}\n\n/**\n * The XLSX mime type.\n * @type {string}\n * @ignore\n */\nWorkbook.MIME_TYPE = \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\";\n\nmodule.exports = Workbook;\n\n/*\nxl/workbook.xml\n\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<workbook xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" mc:Ignorable=\"x15\" xmlns:x15=\"http://schemas.microsoft.com/office/spreadsheetml/2010/11/main\">\n\t<fileVersion appName=\"xl\" lastEdited=\"7\" lowestEdited=\"7\" rupBuild=\"16925\"/>\n\t<workbookPr defaultThemeVersion=\"164011\"/>\n\t<mc:AlternateContent xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\">\n\t\t<mc:Choice Requires=\"x15\">\n\t\t\t<x15ac:absPath url=\"\\path\\to\\file\" xmlns:x15ac=\"http://schemas.microsoft.com/office/spreadsheetml/2010/11/ac\"/>\n\t\t</mc:Choice>\n\t</mc:AlternateContent>\n\t<bookViews>\n\t\t<workbookView xWindow=\"3720\" yWindow=\"0\" windowWidth=\"27870\" windowHeight=\"12795\"/>\n\t</bookViews>\n\t<sheets>\n\t\t<sheet name=\"Sheet1\" sheetId=\"1\" r:id=\"rId1\"/>\n\t</sheets>\n\t<calcPr calcId=\"171027\"/>\n\t<extLst>\n\t\t<ext uri=\"{140A7094-0E35-4892-8432-C4D2E57EDEB5}\" xmlns:x15=\"http://schemas.microsoft.com/office/spreadsheetml/2010/11/main\">\n\t\t\t<x15:workbookPr chartTrackingRefBase=\"1\"/>\n\t\t</ext>\n\t</extLst>\n</workbook>\n// */\n"]},"metadata":{},"sourceType":"script"}