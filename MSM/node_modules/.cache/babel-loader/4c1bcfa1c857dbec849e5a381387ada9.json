{"ast":null,"code":"\"use strict\";\n\nconst ArgHandler = require(\"./ArgHandler\");\n\nconst addressConverter = require('./addressConverter'); // Default column width.\n\n\nconst defaultColumnWidth = 9.140625;\n/**\n * A column.\n */\n\nclass Column {\n  // /**\n  //  * Creates a new Column.\n  //  * @param {Sheet} sheet - The parent sheet.\n  //  * @param {{}} node - The column node.\n  //  * @constructor\n  //  * @ignore\n  //  * @private\n  //  */\n  constructor(sheet, node) {\n    this._sheet = sheet;\n    this._node = node;\n  }\n  /* PUBLIC */\n\n  /**\n   * Get the address of the column.\n   * @param {{}} [opts] - Options\n   * @param {boolean} [opts.includeSheetName] - Include the sheet name in the address.\n   * @param {boolean} [opts.anchored] - Anchor the address.\n   * @returns {string} The address\n   */\n\n\n  address(opts) {\n    return addressConverter.toAddress({\n      type: 'column',\n      columnName: this.columnName(),\n      sheetName: opts && opts.includeSheetName && this.sheet().name(),\n      columnAnchored: opts && opts.anchored\n    });\n  }\n  /**\n   * Get a cell within the column.\n   * @param {number} rowNumber - The row number.\n   * @returns {Cell} The cell in the column with the given row number.\n   */\n\n\n  cell(rowNumber) {\n    return this.sheet().cell(rowNumber, this.columnNumber());\n  }\n  /**\n   * Get the name of the column.\n   * @returns {string} The column name.\n   */\n\n\n  columnName() {\n    return addressConverter.columnNumberToName(this.columnNumber());\n  }\n  /**\n   * Get the number of the column.\n   * @returns {number} The column number.\n   */\n\n\n  columnNumber() {\n    return this._node.attributes.min;\n  }\n  /**\n   * Gets a value indicating whether the column is hidden.\n   * @returns {boolean} A flag indicating whether the column is hidden.\n   */\n\n  /**\n  * Sets whether the column is hidden.\n  * @param {boolean} hidden - A flag indicating whether to hide the column.\n  * @returns {Column} The column.\n  */\n\n\n  hidden() {\n    return new ArgHandler(\"Column.hidden\").case(() => {\n      return this._node.attributes.hidden === 1;\n    }).case('boolean', hidden => {\n      if (hidden) this._node.attributes.hidden = 1;else delete this._node.attributes.hidden;\n      return this;\n    }).handle(arguments);\n  }\n  /**\n   * Get the parent sheet.\n   * @returns {Sheet} The parent sheet.\n   */\n\n\n  sheet() {\n    return this._sheet;\n  }\n  /**\n   * Gets an individual style.\n   * @param {string} name - The name of the style.\n   * @returns {*} The style.\n   */\n\n  /**\n  * Gets multiple styles.\n  * @param {Array.<string>} names - The names of the style.\n  * @returns {object.<string, *>} Object whose keys are the style names and values are the styles.\n  */\n\n  /**\n  * Sets an individual style.\n  * @param {string} name - The name of the style.\n  * @param {*} value - The value to set.\n  * @returns {Cell} The cell.\n  */\n\n  /**\n  * Sets multiple styles.\n  * @param {object.<string, *>} styles - Object whose keys are the style names and values are the styles to set.\n  * @returns {Cell} The cell.\n  */\n\n  /**\n  * Sets to a specific style\n  * @param {Style} style - Style object given from stylesheet.createStyle\n  * @returns {Cell} The cell.\n  */\n\n\n  style() {\n    return new ArgHandler(\"Column.style\").case('string', name => {\n      // Get single value\n      this._createStyleIfNeeded();\n\n      return this._style.style(name);\n    }).case('array', names => {\n      // Get list of values\n      const values = {};\n      names.forEach(name => {\n        values[name] = this.style(name);\n      });\n      return values;\n    }).case(['string', '*'], (name, value) => {\n      // If a row node is already defined that intersects with this column and that row has a style set, we\n      // need to make sure that a cell node exists at the intersection so we can style it appropriately.\n      // Fetching the cell will force a new cell node to be created with a style matching the column. So we\n      // will fetch and style the cell at each row that intersects this column if it is already present or it\n      // has a style defined.\n      this.sheet().forEachExistingRow(row => {\n        if (row.hasStyle() || row.hasCell(this.columnNumber())) {\n          row.cell(this.columnNumber()).style(name, value);\n        }\n      }); // Set a single value for all cells to a single value\n\n      this._createStyleIfNeeded();\n\n      this._style.style(name, value);\n\n      return this;\n    }).case('object', nameValues => {\n      // Object of key value pairs to set\n      for (const name in nameValues) {\n        if (!nameValues.hasOwnProperty(name)) continue;\n        const value = nameValues[name];\n        this.style(name, value);\n      }\n\n      return this;\n    }).case('Style', style => {\n      // See Large Comment Above\n      this.sheet().forEachExistingRow(row => {\n        if (row.hasStyle() || row.hasCell(this.columnNumber())) {\n          row.cell(this.columnNumber()).style(style);\n        }\n      });\n      this._style = style;\n      this._node.attributes.style = style.id();\n      return this;\n    }).handle(arguments);\n  }\n  /**\n   * Gets the width.\n   * @returns {undefined|number} The width (or undefined).\n   */\n\n  /**\n  * Sets the width.\n  * @param {number} width - The width of the column.\n  * @returns {Column} The column.\n  */\n\n\n  width(width) {\n    return new ArgHandler(\"Column.width\").case(() => {\n      return this._node.attributes.customWidth ? this._node.attributes.width : undefined;\n    }).case('number', width => {\n      this._node.attributes.width = width;\n      this._node.attributes.customWidth = 1;\n      return this;\n    }).case('nil', () => {\n      delete this._node.attributes.width;\n      delete this._node.attributes.customWidth;\n      return this;\n    }).handle(arguments);\n  }\n  /**\n   * Get the parent workbook.\n   * @returns {Workbook} The parent workbook.\n   */\n\n\n  workbook() {\n    return this.sheet().workbook();\n  }\n  /**\n   * Append vertical page break after the column.\n   * @returns {Column} the column.\n   */\n\n\n  addPageBreak() {\n    this.sheet().verticalPageBreaks().add(this.columnNumber());\n    return this;\n  }\n  /* INTERNAL */\n\n  /**\n   * Convert the column to an XML object.\n   * @returns {{}} The XML form.\n   * @ignore\n   */\n\n\n  toXml() {\n    return this._node;\n  }\n  /* PRIVATE */\n\n  /**\n   * Create a style for this column if it doesn't already exist.\n   * @returns {undefined}\n   * @private\n   */\n\n\n  _createStyleIfNeeded() {\n    if (!this._style) {\n      const styleId = this._node.attributes.style;\n      this._style = this.workbook().styleSheet().createStyle(styleId);\n      this._node.attributes.style = this._style.id();\n      if (!this.width()) this.width(defaultColumnWidth);\n    }\n  }\n\n}\n\nmodule.exports = Column;","map":{"version":3,"sources":["C:/Users/tzika/Desktop/Polymerlink-Front/polymerlink-2/node_modules/xlsx-populate/lib/Column.js"],"names":["ArgHandler","require","addressConverter","defaultColumnWidth","Column","constructor","sheet","node","_sheet","_node","address","opts","toAddress","type","columnName","sheetName","includeSheetName","name","columnAnchored","anchored","cell","rowNumber","columnNumber","columnNumberToName","attributes","min","hidden","case","handle","arguments","style","_createStyleIfNeeded","_style","names","values","forEach","value","forEachExistingRow","row","hasStyle","hasCell","nameValues","hasOwnProperty","id","width","customWidth","undefined","workbook","addPageBreak","verticalPageBreaks","add","toXml","styleId","styleSheet","createStyle","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst ArgHandler = require(\"./ArgHandler\");\nconst addressConverter = require('./addressConverter');\n\n// Default column width.\nconst defaultColumnWidth = 9.140625;\n\n/**\n * A column.\n */\nclass Column {\n    // /**\n    //  * Creates a new Column.\n    //  * @param {Sheet} sheet - The parent sheet.\n    //  * @param {{}} node - The column node.\n    //  * @constructor\n    //  * @ignore\n    //  * @private\n    //  */\n    constructor(sheet, node) {\n        this._sheet = sheet;\n        this._node = node;\n    }\n\n    /* PUBLIC */\n\n    /**\n     * Get the address of the column.\n     * @param {{}} [opts] - Options\n     * @param {boolean} [opts.includeSheetName] - Include the sheet name in the address.\n     * @param {boolean} [opts.anchored] - Anchor the address.\n     * @returns {string} The address\n     */\n    address(opts) {\n        return addressConverter.toAddress({\n            type: 'column',\n            columnName: this.columnName(),\n            sheetName: opts && opts.includeSheetName && this.sheet().name(),\n            columnAnchored: opts && opts.anchored\n        });\n    }\n\n    /**\n     * Get a cell within the column.\n     * @param {number} rowNumber - The row number.\n     * @returns {Cell} The cell in the column with the given row number.\n     */\n    cell(rowNumber) {\n        return this.sheet().cell(rowNumber, this.columnNumber());\n    }\n\n    /**\n     * Get the name of the column.\n     * @returns {string} The column name.\n     */\n    columnName() {\n        return addressConverter.columnNumberToName(this.columnNumber());\n    }\n\n    /**\n     * Get the number of the column.\n     * @returns {number} The column number.\n     */\n    columnNumber() {\n        return this._node.attributes.min;\n    }\n\n    /**\n     * Gets a value indicating whether the column is hidden.\n     * @returns {boolean} A flag indicating whether the column is hidden.\n     *//**\n     * Sets whether the column is hidden.\n     * @param {boolean} hidden - A flag indicating whether to hide the column.\n     * @returns {Column} The column.\n     */\n    hidden() {\n        return new ArgHandler(\"Column.hidden\")\n            .case(() => {\n                return this._node.attributes.hidden === 1;\n            })\n            .case('boolean', hidden => {\n                if (hidden) this._node.attributes.hidden = 1;\n                else delete this._node.attributes.hidden;\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Get the parent sheet.\n     * @returns {Sheet} The parent sheet.\n     */\n    sheet() {\n        return this._sheet;\n    }\n\n    /**\n     * Gets an individual style.\n     * @param {string} name - The name of the style.\n     * @returns {*} The style.\n     *//**\n     * Gets multiple styles.\n     * @param {Array.<string>} names - The names of the style.\n     * @returns {object.<string, *>} Object whose keys are the style names and values are the styles.\n     *//**\n     * Sets an individual style.\n     * @param {string} name - The name of the style.\n     * @param {*} value - The value to set.\n     * @returns {Cell} The cell.\n     *//**\n     * Sets multiple styles.\n     * @param {object.<string, *>} styles - Object whose keys are the style names and values are the styles to set.\n     * @returns {Cell} The cell.\n     *//**\n\t * Sets to a specific style\n\t * @param {Style} style - Style object given from stylesheet.createStyle\n\t * @returns {Cell} The cell.\n\t */\n    style() {\n        return new ArgHandler(\"Column.style\")\n            .case('string', name => {\n                // Get single value\n                this._createStyleIfNeeded();\n                return this._style.style(name);\n            })\n            .case('array', names => {\n                // Get list of values\n                const values = {};\n                names.forEach(name => {\n                    values[name] = this.style(name);\n                });\n\n                return values;\n            })\n            .case(['string', '*'], (name, value) => {\n                // If a row node is already defined that intersects with this column and that row has a style set, we\n                // need to make sure that a cell node exists at the intersection so we can style it appropriately.\n                // Fetching the cell will force a new cell node to be created with a style matching the column. So we\n                // will fetch and style the cell at each row that intersects this column if it is already present or it\n                // has a style defined.\n                this.sheet().forEachExistingRow(row => {\n                    if (row.hasStyle() || row.hasCell(this.columnNumber())) {\n                        row.cell(this.columnNumber()).style(name, value);\n                    }\n                });\n\n                // Set a single value for all cells to a single value\n                this._createStyleIfNeeded();\n                this._style.style(name, value);\n\n                return this;\n            })\n            .case('object', nameValues => {\n                // Object of key value pairs to set\n                for (const name in nameValues) {\n                    if (!nameValues.hasOwnProperty(name)) continue;\n                    const value = nameValues[name];\n                    this.style(name, value);\n                }\n\n                return this;\n            })\n            .case('Style', style => {\n                // See Large Comment Above\n                this.sheet().forEachExistingRow(row => {\n                    if (row.hasStyle() || row.hasCell(this.columnNumber())) {\n                        row.cell(this.columnNumber()).style(style);\n                    }\n                });\n\n                this._style = style;\n                this._node.attributes.style = style.id();\n\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Gets the width.\n     * @returns {undefined|number} The width (or undefined).\n     *//**\n     * Sets the width.\n     * @param {number} width - The width of the column.\n     * @returns {Column} The column.\n     */\n    width(width) {\n        return new ArgHandler(\"Column.width\")\n            .case(() => {\n                return this._node.attributes.customWidth ? this._node.attributes.width : undefined;\n            })\n            .case('number', width => {\n                this._node.attributes.width = width;\n                this._node.attributes.customWidth = 1;\n                return this;\n            })\n            .case('nil', () => {\n                delete this._node.attributes.width;\n                delete this._node.attributes.customWidth;\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Get the parent workbook.\n     * @returns {Workbook} The parent workbook.\n     */\n    workbook() {\n        return this.sheet().workbook();\n    }\n\n    /**\n     * Append vertical page break after the column.\n     * @returns {Column} the column.\n     */\n    addPageBreak() {\n        this.sheet().verticalPageBreaks().add(this.columnNumber());\n        return this;\n    }\n\n    /* INTERNAL */\n\n    /**\n     * Convert the column to an XML object.\n     * @returns {{}} The XML form.\n     * @ignore\n     */\n    toXml() {\n        return this._node;\n    }\n\n    /* PRIVATE */\n\n    /**\n     * Create a style for this column if it doesn't already exist.\n     * @returns {undefined}\n     * @private\n     */\n    _createStyleIfNeeded() {\n        if (!this._style) {\n            const styleId = this._node.attributes.style;\n            this._style = this.workbook().styleSheet().createStyle(styleId);\n            this._node.attributes.style = this._style.id();\n\n            if (!this.width()) this.width(defaultColumnWidth);\n        }\n    }\n}\n\nmodule.exports = Column;\n"]},"metadata":{},"sourceType":"script"}