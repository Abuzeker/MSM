{"ast":null,"code":"\"use strict\";\n\nconst _ = require(\"lodash\");\n/**\n * XML query methods.\n * @private\n */\n\n\nmodule.exports = {\n  /**\n   * Append a child to the node.\n   * @param {{}} node - The parent node.\n   * @param {{}} child - The child node.\n   * @returns {undefined}\n   */\n  appendChild(node, child) {\n    if (!node.children) node.children = [];\n    node.children.push(child);\n  },\n\n  /**\n   * Append a child if one with the given name is not found.\n   * @param {{}} node - The parent node.\n   * @param {string} name - The child node name.\n   * @returns {{}} The child.\n   */\n  appendChildIfNotFound(node, name) {\n    let child = this.findChild(node, name);\n\n    if (!child) {\n      child = {\n        name,\n        attributes: {},\n        children: []\n      };\n      this.appendChild(node, child);\n    }\n\n    return child;\n  },\n\n  /**\n   * Find a child with the given name.\n   * @param {{}} node - The parent node.\n   * @param {string} name - The name to find.\n   * @returns {undefined|{}} The child if found.\n   */\n  findChild(node, name) {\n    return _.find(node.children, {\n      name\n    });\n  },\n\n  /**\n   * Get an attribute from a child node.\n   * @param {{}} node - The parent node.\n   * @param {string} name - The name of the child node.\n   * @param {string} attribute - The name of the attribute.\n   * @returns {undefined|*} The value of the attribute if found.\n   */\n  getChildAttribute(node, name, attribute) {\n    const child = this.findChild(node, name);\n    if (child) return child.attributes && child.attributes[attribute];\n  },\n\n  /**\n   * Returns a value indicating whether the node has a child with the given name.\n   * @param {{}} node - The parent node.\n   * @param {string} name - The name of the child node.\n   * @returns {boolean} True if found, false otherwise.\n   */\n  hasChild(node, name) {\n    return _.some(node.children, {\n      name\n    });\n  },\n\n  /**\n   * Insert the child after the specified node.\n   * @param {{}} node - The parent node.\n   * @param {{}} child - The child node.\n   * @param {{}} after - The node to insert after.\n   * @returns {undefined}\n   */\n  insertAfter(node, child, after) {\n    if (!node.children) node.children = [];\n    const index = node.children.indexOf(after);\n    node.children.splice(index + 1, 0, child);\n  },\n\n  /**\n   * Insert the child before the specified node.\n   * @param {{}} node - The parent node.\n   * @param {{}} child - The child node.\n   * @param {{}} before - The node to insert before.\n   * @returns {undefined}\n   */\n  insertBefore(node, child, before) {\n    if (!node.children) node.children = [];\n    const index = node.children.indexOf(before);\n    node.children.splice(index, 0, child);\n  },\n\n  /**\n   * Insert a child node in the correct order.\n   * @param {{}} node - The parent node.\n   * @param {{}} child - The child node.\n   * @param {Array.<string>} nodeOrder - The order of the node names.\n   * @returns {undefined}\n   */\n  insertInOrder(node, child, nodeOrder) {\n    const childIndex = nodeOrder.indexOf(child.name);\n\n    if (node.children && childIndex >= 0) {\n      for (let i = childIndex + 1; i < nodeOrder.length; i++) {\n        const sibling = this.findChild(node, nodeOrder[i]);\n\n        if (sibling) {\n          this.insertBefore(node, child, sibling);\n          return;\n        }\n      }\n    }\n\n    this.appendChild(node, child);\n  },\n\n  /**\n   * Check if the node is empty (no attributes and no children).\n   * @param {{}} node - The node.\n   * @returns {boolean} True if empty, false otherwise.\n   */\n  isEmpty(node) {\n    return _.isEmpty(node.children) && _.isEmpty(node.attributes);\n  },\n\n  /**\n   * Remove a child node.\n   * @param {{}} node - The parent node.\n   * @param {string|{}} child - The child node or name of node.\n   * @returns {undefined}\n   */\n  removeChild(node, child) {\n    if (!node.children) return;\n\n    if (typeof child === 'string') {\n      _.remove(node.children, {\n        name: child\n      });\n    } else {\n      const index = node.children.indexOf(child);\n      if (index >= 0) node.children.splice(index, 1);\n    }\n  },\n\n  /**\n   * Set/unset the attributes on the node.\n   * @param {{}} node - The node.\n   * @param {{}} attributes - The attributes to set.\n   * @returns {undefined}\n   */\n  setAttributes(node, attributes) {\n    _.forOwn(attributes, (value, attribute) => {\n      if (_.isNil(value)) {\n        if (node.attributes) delete node.attributes[attribute];\n      } else {\n        if (!node.attributes) node.attributes = {};\n        node.attributes[attribute] = value;\n      }\n    });\n  },\n\n  /**\n   * Set attributes on a child node, creating the child if necessary.\n   * @param {{}} node - The parent node.\n   * @param {string} name - The name of the child node.\n   * @param {{}} attributes - The attributes to set.\n   * @returns {{}} The child.\n   */\n  setChildAttributes(node, name, attributes) {\n    let child = this.findChild(node, name);\n\n    _.forOwn(attributes, (value, attribute) => {\n      if (_.isNil(value)) {\n        if (child && child.attributes) delete child.attributes[attribute];\n      } else {\n        if (!child) {\n          child = {\n            name,\n            attributes: {},\n            children: []\n          };\n          this.appendChild(node, child);\n        }\n\n        if (!child.attributes) child.attributes = {};\n        child.attributes[attribute] = value;\n      }\n    });\n\n    return child;\n  },\n\n  /**\n   * Remove the child node if empty.\n   * @param {{}} node - The parent node.\n   * @param {string|{}} child - The child or name of child node.\n   * @returns {undefined}\n   */\n  removeChildIfEmpty(node, child) {\n    if (typeof child === 'string') child = this.findChild(node, child);\n    if (child && this.isEmpty(child)) this.removeChild(node, child);\n  }\n\n};","map":{"version":3,"sources":["C:/Users/tzika/Desktop/MSM Backup/MSM-Front/MSM/node_modules/xlsx-populate/lib/xmlq.js"],"names":["_","require","module","exports","appendChild","node","child","children","push","appendChildIfNotFound","name","findChild","attributes","find","getChildAttribute","attribute","hasChild","some","insertAfter","after","index","indexOf","splice","insertBefore","before","insertInOrder","nodeOrder","childIndex","i","length","sibling","isEmpty","removeChild","remove","setAttributes","forOwn","value","isNil","setChildAttributes","removeChildIfEmpty"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst _ = require(\"lodash\");\n\n/**\n * XML query methods.\n * @private\n */\nmodule.exports = {\n    /**\n     * Append a child to the node.\n     * @param {{}} node - The parent node.\n     * @param {{}} child - The child node.\n     * @returns {undefined}\n     */\n    appendChild(node, child) {\n        if (!node.children) node.children = [];\n        node.children.push(child);\n    },\n\n    /**\n     * Append a child if one with the given name is not found.\n     * @param {{}} node - The parent node.\n     * @param {string} name - The child node name.\n     * @returns {{}} The child.\n     */\n    appendChildIfNotFound(node, name) {\n        let child = this.findChild(node, name);\n        if (!child) {\n            child = { name, attributes: {}, children: [] };\n            this.appendChild(node, child);\n        }\n\n        return child;\n    },\n\n    /**\n     * Find a child with the given name.\n     * @param {{}} node - The parent node.\n     * @param {string} name - The name to find.\n     * @returns {undefined|{}} The child if found.\n     */\n    findChild(node, name) {\n        return _.find(node.children, { name });\n    },\n\n    /**\n     * Get an attribute from a child node.\n     * @param {{}} node - The parent node.\n     * @param {string} name - The name of the child node.\n     * @param {string} attribute - The name of the attribute.\n     * @returns {undefined|*} The value of the attribute if found.\n     */\n    getChildAttribute(node, name, attribute) {\n        const child = this.findChild(node, name);\n        if (child) return child.attributes && child.attributes[attribute];\n    },\n\n    /**\n     * Returns a value indicating whether the node has a child with the given name.\n     * @param {{}} node - The parent node.\n     * @param {string} name - The name of the child node.\n     * @returns {boolean} True if found, false otherwise.\n     */\n    hasChild(node, name) {\n        return _.some(node.children, { name });\n    },\n\n    /**\n     * Insert the child after the specified node.\n     * @param {{}} node - The parent node.\n     * @param {{}} child - The child node.\n     * @param {{}} after - The node to insert after.\n     * @returns {undefined}\n     */\n    insertAfter(node, child, after) {\n        if (!node.children) node.children = [];\n        const index = node.children.indexOf(after);\n        node.children.splice(index + 1, 0, child);\n    },\n\n    /**\n     * Insert the child before the specified node.\n     * @param {{}} node - The parent node.\n     * @param {{}} child - The child node.\n     * @param {{}} before - The node to insert before.\n     * @returns {undefined}\n     */\n    insertBefore(node, child, before) {\n        if (!node.children) node.children = [];\n        const index = node.children.indexOf(before);\n        node.children.splice(index, 0, child);\n    },\n\n    /**\n     * Insert a child node in the correct order.\n     * @param {{}} node - The parent node.\n     * @param {{}} child - The child node.\n     * @param {Array.<string>} nodeOrder - The order of the node names.\n     * @returns {undefined}\n     */\n    insertInOrder(node, child, nodeOrder) {\n        const childIndex = nodeOrder.indexOf(child.name);\n        if (node.children && childIndex >= 0) {\n            for (let i = childIndex + 1; i < nodeOrder.length; i++) {\n                const sibling = this.findChild(node, nodeOrder[i]);\n                if (sibling) {\n                    this.insertBefore(node, child, sibling);\n                    return;\n                }\n            }\n        }\n\n        this.appendChild(node, child);\n    },\n\n    /**\n     * Check if the node is empty (no attributes and no children).\n     * @param {{}} node - The node.\n     * @returns {boolean} True if empty, false otherwise.\n     */\n    isEmpty(node) {\n        return _.isEmpty(node.children) && _.isEmpty(node.attributes);\n    },\n\n    /**\n     * Remove a child node.\n     * @param {{}} node - The parent node.\n     * @param {string|{}} child - The child node or name of node.\n     * @returns {undefined}\n     */\n    removeChild(node, child) {\n        if (!node.children) return;\n        if (typeof child === 'string') {\n            _.remove(node.children, { name: child });\n        } else {\n            const index = node.children.indexOf(child);\n            if (index >= 0) node.children.splice(index, 1);\n        }\n    },\n\n    /**\n     * Set/unset the attributes on the node.\n     * @param {{}} node - The node.\n     * @param {{}} attributes - The attributes to set.\n     * @returns {undefined}\n     */\n    setAttributes(node, attributes) {\n        _.forOwn(attributes, (value, attribute) => {\n            if (_.isNil(value)) {\n                if (node.attributes) delete node.attributes[attribute];\n            } else {\n                if (!node.attributes) node.attributes = {};\n                node.attributes[attribute] = value;\n            }\n        });\n    },\n\n    /**\n     * Set attributes on a child node, creating the child if necessary.\n     * @param {{}} node - The parent node.\n     * @param {string} name - The name of the child node.\n     * @param {{}} attributes - The attributes to set.\n     * @returns {{}} The child.\n     */\n    setChildAttributes(node, name, attributes) {\n        let child = this.findChild(node, name);\n        _.forOwn(attributes, (value, attribute) => {\n            if (_.isNil(value)) {\n                if (child && child.attributes) delete child.attributes[attribute];\n            } else {\n                if (!child) {\n                    child = { name, attributes: {}, children: [] };\n                    this.appendChild(node, child);\n                }\n\n                if (!child.attributes) child.attributes = {};\n                child.attributes[attribute] = value;\n            }\n        });\n\n        return child;\n    },\n\n    /**\n     * Remove the child node if empty.\n     * @param {{}} node - The parent node.\n     * @param {string|{}} child - The child or name of child node.\n     * @returns {undefined}\n     */\n    removeChildIfEmpty(node, child) {\n        if (typeof child === 'string') child = this.findChild(node, child);\n        if (child && this.isEmpty(child)) this.removeChild(node, child);\n    }\n};\n"]},"metadata":{},"sourceType":"script"}