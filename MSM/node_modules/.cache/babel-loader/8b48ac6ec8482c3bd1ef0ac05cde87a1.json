{"ast":null,"code":"\"use strict\";\n/**\n * OOXML uses the CFB file format with Agile Encryption. The details of the encryption are here:\n * https://msdn.microsoft.com/en-us/library/dd950165(v=office.12).aspx\n *\n * Helpful guidance also take from this Github project:\n * https://github.com/nolze/ms-offcrypto-tool\n */\n\nconst _ = require(\"lodash\");\n\nconst cfb = require(\"cfb\");\n\nconst crypto = require(\"crypto\");\n\nconst externals = require(\"./externals\");\n\nconst XmlParser = require(\"./XmlParser\");\n\nconst XmlBuilder = require(\"./XmlBuilder\");\n\nconst xmlq = require(\"./xmlq\");\n\nconst ENCRYPTION_INFO_PREFIX = Buffer.from([0x04, 0x00, 0x04, 0x00, 0x40, 0x00, 0x00, 0x00]); // First 4 bytes are the version number, second 4 bytes are reserved.\n\nconst PACKAGE_ENCRYPTION_CHUNK_SIZE = 4096;\nconst PACKAGE_OFFSET = 8; // First 8 bytes are the size of the stream\n// Block keys used for encryption\n\nconst BLOCK_KEYS = {\n  dataIntegrity: {\n    hmacKey: Buffer.from([0x5f, 0xb2, 0xad, 0x01, 0x0c, 0xb9, 0xe1, 0xf6]),\n    hmacValue: Buffer.from([0xa0, 0x67, 0x7f, 0x02, 0xb2, 0x2c, 0x84, 0x33])\n  },\n  key: Buffer.from([0x14, 0x6e, 0x0b, 0xe7, 0xab, 0xac, 0xd0, 0xd6]),\n  verifierHash: {\n    input: Buffer.from([0xfe, 0xa7, 0xd2, 0x76, 0x3b, 0x4b, 0x9e, 0x79]),\n    value: Buffer.from([0xd7, 0xaa, 0x0f, 0x6d, 0x30, 0x61, 0x34, 0x4e])\n  }\n};\n/**\n * Encrypts/decrypts XLSXs.\n * @private\n */\n\nclass Encryptor {\n  /**\n   * Encrypt the data with the password.\n   * @param {Buffer} data - The data to encrypt\n   * @param {string} password - The password\n   * @returns {Buffer} The encrypted data\n   */\n  encrypt(data, password) {\n    // Generate a random key to use to encrypt the document. Excel uses 32 bytes. We'll use the password to encrypt this key.\n    // N.B. The number of bits needs to correspond to an algorithm available in crypto (e.g. aes-256-cbc).\n    const packageKey = crypto.randomBytes(32); // Create the encryption info. We'll use this for all of the encryption operations and for building the encryption info XML entry\n\n    const encryptionInfo = {\n      package: {\n        // Info on the encryption of the package.\n        cipherAlgorithm: 'AES',\n        // Cipher algorithm to use. Excel uses AES.\n        cipherChaining: 'ChainingModeCBC',\n        // Cipher chaining mode to use. Excel uses CBC.\n        saltValue: crypto.randomBytes(16),\n        // Random value to use as encryption salt. Excel uses 16 bytes.\n        hashAlgorithm: 'SHA512',\n        // Hash algorithm to use. Excel uses SHA512.\n        hashSize: 64,\n        // The size of the hash in bytes. SHA512 results in 64-byte hashes\n        blockSize: 16,\n        // The number of bytes used to encrypt one block of data. It MUST be at least 2, no greater than 4096, and a multiple of 2. Excel uses 16\n        keyBits: packageKey.length * 8 // The number of bits in the package key.\n\n      },\n      key: {\n        // Info on the encryption of the package key.\n        cipherAlgorithm: 'AES',\n        // Cipher algorithm to use. Excel uses AES.\n        cipherChaining: 'ChainingModeCBC',\n        // Cipher chaining mode to use. Excel uses CBC.\n        saltValue: crypto.randomBytes(16),\n        // Random value to use as encryption salt. Excel uses 16 bytes.\n        hashAlgorithm: 'SHA512',\n        // Hash algorithm to use. Excel uses SHA512.\n        hashSize: 64,\n        // The size of the hash in bytes. SHA512 results in 64-byte hashes\n        blockSize: 16,\n        // The number of bytes used to encrypt one block of data. It MUST be at least 2, no greater than 4096, and a multiple of 2. Excel uses 16\n        spinCount: 100000,\n        // The number of times to iterate on a hash of a password. It MUST NOT be greater than 10,000,000. Excel uses 100,000.\n        keyBits: 256 // The length of the key to generate from the password. Must be a multiple of 8. Excel uses 256.\n\n      }\n    };\n    /* Package Encryption */\n    // Encrypt package using the package key.\n\n    const encryptedPackage = this._cryptPackage(true, encryptionInfo.package.cipherAlgorithm, encryptionInfo.package.cipherChaining, encryptionInfo.package.hashAlgorithm, encryptionInfo.package.blockSize, encryptionInfo.package.saltValue, packageKey, data);\n    /* Data Integrity */\n    // Create the data integrity fields used by clients for integrity checks.\n    // First generate a random array of bytes to use in HMAC. The docs say to use the same length as the key salt, but Excel seems to use 64.\n\n\n    const hmacKey = crypto.randomBytes(64); // Then create an initialization vector using the package encryption info and the appropriate block key.\n\n    const hmacKeyIV = this._createIV(encryptionInfo.package.hashAlgorithm, encryptionInfo.package.saltValue, encryptionInfo.package.blockSize, BLOCK_KEYS.dataIntegrity.hmacKey); // Use the package key and the IV to encrypt the HMAC key\n\n\n    const encryptedHmacKey = this._crypt(true, encryptionInfo.package.cipherAlgorithm, encryptionInfo.package.cipherChaining, packageKey, hmacKeyIV, hmacKey); // Now create the HMAC\n\n\n    const hmacValue = this._hmac(encryptionInfo.package.hashAlgorithm, hmacKey, encryptedPackage); // Next generate an initialization vector for encrypting the resulting HMAC value.\n\n\n    const hmacValueIV = this._createIV(encryptionInfo.package.hashAlgorithm, encryptionInfo.package.saltValue, encryptionInfo.package.blockSize, BLOCK_KEYS.dataIntegrity.hmacValue); // Now encrypt the value\n\n\n    const encryptedHmacValue = this._crypt(true, encryptionInfo.package.cipherAlgorithm, encryptionInfo.package.cipherChaining, packageKey, hmacValueIV, hmacValue); // Put the encrypted key and value on the encryption info\n\n\n    encryptionInfo.dataIntegrity = {\n      encryptedHmacKey,\n      encryptedHmacValue\n    };\n    /* Key Encryption */\n    // Convert the password to an encryption key\n\n    const key = this._convertPasswordToKey(password, encryptionInfo.key.hashAlgorithm, encryptionInfo.key.saltValue, encryptionInfo.key.spinCount, encryptionInfo.key.keyBits, BLOCK_KEYS.key); // Encrypt the package key with the\n\n\n    encryptionInfo.key.encryptedKeyValue = this._crypt(true, encryptionInfo.key.cipherAlgorithm, encryptionInfo.key.cipherChaining, key, encryptionInfo.key.saltValue, packageKey);\n    /* Verifier hash */\n    // Create a random byte array for hashing\n\n    const verifierHashInput = crypto.randomBytes(16); // Create an encryption key from the password for the input\n\n    const verifierHashInputKey = this._convertPasswordToKey(password, encryptionInfo.key.hashAlgorithm, encryptionInfo.key.saltValue, encryptionInfo.key.spinCount, encryptionInfo.key.keyBits, BLOCK_KEYS.verifierHash.input); // Use the key to encrypt the verifier input\n\n\n    encryptionInfo.key.encryptedVerifierHashInput = this._crypt(true, encryptionInfo.key.cipherAlgorithm, encryptionInfo.key.cipherChaining, verifierHashInputKey, encryptionInfo.key.saltValue, verifierHashInput); // Create a hash of the input\n\n    const verifierHashValue = this._hash(encryptionInfo.key.hashAlgorithm, verifierHashInput); // Create an encryption key from the password for the hash\n\n\n    const verifierHashValueKey = this._convertPasswordToKey(password, encryptionInfo.key.hashAlgorithm, encryptionInfo.key.saltValue, encryptionInfo.key.spinCount, encryptionInfo.key.keyBits, BLOCK_KEYS.verifierHash.value); // Use the key to encrypt the hash value\n\n\n    encryptionInfo.key.encryptedVerifierHashValue = this._crypt(true, encryptionInfo.key.cipherAlgorithm, encryptionInfo.key.cipherChaining, verifierHashValueKey, encryptionInfo.key.saltValue, verifierHashValue); // Build the encryption info buffer\n\n    const encryptionInfoBuffer = this._buildEncryptionInfo(encryptionInfo); // Create a new CFB\n\n\n    let output = cfb.utils.cfb_new(); // Add the encryption info and encrypted package\n\n    cfb.utils.cfb_add(output, \"EncryptionInfo\", encryptionInfoBuffer);\n    cfb.utils.cfb_add(output, \"EncryptedPackage\", encryptedPackage); // Delete the SheetJS entry that is added at initialization\n\n    cfb.utils.cfb_del(output, \"\\u0001Sh33tJ5\"); // Write to a buffer and return\n\n    output = cfb.write(output); // The cfb library writes to a Uint8array in the browser. Convert to a Buffer.\n\n    if (!Buffer.isBuffer(output)) output = Buffer.from(output);\n    return output;\n  }\n  /**\n   * Decrypt the data with the given password\n   * @param {Buffer} data - The data to decrypt\n   * @param {string} password - The password\n   * @returns {Promise.<Buffer>} The decrypted data\n   */\n\n\n  decryptAsync(data, password) {\n    // Parse the CFB input and pull out the encryption info and encrypted package entries.\n    const parsed = cfb.parse(data);\n\n    let encryptionInfoBuffer = _.find(parsed.FileIndex, {\n      name: \"EncryptionInfo\"\n    }).content;\n\n    let encryptedPackageBuffer = _.find(parsed.FileIndex, {\n      name: \"EncryptedPackage\"\n    }).content; // In the browser the CFB content is an array. Convert to a Buffer.\n\n\n    if (!Buffer.isBuffer(encryptionInfoBuffer)) encryptionInfoBuffer = Buffer.from(encryptionInfoBuffer);\n    if (!Buffer.isBuffer(encryptedPackageBuffer)) encryptedPackageBuffer = Buffer.from(encryptedPackageBuffer);\n    return externals.Promise.resolve().then(() => this._parseEncryptionInfoAsync(encryptionInfoBuffer)) // Parse the encryption info XML into an object\n    .then(encryptionInfo => {\n      // Convert the password into an encryption key\n      const key = this._convertPasswordToKey(password, encryptionInfo.key.hashAlgorithm, encryptionInfo.key.saltValue, encryptionInfo.key.spinCount, encryptionInfo.key.keyBits, BLOCK_KEYS.key); // Use the key to decrypt the package key\n\n\n      const packageKey = this._crypt(false, encryptionInfo.key.cipherAlgorithm, encryptionInfo.key.cipherChaining, key, encryptionInfo.key.saltValue, encryptionInfo.key.encryptedKeyValue); // Use the package key to decrypt the package\n\n\n      return this._cryptPackage(false, encryptionInfo.package.cipherAlgorithm, encryptionInfo.package.cipherChaining, encryptionInfo.package.hashAlgorithm, encryptionInfo.package.blockSize, encryptionInfo.package.saltValue, packageKey, encryptedPackageBuffer);\n    });\n  }\n  /**\n   * Build the encryption info XML/buffer\n   * @param {{}} encryptionInfo - The encryption info object\n   * @returns {Buffer} The buffer\n   * @private\n   */\n\n\n  _buildEncryptionInfo(encryptionInfo) {\n    // Map the object into the appropriate XML structure. Buffers are encoded in base 64.\n    const encryptionInfoNode = {\n      name: \"encryption\",\n      attributes: {\n        xmlns: \"http://schemas.microsoft.com/office/2006/encryption\",\n        'xmlns:p': \"http://schemas.microsoft.com/office/2006/keyEncryptor/password\",\n        'xmlns:c': \"http://schemas.microsoft.com/office/2006/keyEncryptor/certificate\"\n      },\n      children: [{\n        name: \"keyData\",\n        attributes: {\n          saltSize: encryptionInfo.package.saltValue.length,\n          blockSize: encryptionInfo.package.blockSize,\n          keyBits: encryptionInfo.package.keyBits,\n          hashSize: encryptionInfo.package.hashSize,\n          cipherAlgorithm: encryptionInfo.package.cipherAlgorithm,\n          cipherChaining: encryptionInfo.package.cipherChaining,\n          hashAlgorithm: encryptionInfo.package.hashAlgorithm,\n          saltValue: encryptionInfo.package.saltValue.toString(\"base64\")\n        }\n      }, {\n        name: \"dataIntegrity\",\n        attributes: {\n          encryptedHmacKey: encryptionInfo.dataIntegrity.encryptedHmacKey.toString(\"base64\"),\n          encryptedHmacValue: encryptionInfo.dataIntegrity.encryptedHmacValue.toString(\"base64\")\n        }\n      }, {\n        name: \"keyEncryptors\",\n        children: [{\n          name: \"keyEncryptor\",\n          attributes: {\n            uri: \"http://schemas.microsoft.com/office/2006/keyEncryptor/password\"\n          },\n          children: [{\n            name: \"p:encryptedKey\",\n            attributes: {\n              spinCount: encryptionInfo.key.spinCount,\n              saltSize: encryptionInfo.key.saltValue.length,\n              blockSize: encryptionInfo.key.blockSize,\n              keyBits: encryptionInfo.key.keyBits,\n              hashSize: encryptionInfo.key.hashSize,\n              cipherAlgorithm: encryptionInfo.key.cipherAlgorithm,\n              cipherChaining: encryptionInfo.key.cipherChaining,\n              hashAlgorithm: encryptionInfo.key.hashAlgorithm,\n              saltValue: encryptionInfo.key.saltValue.toString(\"base64\"),\n              encryptedVerifierHashInput: encryptionInfo.key.encryptedVerifierHashInput.toString(\"base64\"),\n              encryptedVerifierHashValue: encryptionInfo.key.encryptedVerifierHashValue.toString(\"base64\"),\n              encryptedKeyValue: encryptionInfo.key.encryptedKeyValue.toString(\"base64\")\n            }\n          }]\n        }]\n      }]\n    }; // Convert to an XML string\n\n    const xmlBuilder = new XmlBuilder();\n    const encryptionInfoXml = xmlBuilder.build(encryptionInfoNode); // Convert to a buffer and prefix with the appropriate bytes\n\n    return Buffer.concat([ENCRYPTION_INFO_PREFIX, Buffer.from(encryptionInfoXml, \"utf8\")]);\n  }\n  /**\n   * Parse the encryption info from the XML/buffer\n   * @param {Buffer} buffer - The buffer\n   * @returns {Promise.<{}>} The parsed encryption info object\n   * @private\n   */\n\n\n  _parseEncryptionInfoAsync(buffer) {\n    // Pull off the prefix and convert to string\n    const xml = buffer.slice(ENCRYPTION_INFO_PREFIX.length).toString(\"utf8\"); // Parse the XML\n\n    const xmlParser = new XmlParser();\n    return xmlParser.parseAsync(xml).then(doc => {\n      // Pull out the relevant values for decryption and return\n      const keyDataNode = xmlq.findChild(doc, \"keyData\");\n      const keyEncryptorsNode = xmlq.findChild(doc, \"keyEncryptors\");\n      const keyEncryptorNode = xmlq.findChild(keyEncryptorsNode, \"keyEncryptor\");\n      const encryptedKeyNode = xmlq.findChild(keyEncryptorNode, \"p:encryptedKey\");\n      return {\n        package: {\n          cipherAlgorithm: keyDataNode.attributes.cipherAlgorithm,\n          cipherChaining: keyDataNode.attributes.cipherChaining,\n          saltValue: Buffer.from(keyDataNode.attributes.saltValue, \"base64\"),\n          hashAlgorithm: keyDataNode.attributes.hashAlgorithm,\n          blockSize: keyDataNode.attributes.blockSize\n        },\n        key: {\n          encryptedKeyValue: Buffer.from(encryptedKeyNode.attributes.encryptedKeyValue, \"base64\"),\n          cipherAlgorithm: encryptedKeyNode.attributes.cipherAlgorithm,\n          cipherChaining: encryptedKeyNode.attributes.cipherChaining,\n          saltValue: Buffer.from(encryptedKeyNode.attributes.saltValue, \"base64\"),\n          hashAlgorithm: encryptedKeyNode.attributes.hashAlgorithm,\n          spinCount: encryptedKeyNode.attributes.spinCount,\n          keyBits: encryptedKeyNode.attributes.keyBits\n        }\n      };\n    });\n  }\n  /**\n   * Calculate a hash of the concatenated buffers with the given algorithm.\n   * @param {string} algorithm - The hash algorithm.\n   * @param {Array.<Buffer>} buffers - The buffers to concat and hash\n   * @returns {Buffer} The hash\n   * @private\n   */\n\n\n  _hash(algorithm, ...buffers) {\n    algorithm = algorithm.toLowerCase();\n    const hashes = crypto.getHashes();\n    if (hashes.indexOf(algorithm) < 0) throw new Error(`Hash algorithm '${algorithm}' not supported!`);\n    const hash = crypto.createHash(algorithm);\n    hash.update(Buffer.concat(buffers));\n    return hash.digest();\n  }\n  /**\n   * Calculate an HMAC of the concatenated buffers with the given algorithm and key\n   * @param {string} algorithm - The algorithm.\n   * @param {string} key - The key\n   * @param {Array.<Buffer>} buffers - The buffer to concat and HMAC\n   * @returns {Buffer} The HMAC\n   * @private\n   */\n\n\n  _hmac(algorithm, key, ...buffers) {\n    algorithm = algorithm.toLowerCase();\n    const hashes = crypto.getHashes();\n    if (hashes.indexOf(algorithm) < 0) throw new Error(`HMAC algorithm '${algorithm}' not supported!`);\n    const hmac = crypto.createHmac(algorithm, key);\n    hmac.update(Buffer.concat(buffers));\n    return hmac.digest();\n  }\n  /**\n   * Encrypt/decrypt input\n   * @param {boolean} encrypt - True to encrypt, false to decrypt\n   * @param {string} cipherAlgorithm - The cipher algorithm\n   * @param {sring} cipherChaining - The cipher chaining mode\n   * @param {Buffer} key - The encryption key\n   * @param {Buffer} iv - The initialization vector\n   * @param {Buffer} input - The input\n   * @returns {Buffer} The output\n   * @private\n   */\n\n\n  _crypt(encrypt, cipherAlgorithm, cipherChaining, key, iv, input) {\n    let algorithm = `${cipherAlgorithm.toLowerCase()}-${key.length * 8}`;\n    if (cipherChaining === 'ChainingModeCBC') algorithm += '-cbc';else throw new Error(`Unknown cipher chaining: ${cipherChaining}`);\n    const cipher = crypto[encrypt ? 'createCipheriv' : 'createDecipheriv'](algorithm, key, iv);\n    cipher.setAutoPadding(false);\n    let output = cipher.update(input);\n    output = Buffer.concat([output, cipher.final()]);\n    return output;\n  }\n  /**\n   * Encrypt/decrypt the package\n   * @param {boolean} encrypt - True to encrypt, false to decrypt\n   * @param {string} cipherAlgorithm - The cipher algorithm\n   * @param {string} cipherChaining - The cipher chaining mode\n   * @param {string} hashAlgorithm - The hash algorithm\n   * @param {number} blockSize - The IV block size\n   * @param {Buffer} saltValue - The salt\n   * @param {Buffer} key - The encryption key\n   * @param {Buffer} input - The package input\n   * @returns {Buffer} The output\n   * @private\n   */\n\n\n  _cryptPackage(encrypt, cipherAlgorithm, cipherChaining, hashAlgorithm, blockSize, saltValue, key, input) {\n    // The first 8 bytes is supposed to be the length, but it seems like it is really the length - 4..\n    const outputChunks = [];\n    const offset = encrypt ? 0 : PACKAGE_OFFSET; // The package is encoded in chunks. Encrypt/decrypt each and concat.\n\n    let i = 0,\n        start = 0,\n        end = 0;\n\n    while (end < input.length) {\n      start = end;\n      end = start + PACKAGE_ENCRYPTION_CHUNK_SIZE;\n      if (end > input.length) end = input.length; // Grab the next chunk\n\n      let inputChunk = input.slice(start + offset, end + offset); // Pad the chunk if it is not an integer multiple of the block size\n\n      const remainder = inputChunk.length % blockSize;\n      if (remainder) inputChunk = Buffer.concat([inputChunk, Buffer.alloc(blockSize - remainder)]); // Create the initialization vector\n\n      const iv = this._createIV(hashAlgorithm, saltValue, blockSize, i); // Encrypt/decrypt the chunk and add it to the array\n\n\n      const outputChunk = this._crypt(encrypt, cipherAlgorithm, cipherChaining, key, iv, inputChunk);\n\n      outputChunks.push(outputChunk);\n      i++;\n    } // Concat all of the output chunks.\n\n\n    let output = Buffer.concat(outputChunks);\n\n    if (encrypt) {\n      // Put the length of the package in the first 8 bytes\n      output = Buffer.concat([this._createUInt32LEBuffer(input.length, PACKAGE_OFFSET), output]);\n    } else {\n      // Truncate the buffer to the size in the prefix\n      const length = input.readUInt32LE(0);\n      output = output.slice(0, length);\n    }\n\n    return output;\n  }\n  /**\n   * Create a buffer of an integer encoded as a uint32le\n   * @param {number} value - The integer to encode\n   * @param {number} [bufferSize=4] The output buffer size in bytes\n   * @returns {Buffer} The buffer\n   * @private\n   */\n\n\n  _createUInt32LEBuffer(value, bufferSize = 4) {\n    const buffer = Buffer.alloc(bufferSize);\n    buffer.writeUInt32LE(value, 0);\n    return buffer;\n  }\n  /**\n   * Convert a password into an encryption key\n   * @param {string} password - The password\n   * @param {string} hashAlgorithm - The hash algoritm\n   * @param {Buffer} saltValue - The salt value\n   * @param {number} spinCount - The spin count\n   * @param {number} keyBits - The length of the key in bits\n   * @param {Buffer} blockKey - The block key\n   * @returns {Buffer} The encryption key\n   * @private\n   */\n\n\n  _convertPasswordToKey(password, hashAlgorithm, saltValue, spinCount, keyBits, blockKey) {\n    // Password must be in unicode buffer\n    const passwordBuffer = Buffer.from(password, 'utf16le'); // Generate the initial hash\n\n    let key = this._hash(hashAlgorithm, saltValue, passwordBuffer); // Now regenerate until spin count\n\n\n    for (let i = 0; i < spinCount; i++) {\n      const iterator = this._createUInt32LEBuffer(i);\n\n      key = this._hash(hashAlgorithm, iterator, key);\n    } // Now generate the final hash\n\n\n    key = this._hash(hashAlgorithm, key, blockKey); // Truncate or pad as needed to get to length of keyBits\n\n    const keyBytes = keyBits / 8;\n\n    if (key.length < keyBytes) {\n      const tmp = Buffer.alloc(keyBytes, 0x36);\n      key.copy(tmp);\n      key = tmp;\n    } else if (key.length > keyBytes) {\n      key = key.slice(0, keyBytes);\n    }\n\n    return key;\n  }\n  /**\n   * Create an initialization vector (IV)\n   * @param {string} hashAlgorithm - The hash algorithm\n   * @param {Buffer} saltValue - The salt value\n   * @param {number} blockSize - The size of the IV\n   * @param {Buffer|number} blockKey - The block key or an int to convert to a buffer\n   * @returns {Buffer} The IV\n   * @private\n   */\n\n\n  _createIV(hashAlgorithm, saltValue, blockSize, blockKey) {\n    // Create the block key from the current index\n    if (typeof blockKey === \"number\") blockKey = this._createUInt32LEBuffer(blockKey); // Create the initialization vector by hashing the salt with the block key.\n    // Truncate or pad as needed to meet the block size.\n\n    let iv = this._hash(hashAlgorithm, saltValue, blockKey);\n\n    if (iv.length < blockSize) {\n      const tmp = Buffer.alloc(blockSize, 0x36);\n      iv.copy(tmp);\n      iv = tmp;\n    } else if (iv.length > blockSize) {\n      iv = iv.slice(0, blockSize);\n    }\n\n    return iv;\n  }\n\n}\n\nmodule.exports = Encryptor;","map":{"version":3,"sources":["C:/Users/tzika/Desktop/Polymerlink-Front/polymerlink-2/node_modules/xlsx-populate/lib/Encryptor.js"],"names":["_","require","cfb","crypto","externals","XmlParser","XmlBuilder","xmlq","ENCRYPTION_INFO_PREFIX","Buffer","from","PACKAGE_ENCRYPTION_CHUNK_SIZE","PACKAGE_OFFSET","BLOCK_KEYS","dataIntegrity","hmacKey","hmacValue","key","verifierHash","input","value","Encryptor","encrypt","data","password","packageKey","randomBytes","encryptionInfo","package","cipherAlgorithm","cipherChaining","saltValue","hashAlgorithm","hashSize","blockSize","keyBits","length","spinCount","encryptedPackage","_cryptPackage","hmacKeyIV","_createIV","encryptedHmacKey","_crypt","_hmac","hmacValueIV","encryptedHmacValue","_convertPasswordToKey","encryptedKeyValue","verifierHashInput","verifierHashInputKey","encryptedVerifierHashInput","verifierHashValue","_hash","verifierHashValueKey","encryptedVerifierHashValue","encryptionInfoBuffer","_buildEncryptionInfo","output","utils","cfb_new","cfb_add","cfb_del","write","isBuffer","decryptAsync","parsed","parse","find","FileIndex","name","content","encryptedPackageBuffer","Promise","resolve","then","_parseEncryptionInfoAsync","encryptionInfoNode","attributes","xmlns","children","saltSize","toString","uri","xmlBuilder","encryptionInfoXml","build","concat","buffer","xml","slice","xmlParser","parseAsync","doc","keyDataNode","findChild","keyEncryptorsNode","keyEncryptorNode","encryptedKeyNode","algorithm","buffers","toLowerCase","hashes","getHashes","indexOf","Error","hash","createHash","update","digest","hmac","createHmac","iv","cipher","setAutoPadding","final","outputChunks","offset","i","start","end","inputChunk","remainder","alloc","outputChunk","push","_createUInt32LEBuffer","readUInt32LE","bufferSize","writeUInt32LE","blockKey","passwordBuffer","iterator","keyBytes","tmp","copy","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\n/**\n * OOXML uses the CFB file format with Agile Encryption. The details of the encryption are here:\n * https://msdn.microsoft.com/en-us/library/dd950165(v=office.12).aspx\n *\n * Helpful guidance also take from this Github project:\n * https://github.com/nolze/ms-offcrypto-tool\n */\n\nconst _ = require(\"lodash\");\nconst cfb = require(\"cfb\");\nconst crypto = require(\"crypto\");\nconst externals = require(\"./externals\");\nconst XmlParser = require(\"./XmlParser\");\nconst XmlBuilder = require(\"./XmlBuilder\");\nconst xmlq = require(\"./xmlq\");\n\nconst ENCRYPTION_INFO_PREFIX = Buffer.from([0x04, 0x00, 0x04, 0x00, 0x40, 0x00, 0x00, 0x00]); // First 4 bytes are the version number, second 4 bytes are reserved.\nconst PACKAGE_ENCRYPTION_CHUNK_SIZE = 4096;\nconst PACKAGE_OFFSET = 8; // First 8 bytes are the size of the stream\n\n// Block keys used for encryption\nconst BLOCK_KEYS = {\n    dataIntegrity: {\n        hmacKey: Buffer.from([0x5f, 0xb2, 0xad, 0x01, 0x0c, 0xb9, 0xe1, 0xf6]),\n        hmacValue: Buffer.from([0xa0, 0x67, 0x7f, 0x02, 0xb2, 0x2c, 0x84, 0x33])\n    },\n    key: Buffer.from([0x14, 0x6e, 0x0b, 0xe7, 0xab, 0xac, 0xd0, 0xd6]),\n    verifierHash: {\n        input: Buffer.from([0xfe, 0xa7, 0xd2, 0x76, 0x3b, 0x4b, 0x9e, 0x79]),\n        value: Buffer.from([0xd7, 0xaa, 0x0f, 0x6d, 0x30, 0x61, 0x34, 0x4e])\n    }\n};\n\n/**\n * Encrypts/decrypts XLSXs.\n * @private\n */\nclass Encryptor {\n    /**\n     * Encrypt the data with the password.\n     * @param {Buffer} data - The data to encrypt\n     * @param {string} password - The password\n     * @returns {Buffer} The encrypted data\n     */\n    encrypt(data, password) {\n        // Generate a random key to use to encrypt the document. Excel uses 32 bytes. We'll use the password to encrypt this key.\n        // N.B. The number of bits needs to correspond to an algorithm available in crypto (e.g. aes-256-cbc).\n        const packageKey = crypto.randomBytes(32);\n\n        // Create the encryption info. We'll use this for all of the encryption operations and for building the encryption info XML entry\n        const encryptionInfo = {\n            package: { // Info on the encryption of the package.\n                cipherAlgorithm: 'AES', // Cipher algorithm to use. Excel uses AES.\n                cipherChaining: 'ChainingModeCBC', // Cipher chaining mode to use. Excel uses CBC.\n                saltValue: crypto.randomBytes(16), // Random value to use as encryption salt. Excel uses 16 bytes.\n                hashAlgorithm: 'SHA512', // Hash algorithm to use. Excel uses SHA512.\n                hashSize: 64, // The size of the hash in bytes. SHA512 results in 64-byte hashes\n                blockSize: 16, // The number of bytes used to encrypt one block of data. It MUST be at least 2, no greater than 4096, and a multiple of 2. Excel uses 16\n                keyBits: packageKey.length * 8 // The number of bits in the package key.\n            },\n            key: { // Info on the encryption of the package key.\n                cipherAlgorithm: 'AES', // Cipher algorithm to use. Excel uses AES.\n                cipherChaining: 'ChainingModeCBC', // Cipher chaining mode to use. Excel uses CBC.\n                saltValue: crypto.randomBytes(16), // Random value to use as encryption salt. Excel uses 16 bytes.\n                hashAlgorithm: 'SHA512', // Hash algorithm to use. Excel uses SHA512.\n                hashSize: 64, // The size of the hash in bytes. SHA512 results in 64-byte hashes\n                blockSize: 16, // The number of bytes used to encrypt one block of data. It MUST be at least 2, no greater than 4096, and a multiple of 2. Excel uses 16\n                spinCount: 100000, // The number of times to iterate on a hash of a password. It MUST NOT be greater than 10,000,000. Excel uses 100,000.\n                keyBits: 256 // The length of the key to generate from the password. Must be a multiple of 8. Excel uses 256.\n            }\n        };\n\n        /* Package Encryption */\n\n        // Encrypt package using the package key.\n        const encryptedPackage = this._cryptPackage(\n            true,\n            encryptionInfo.package.cipherAlgorithm,\n            encryptionInfo.package.cipherChaining,\n            encryptionInfo.package.hashAlgorithm,\n            encryptionInfo.package.blockSize,\n            encryptionInfo.package.saltValue,\n            packageKey,\n            data\n        );\n\n        /* Data Integrity */\n\n        // Create the data integrity fields used by clients for integrity checks.\n        // First generate a random array of bytes to use in HMAC. The docs say to use the same length as the key salt, but Excel seems to use 64.\n        const hmacKey = crypto.randomBytes(64);\n\n        // Then create an initialization vector using the package encryption info and the appropriate block key.\n        const hmacKeyIV = this._createIV(\n            encryptionInfo.package.hashAlgorithm,\n            encryptionInfo.package.saltValue,\n            encryptionInfo.package.blockSize,\n            BLOCK_KEYS.dataIntegrity.hmacKey\n        );\n\n        // Use the package key and the IV to encrypt the HMAC key\n        const encryptedHmacKey = this._crypt(\n            true,\n            encryptionInfo.package.cipherAlgorithm,\n            encryptionInfo.package.cipherChaining,\n            packageKey,\n            hmacKeyIV,\n            hmacKey);\n\n        // Now create the HMAC\n        const hmacValue = this._hmac(encryptionInfo.package.hashAlgorithm, hmacKey, encryptedPackage);\n\n        // Next generate an initialization vector for encrypting the resulting HMAC value.\n        const hmacValueIV = this._createIV(\n            encryptionInfo.package.hashAlgorithm,\n            encryptionInfo.package.saltValue,\n            encryptionInfo.package.blockSize,\n            BLOCK_KEYS.dataIntegrity.hmacValue\n        );\n\n        // Now encrypt the value\n        const encryptedHmacValue = this._crypt(\n            true,\n            encryptionInfo.package.cipherAlgorithm,\n            encryptionInfo.package.cipherChaining,\n            packageKey,\n            hmacValueIV,\n            hmacValue\n        );\n\n        // Put the encrypted key and value on the encryption info\n        encryptionInfo.dataIntegrity = {\n            encryptedHmacKey,\n            encryptedHmacValue\n        };\n\n        /* Key Encryption */\n\n        // Convert the password to an encryption key\n        const key = this._convertPasswordToKey(\n            password,\n            encryptionInfo.key.hashAlgorithm,\n            encryptionInfo.key.saltValue,\n            encryptionInfo.key.spinCount,\n            encryptionInfo.key.keyBits,\n            BLOCK_KEYS.key\n        );\n\n        // Encrypt the package key with the\n        encryptionInfo.key.encryptedKeyValue = this._crypt(\n            true,\n            encryptionInfo.key.cipherAlgorithm,\n            encryptionInfo.key.cipherChaining,\n            key,\n            encryptionInfo.key.saltValue,\n            packageKey);\n\n        /* Verifier hash */\n\n        // Create a random byte array for hashing\n        const verifierHashInput = crypto.randomBytes(16);\n\n        // Create an encryption key from the password for the input\n        const verifierHashInputKey = this._convertPasswordToKey(\n            password,\n            encryptionInfo.key.hashAlgorithm,\n            encryptionInfo.key.saltValue,\n            encryptionInfo.key.spinCount,\n            encryptionInfo.key.keyBits,\n            BLOCK_KEYS.verifierHash.input\n        );\n\n        // Use the key to encrypt the verifier input\n        encryptionInfo.key.encryptedVerifierHashInput = this._crypt(\n            true,\n            encryptionInfo.key.cipherAlgorithm,\n            encryptionInfo.key.cipherChaining,\n            verifierHashInputKey,\n            encryptionInfo.key.saltValue,\n            verifierHashInput\n        );\n\n        // Create a hash of the input\n        const verifierHashValue = this._hash(encryptionInfo.key.hashAlgorithm, verifierHashInput);\n\n        // Create an encryption key from the password for the hash\n        const verifierHashValueKey = this._convertPasswordToKey(\n            password,\n            encryptionInfo.key.hashAlgorithm,\n            encryptionInfo.key.saltValue,\n            encryptionInfo.key.spinCount,\n            encryptionInfo.key.keyBits,\n            BLOCK_KEYS.verifierHash.value\n        );\n\n        // Use the key to encrypt the hash value\n        encryptionInfo.key.encryptedVerifierHashValue = this._crypt(\n            true,\n            encryptionInfo.key.cipherAlgorithm,\n            encryptionInfo.key.cipherChaining,\n            verifierHashValueKey,\n            encryptionInfo.key.saltValue,\n            verifierHashValue\n        );\n\n        // Build the encryption info buffer\n        const encryptionInfoBuffer = this._buildEncryptionInfo(encryptionInfo);\n\n        // Create a new CFB\n        let output = cfb.utils.cfb_new();\n\n        // Add the encryption info and encrypted package\n        cfb.utils.cfb_add(output, \"EncryptionInfo\", encryptionInfoBuffer);\n        cfb.utils.cfb_add(output, \"EncryptedPackage\", encryptedPackage);\n\n        // Delete the SheetJS entry that is added at initialization\n        cfb.utils.cfb_del(output, \"\\u0001Sh33tJ5\");\n\n        // Write to a buffer and return\n        output = cfb.write(output);\n\n        // The cfb library writes to a Uint8array in the browser. Convert to a Buffer.\n        if (!Buffer.isBuffer(output)) output = Buffer.from(output);\n\n        return output;\n    }\n\n    /**\n     * Decrypt the data with the given password\n     * @param {Buffer} data - The data to decrypt\n     * @param {string} password - The password\n     * @returns {Promise.<Buffer>} The decrypted data\n     */\n    decryptAsync(data, password) {\n        // Parse the CFB input and pull out the encryption info and encrypted package entries.\n        const parsed = cfb.parse(data);\n        let encryptionInfoBuffer = _.find(parsed.FileIndex, { name: \"EncryptionInfo\" }).content;\n        let encryptedPackageBuffer = _.find(parsed.FileIndex, { name: \"EncryptedPackage\" }).content;\n\n        // In the browser the CFB content is an array. Convert to a Buffer.\n        if (!Buffer.isBuffer(encryptionInfoBuffer)) encryptionInfoBuffer = Buffer.from(encryptionInfoBuffer);\n        if (!Buffer.isBuffer(encryptedPackageBuffer)) encryptedPackageBuffer = Buffer.from(encryptedPackageBuffer);\n\n        return externals.Promise.resolve()\n            .then(() => this._parseEncryptionInfoAsync(encryptionInfoBuffer)) // Parse the encryption info XML into an object\n            .then(encryptionInfo => {\n                // Convert the password into an encryption key\n                const key = this._convertPasswordToKey(\n                    password,\n                    encryptionInfo.key.hashAlgorithm,\n                    encryptionInfo.key.saltValue,\n                    encryptionInfo.key.spinCount,\n                    encryptionInfo.key.keyBits,\n                    BLOCK_KEYS.key\n                );\n\n                // Use the key to decrypt the package key\n                const packageKey = this._crypt(\n                    false,\n                    encryptionInfo.key.cipherAlgorithm,\n                    encryptionInfo.key.cipherChaining,\n                    key,\n                    encryptionInfo.key.saltValue,\n                    encryptionInfo.key.encryptedKeyValue\n                );\n\n                // Use the package key to decrypt the package\n                return this._cryptPackage(\n                    false,\n                    encryptionInfo.package.cipherAlgorithm,\n                    encryptionInfo.package.cipherChaining,\n                    encryptionInfo.package.hashAlgorithm,\n                    encryptionInfo.package.blockSize,\n                    encryptionInfo.package.saltValue,\n                    packageKey,\n                    encryptedPackageBuffer);\n            });\n    }\n\n    /**\n     * Build the encryption info XML/buffer\n     * @param {{}} encryptionInfo - The encryption info object\n     * @returns {Buffer} The buffer\n     * @private\n     */\n    _buildEncryptionInfo(encryptionInfo) {\n        // Map the object into the appropriate XML structure. Buffers are encoded in base 64.\n        const encryptionInfoNode = {\n            name: \"encryption\",\n            attributes: {\n                xmlns: \"http://schemas.microsoft.com/office/2006/encryption\",\n                'xmlns:p': \"http://schemas.microsoft.com/office/2006/keyEncryptor/password\",\n                'xmlns:c': \"http://schemas.microsoft.com/office/2006/keyEncryptor/certificate\"\n            },\n            children: [\n                {\n                    name: \"keyData\",\n                    attributes: {\n                        saltSize: encryptionInfo.package.saltValue.length,\n                        blockSize: encryptionInfo.package.blockSize,\n                        keyBits: encryptionInfo.package.keyBits,\n                        hashSize: encryptionInfo.package.hashSize,\n                        cipherAlgorithm: encryptionInfo.package.cipherAlgorithm,\n                        cipherChaining: encryptionInfo.package.cipherChaining,\n                        hashAlgorithm: encryptionInfo.package.hashAlgorithm,\n                        saltValue: encryptionInfo.package.saltValue.toString(\"base64\")\n                    }\n                },\n                {\n                    name: \"dataIntegrity\",\n                    attributes: {\n                        encryptedHmacKey: encryptionInfo.dataIntegrity.encryptedHmacKey.toString(\"base64\"),\n                        encryptedHmacValue: encryptionInfo.dataIntegrity.encryptedHmacValue.toString(\"base64\")\n                    }\n                },\n                {\n                    name: \"keyEncryptors\",\n                    children: [\n                        {\n                            name: \"keyEncryptor\",\n                            attributes: {\n                                uri: \"http://schemas.microsoft.com/office/2006/keyEncryptor/password\"\n                            },\n                            children: [\n                                {\n                                    name: \"p:encryptedKey\",\n                                    attributes: {\n                                        spinCount: encryptionInfo.key.spinCount,\n                                        saltSize: encryptionInfo.key.saltValue.length,\n                                        blockSize: encryptionInfo.key.blockSize,\n                                        keyBits: encryptionInfo.key.keyBits,\n                                        hashSize: encryptionInfo.key.hashSize,\n                                        cipherAlgorithm: encryptionInfo.key.cipherAlgorithm,\n                                        cipherChaining: encryptionInfo.key.cipherChaining,\n                                        hashAlgorithm: encryptionInfo.key.hashAlgorithm,\n                                        saltValue: encryptionInfo.key.saltValue.toString(\"base64\"),\n                                        encryptedVerifierHashInput: encryptionInfo.key.encryptedVerifierHashInput.toString(\"base64\"),\n                                        encryptedVerifierHashValue: encryptionInfo.key.encryptedVerifierHashValue.toString(\"base64\"),\n                                        encryptedKeyValue: encryptionInfo.key.encryptedKeyValue.toString(\"base64\")\n                                    }\n                                }\n                            ]\n                        }\n                    ]\n                }\n            ]\n        };\n\n        // Convert to an XML string\n        const xmlBuilder = new XmlBuilder();\n        const encryptionInfoXml = xmlBuilder.build(encryptionInfoNode);\n\n        // Convert to a buffer and prefix with the appropriate bytes\n        return Buffer.concat([ENCRYPTION_INFO_PREFIX, Buffer.from(encryptionInfoXml, \"utf8\")]);\n    }\n\n    /**\n     * Parse the encryption info from the XML/buffer\n     * @param {Buffer} buffer - The buffer\n     * @returns {Promise.<{}>} The parsed encryption info object\n     * @private\n     */\n    _parseEncryptionInfoAsync(buffer) {\n        // Pull off the prefix and convert to string\n        const xml = buffer.slice(ENCRYPTION_INFO_PREFIX.length).toString(\"utf8\");\n\n        // Parse the XML\n        const xmlParser = new XmlParser();\n        return xmlParser.parseAsync(xml)\n            .then(doc => {\n                // Pull out the relevant values for decryption and return\n                const keyDataNode = xmlq.findChild(doc, \"keyData\");\n                const keyEncryptorsNode = xmlq.findChild(doc, \"keyEncryptors\");\n                const keyEncryptorNode = xmlq.findChild(keyEncryptorsNode, \"keyEncryptor\");\n                const encryptedKeyNode = xmlq.findChild(keyEncryptorNode, \"p:encryptedKey\");\n\n                return {\n                    package: {\n                        cipherAlgorithm: keyDataNode.attributes.cipherAlgorithm,\n                        cipherChaining: keyDataNode.attributes.cipherChaining,\n                        saltValue: Buffer.from(keyDataNode.attributes.saltValue, \"base64\"),\n                        hashAlgorithm: keyDataNode.attributes.hashAlgorithm,\n                        blockSize: keyDataNode.attributes.blockSize\n                    },\n                    key: {\n                        encryptedKeyValue: Buffer.from(encryptedKeyNode.attributes.encryptedKeyValue, \"base64\"),\n                        cipherAlgorithm: encryptedKeyNode.attributes.cipherAlgorithm,\n                        cipherChaining: encryptedKeyNode.attributes.cipherChaining,\n                        saltValue: Buffer.from(encryptedKeyNode.attributes.saltValue, \"base64\"),\n                        hashAlgorithm: encryptedKeyNode.attributes.hashAlgorithm,\n                        spinCount: encryptedKeyNode.attributes.spinCount,\n                        keyBits: encryptedKeyNode.attributes.keyBits\n                    }\n                };\n            });\n    }\n\n    /**\n     * Calculate a hash of the concatenated buffers with the given algorithm.\n     * @param {string} algorithm - The hash algorithm.\n     * @param {Array.<Buffer>} buffers - The buffers to concat and hash\n     * @returns {Buffer} The hash\n     * @private\n     */\n    _hash(algorithm, ...buffers) {\n        algorithm = algorithm.toLowerCase();\n        const hashes = crypto.getHashes();\n        if (hashes.indexOf(algorithm) < 0) throw new Error(`Hash algorithm '${algorithm}' not supported!`);\n\n        const hash = crypto.createHash(algorithm);\n        hash.update(Buffer.concat(buffers));\n        return hash.digest();\n    }\n\n    /**\n     * Calculate an HMAC of the concatenated buffers with the given algorithm and key\n     * @param {string} algorithm - The algorithm.\n     * @param {string} key - The key\n     * @param {Array.<Buffer>} buffers - The buffer to concat and HMAC\n     * @returns {Buffer} The HMAC\n     * @private\n     */\n    _hmac(algorithm, key, ...buffers) {\n        algorithm = algorithm.toLowerCase();\n        const hashes = crypto.getHashes();\n        if (hashes.indexOf(algorithm) < 0) throw new Error(`HMAC algorithm '${algorithm}' not supported!`);\n\n        const hmac = crypto.createHmac(algorithm, key);\n        hmac.update(Buffer.concat(buffers));\n        return hmac.digest();\n    }\n\n    /**\n     * Encrypt/decrypt input\n     * @param {boolean} encrypt - True to encrypt, false to decrypt\n     * @param {string} cipherAlgorithm - The cipher algorithm\n     * @param {sring} cipherChaining - The cipher chaining mode\n     * @param {Buffer} key - The encryption key\n     * @param {Buffer} iv - The initialization vector\n     * @param {Buffer} input - The input\n     * @returns {Buffer} The output\n     * @private\n     */\n    _crypt(encrypt, cipherAlgorithm, cipherChaining, key, iv, input) {\n        let algorithm = `${cipherAlgorithm.toLowerCase()}-${key.length * 8}`;\n        if (cipherChaining === 'ChainingModeCBC') algorithm += '-cbc';\n        else throw new Error(`Unknown cipher chaining: ${cipherChaining}`);\n\n        const cipher = crypto[encrypt ? 'createCipheriv' : 'createDecipheriv'](algorithm, key, iv);\n        cipher.setAutoPadding(false);\n        let output = cipher.update(input);\n        output = Buffer.concat([output, cipher.final()]);\n        return output;\n    }\n\n    /**\n     * Encrypt/decrypt the package\n     * @param {boolean} encrypt - True to encrypt, false to decrypt\n     * @param {string} cipherAlgorithm - The cipher algorithm\n     * @param {string} cipherChaining - The cipher chaining mode\n     * @param {string} hashAlgorithm - The hash algorithm\n     * @param {number} blockSize - The IV block size\n     * @param {Buffer} saltValue - The salt\n     * @param {Buffer} key - The encryption key\n     * @param {Buffer} input - The package input\n     * @returns {Buffer} The output\n     * @private\n     */\n    _cryptPackage(encrypt, cipherAlgorithm, cipherChaining, hashAlgorithm, blockSize, saltValue, key, input) {\n        // The first 8 bytes is supposed to be the length, but it seems like it is really the length - 4..\n        const outputChunks = [];\n        const offset = encrypt ? 0 : PACKAGE_OFFSET;\n\n        // The package is encoded in chunks. Encrypt/decrypt each and concat.\n        let i = 0, start = 0, end = 0;\n        while (end < input.length) {\n            start = end;\n            end = start + PACKAGE_ENCRYPTION_CHUNK_SIZE;\n            if (end > input.length) end = input.length;\n\n            // Grab the next chunk\n            let inputChunk = input.slice(start + offset, end + offset);\n\n            // Pad the chunk if it is not an integer multiple of the block size\n            const remainder = inputChunk.length % blockSize;\n            if (remainder) inputChunk = Buffer.concat([inputChunk, Buffer.alloc(blockSize - remainder)]);\n\n            // Create the initialization vector\n            const iv = this._createIV(hashAlgorithm, saltValue, blockSize, i);\n\n            // Encrypt/decrypt the chunk and add it to the array\n            const outputChunk = this._crypt(encrypt, cipherAlgorithm, cipherChaining, key, iv, inputChunk);\n            outputChunks.push(outputChunk);\n\n            i++;\n        }\n\n        // Concat all of the output chunks.\n        let output = Buffer.concat(outputChunks);\n\n        if (encrypt) {\n            // Put the length of the package in the first 8 bytes\n            output = Buffer.concat([this._createUInt32LEBuffer(input.length, PACKAGE_OFFSET), output]);\n        } else {\n            // Truncate the buffer to the size in the prefix\n            const length = input.readUInt32LE(0);\n            output = output.slice(0, length);\n        }\n\n        return output;\n    }\n\n    /**\n     * Create a buffer of an integer encoded as a uint32le\n     * @param {number} value - The integer to encode\n     * @param {number} [bufferSize=4] The output buffer size in bytes\n     * @returns {Buffer} The buffer\n     * @private\n     */\n    _createUInt32LEBuffer(value, bufferSize = 4) {\n        const buffer = Buffer.alloc(bufferSize);\n        buffer.writeUInt32LE(value, 0);\n        return buffer;\n    }\n\n    /**\n     * Convert a password into an encryption key\n     * @param {string} password - The password\n     * @param {string} hashAlgorithm - The hash algoritm\n     * @param {Buffer} saltValue - The salt value\n     * @param {number} spinCount - The spin count\n     * @param {number} keyBits - The length of the key in bits\n     * @param {Buffer} blockKey - The block key\n     * @returns {Buffer} The encryption key\n     * @private\n     */\n    _convertPasswordToKey(password, hashAlgorithm, saltValue, spinCount, keyBits, blockKey) {\n        // Password must be in unicode buffer\n        const passwordBuffer = Buffer.from(password, 'utf16le');\n\n        // Generate the initial hash\n        let key = this._hash(hashAlgorithm, saltValue, passwordBuffer);\n\n        // Now regenerate until spin count\n        for (let i = 0; i < spinCount; i++) {\n            const iterator = this._createUInt32LEBuffer(i);\n            key = this._hash(hashAlgorithm, iterator, key);\n        }\n\n        // Now generate the final hash\n        key = this._hash(hashAlgorithm, key, blockKey);\n\n        // Truncate or pad as needed to get to length of keyBits\n        const keyBytes = keyBits / 8;\n        if (key.length < keyBytes) {\n            const tmp = Buffer.alloc(keyBytes, 0x36);\n            key.copy(tmp);\n            key = tmp;\n        } else if (key.length > keyBytes) {\n            key = key.slice(0, keyBytes);\n        }\n\n        return key;\n    }\n\n    /**\n     * Create an initialization vector (IV)\n     * @param {string} hashAlgorithm - The hash algorithm\n     * @param {Buffer} saltValue - The salt value\n     * @param {number} blockSize - The size of the IV\n     * @param {Buffer|number} blockKey - The block key or an int to convert to a buffer\n     * @returns {Buffer} The IV\n     * @private\n     */\n    _createIV(hashAlgorithm, saltValue, blockSize, blockKey) {\n        // Create the block key from the current index\n        if (typeof blockKey === \"number\") blockKey = this._createUInt32LEBuffer(blockKey);\n\n        // Create the initialization vector by hashing the salt with the block key.\n        // Truncate or pad as needed to meet the block size.\n        let iv = this._hash(hashAlgorithm, saltValue, blockKey);\n        if (iv.length < blockSize) {\n            const tmp = Buffer.alloc(blockSize, 0x36);\n            iv.copy(tmp);\n            iv = tmp;\n        } else if (iv.length > blockSize) {\n            iv = iv.slice(0, blockSize);\n        }\n\n        return iv;\n    }\n}\n\nmodule.exports = Encryptor;\n"]},"metadata":{},"sourceType":"script"}